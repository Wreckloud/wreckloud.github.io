<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="个人博客">
    
    <meta name="author" content="Wreckloud_雲之残骸">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
            <link rel="preconnect" href="https://evan.beee.top" crossorigin>
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://www.wreckloud.com/2025/04/02/猎识印记-领域/javascript-进阶/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="维克罗德的世界探索笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Javascript-进阶">
<meta property="og:url" content="https://www.wreckloud.com/2025/04/02/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/Javascript-%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="渊痕爪记">
<meta property="og:description" content="维克罗德的世界探索笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.wreckloud.com/img/%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90/web.png">
<meta property="article:published_time" content="2025-04-02T04:09:57.000Z">
<meta property="article:modified_time" content="2025-04-27T12:24:46.414Z">
<meta property="article:author" content="Wreckloud">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="进阶提高">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.wreckloud.com/img/%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90/web.png">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/img/%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90/web.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90/web.png">
    <meta name="theme-color" content="#3f871e">
    <link rel="shortcut icon" href="/img/%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90/web.png">
    <!--- Page Info-->
    
    <title>
        
            Javascript-进阶 | 渊痕爪记
        
    </title>

    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    
        
            
    
            
    
            
                
                    <link rel="stylesheet" href="/css/custom.css">
                
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
        <link href="https://font.sec.miui.com/font/css?family=MiSans:400,700:MiSans" rel="stylesheet">
    
    
    
        <link href="https://font.sec.miui.com/font/css?family=MiSans:400,700:MiSans" rel="stylesheet">
    
    
        <link href="https://font.sec.miui.com/font/css?family=MiSans:400,700:MiSans" rel="stylesheet">
    
    
    
        <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/anime.min.js" ></script>
    

    <script id="hexo-configurations">
    window.config = {"hostname":"www.wreckloud.com","root":"/","language":"zh-CN","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"3px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#3f871e","secondary":"#233f15","default_mode":"dark"},"global":{"fonts":{"chinese":{"enable":true,"family":"MiSans","url":"https://font.sec.miui.com/font/css?family=MiSans:400,700:MiSans"},"english":{"enable":true,"family":"MiSans","url":"https://font.sec.miui.com/font/css?family=MiSans:400,700:MiSans"},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":true,"custom_message":null},"open_graph":{"enable":true,"image":"/img/网页资源/web.png","description":"维克罗德的世界探索笔记"},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":false,"style":"static","image":{"light":"/images/light.png","dark":"/images/dark.jpg"},"title":"世界探索笔记","subtitle":{"text":["一言读取中..."],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":0,"starting_delay":1500,"backing_delay":null,"loop":false,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":"ture","family":"MiSans","url":"https://font.sec.miui.com/font/css?family=MiSans:400,700:MiSans"},"social_links":{"enable":true,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":"1677820334@qq.com"},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"9.3.0"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#0d0e12","right":"#56597b","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Categories":{"icon":"fa-solid fa-folder","path":"/categories/"},"画廊":{"path":"/masonry","icon":"fa-regular fa-chart-bar"},"About":{"icon":"fa-solid fa-feather","path":"/links/"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"一只啥也不会又没人要的狼","show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2023/9/17 14:00:00"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":true};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    <h2 class="ml13">
        渊痕爪记
    </h2>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }
    </script>
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/img/%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90/web.png" class="w-full h-full rounded-sm">
                </a>
            
            <a class="logo-title" href="/">
                
                渊痕爪记
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    归档
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories/"
                                        >
                                    <i class="fa-solid fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/masonry"
                                        >
                                    <i class="fa-regular fa-chart-bar fa-fw"></i>
                                    画廊
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/links/"
                                        >
                                    <i class="fa-solid fa-feather fa-fw"></i>
                                    关于
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                归档
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories/"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-solid fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/masonry"
                        >
                            <span>
                                画廊
                            </span>
                            
                                <i class="fa-regular fa-chart-bar fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/links/"
                        >
                            <span>
                                关于
                            </span>
                            
                                <i class="fa-solid fa-feather fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">60</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">40</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			
			
			<img src="/img/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2/defaultcover.jpg" alt="Javascript-进阶" class="w-full h-60 sm:h-72 md:h-80 object-cover sm:rounded-t-large dark:brightness-75" />
			
			<div class="w-full flex items-center absolute bottom-0 justify-start">
				<h1 class="article-title-cover text-center mx-6 my-6 text-second-text-color bg-background-color-transparent px-4 py-3 text-3xl sm:text-4xl md:text-5xl font-semibold backdrop-blur-lg rounded-xl border border-border-color ">Javascript-进阶</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/img/%E7%BD%91%E9%A1%B5%E8%B5%84%E6%BA%90/default.png">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">Wreckloud_雲之残骸</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv4</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-04-02 12:09:57</span>
        <span class="mobile">2025-04-02 12:09:57</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-04-27 20:24:46</span>
            <span class="mobile">2025-04-27 20:24:46</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/">猎识印记-领域</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/">猎识印记-领域</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E5%89%8D%E7%AB%AF/">前端</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/JavaScript/">JavaScript</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E8%BF%9B%E9%98%B6%E6%8F%90%E9%AB%98/">进阶提高</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>17k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>69 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是变量能被访问的有效范围，本质上决定了代码中变量的可见性。理解作用域能帮助我们避免变量污染，写出更健壮的代码。<br>作用域分为两大类型：局部作用域和全局作用域，它们通过作用域链形成层级查找关系。</p>
<h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>局部作用域内的变量只能在特定范围内访问，分为两种常见形式：</p>
<ul>
<li><strong>函数作用域</strong></li>
</ul>
<p>在函数内部声明的变量（包括函数参数）形成一个封闭的独立空间。例如：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">x</span>) &#123; <span class="comment">// x 是函数作用域的局部变量</span></span><br><span class="line">  <span class="keyword">let</span> result = x * <span class="number">2</span>; <span class="comment">// result 只能在函数内部访问</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">calculate</span>(<span class="number">5</span>)); <span class="comment">// 输出 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 报错：x未定义</span></span><br></pre></td></tr></table></figure></div>

<p>函数执行完毕后，其内部变量会被销毁。不同函数之间的变量就像隔墙对话——彼此无法直接访问。</p>
<ul>
<li><strong>块作用域</strong></li>
</ul>
<p>用 <code>&#123;&#125;</code> 包裹的代码块（如 <code>if</code>&#x2F;<code>for</code> 语句）中使用 <code>let</code> 或 <code>const</code> 声明的变量会形成块作用域：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> secret = <span class="string">&quot;块内的秘密&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> oldSecret = <span class="string">&quot;老式秘密&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oldSecret); <span class="comment">// 正常输出（var 无视块作用域）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secret); <span class="comment">// 报错：secret未定义</span></span><br></pre></td></tr></table></figure></div>

<p>通过对比可以看到，<code>let</code> 将变量限制在代码块内，而 <code>var</code> 会泄漏到外层作用域。现代开发中推荐使用 <code>let/const</code> 来避免意外污染。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在 <code>&lt;script&gt;</code> 标签或 JS 文件的最外层声明的变量属于全局作用域，可以在任何位置访问：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> globalVar = <span class="string">&quot;我是全局的&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showGlobal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(globalVar); <span class="comment">// 正常访问</span></span><br><span class="line">  accidentalGlobal = <span class="string">&quot;糟糕！我成了全局变量&quot;</span>; <span class="comment">// 未使用声明关键字！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showGlobal</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(accidentalGlobal); <span class="comment">// 意外泄漏到全局</span></span><br></pre></td></tr></table></figure></div>

<p>需要特别注意：</p>
<ol>
<li>避免直接给 <code>window</code> 对象添加属性（如 <code>window.myVar = 1</code>）</li>
<li>函数内部未使用 <code>let/const/var</code> 声明的变量会变成全局变量</li>
<li>过度使用全局变量容易引发命名冲突</li>
</ol>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>是一种查找机制，在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。<br>当前作用域 → 逐级父作用域 → 全局作用域</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable language_">global</span> = <span class="string">&quot;顶层&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> middle = <span class="string">&quot;中间层&quot;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> local = <span class="string">&quot;底层&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(local);    <span class="comment">// 当前作用域找到</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(middle);  <span class="comment">// 向上查找到 outer 作用域</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">global</span>);  <span class="comment">// 继续向上查找到全局</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure></div>

<p>这种链式查找机制解释了为什么内层函数能访问外部变量，而外层无法访问内部变量。理解这个机制对调试变量未定义错误至关重要。</p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>内存管理是 JavaScript 运行时的核心机制，理解垃圾回收能帮助我们写出更高效、更安全的代码。<br>内存生命周期分为三个阶段：分配（声明变量）→ 使用（读写操作）→ 回收（自动清理），其中回收阶段通过垃圾回收器自动完成，开发者更需要关注的是如何避免内存泄漏。</p>
<p><strong>内存分配与回收规则</strong></p>
<p>当我们在函数内部声明局部变量时，这些变量就像临时便签纸——函数执行时被贴在内存墙上，执行完毕就会被自动撕下（回收）。而全局变量则像永久告示牌，会一直存在直到页面关闭：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createTemp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> tempData = <span class="string">&quot;临时数据&quot;</span>; <span class="comment">// 函数执行时创建</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tempData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">createTemp</span>(); <span class="comment">// 执行完毕后 tempData 被回收</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tempData); <span class="comment">// 报错：变量不存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> globalData = <span class="string">&quot;永久数据&quot;</span>; <span class="comment">// 全局变量持续存在</span></span><br></pre></td></tr></table></figure></div>

<p>需要警惕的是意外创建的全局变量：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">leakMemory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  leakedVar = <span class="string">&quot;本应是局部变量&quot;</span>; <span class="comment">// 缺少 let/const 声明！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">leakMemory</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(leakedVar); <span class="comment">// 意外成为全局变量</span></span><br></pre></td></tr></table></figure></div>

<h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><p>浏览器通过特定算法判断内存是否需要回收，经历了两个重要阶段：</p>
<ul>
<li><strong>引用计数法（已淘汰）</strong></li>
</ul>
<p>早期 IE 浏览器通过”记账本”机制跟踪每个对象的被引用次数：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objA = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;; <span class="comment">// 引用次数+1</span></span><br><span class="line"><span class="keyword">let</span> objB = objA;      <span class="comment">// 引用次数+1 → 总计2次</span></span><br><span class="line">objA = <span class="literal">null</span>;          <span class="comment">// 引用次数-1 → 剩余1次</span></span><br><span class="line">objB = <span class="literal">null</span>;          <span class="comment">// 引用次数-1 → 触发回收</span></span><br></pre></td></tr></table></figure></div>

<p>但当对象相互引用时会导致永久驻留内存：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createLoop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> o1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> o2 = &#123;&#125;;</span><br><span class="line">  o1.<span class="property">link</span> = o2; <span class="comment">// 形成闭环引用</span></span><br><span class="line">  o2.<span class="property">link</span> = o1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">createLoop</span>(); <span class="comment">// 即使函数执行完毕，引用次数永远≥1</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E8%BF%9B%E9%98%B6/file-20250402131711615.jpg"
                     
                ></p>
<ul>
<li><strong>标记清除法（现代方案）</strong></li>
</ul>
<p>现代浏览器采用”大扫除”机制：从全局对象出发标记所有可达对象，未被标记的视为垃圾：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> privateData = <span class="string">&quot;敏感信息&quot;</span>;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">exposedData</span> = privateData; <span class="comment">// 建立全局可达路径</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">createData</span>();</span><br><span class="line"><span class="comment">// 函数执行后 privateData 仍被全局对象引用 → 无法回收</span></span><br></pre></td></tr></table></figure></div>

<p>当需要清理时：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="variable language_">window</span>.<span class="property">exposedData</span>; <span class="comment">// 断开引用链</span></span><br><span class="line"><span class="comment">// 下次垃圾回收时 privateData 成为不可达对象 → 被回收</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E8%BF%9B%E9%98%B6/file-20250402131608201.jpg"
                     
                ></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包就像函数的专属记忆背包——<strong>当函数诞生时，它会随身携带出生地的环境变量</strong>，这种”内外函数嵌套 + 变量持续锁定”的特性，让内部函数能长期访问外部函数的变量，即使外部函数已经执行完毕。</p>
<blockquote>
<p>闭包&#x3D;内层函数+外层函数的变量</p>
</blockquote>
<p><strong>闭包的形成条件</strong></p>
<ol>
<li><strong>嵌套结构</strong>：函数内部定义另一个函数</li>
<li><strong>变量捕获</strong>：内层函数使用外层函数的变量</li>
<li><strong>跨作用域调用</strong>：内层函数在外层函数外部被使用</li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 👉 被锁定的记忆胶囊</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ++count; <span class="comment">// 🎒 每次调用都从背包取出胶囊操作</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🚀 创建携带独立背包的counter函数</span></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()); <span class="comment">// 1 👉 打开胶囊→读取0→+1→存回</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()); <span class="comment">// 2 👉 再次打开更新后的胶囊</span></span><br></pre></td></tr></table></figure></div>

<p>此时外层函数的 <code>count</code> 变量不会被回收，因为内部函数始终保持对其的引用。</p>
<h4 id="闭包的常见写法"><a href="#闭包的常见写法" class="headerlink" title="闭包的常见写法"></a>闭包的常见写法</h4><ul>
<li><strong>封装私有变量（模块模式）</strong></li>
</ul>
<p><strong>场景</strong>：需要保护数据不被外部直接修改时使用<br><strong>写法</strong>：用立即执行函数包裹，返回操作接口</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户积分模块</span></span><br><span class="line"><span class="keyword">const</span> userScore = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _score = <span class="number">0</span>; <span class="comment">// 私有变量，外部无法直接访问</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">num</span>) =&gt;</span> _score += num,</span><br><span class="line">    <span class="attr">deduct</span>: <span class="function">(<span class="params">num</span>) =&gt;</span> _score = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, _score - num),</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> _score</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">userScore.<span class="title function_">add</span>(<span class="number">50</span>);</span><br><span class="line">userScore.<span class="title function_">deduct</span>(<span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userScore.<span class="title function_">get</span>()); <span class="comment">// 30</span></span><br><span class="line"><span class="comment">// console.log(_score) → 报错，无法直接访问</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>动态生成功能函数（工厂模式）</strong></li>
</ul>
<p><strong>场景</strong>：需要批量创建功能相似但配置不同的函数时使用<br><strong>写法</strong>：外层函数接收参数，返回携带配置的新函数</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同倍数的计算器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createMultiplier</span>(<span class="params">multiplier</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num * multiplier; <span class="comment">// 闭包记住当前倍数</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> double = <span class="title function_">createMultiplier</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> triple = <span class="title function_">createMultiplier</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">double</span>(<span class="number">5</span>)); <span class="comment">// 10 → 始终用2倍计算</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">triple</span>(<span class="number">5</span>)); <span class="comment">// 15 → 始终用3倍计算</span></span><br></pre></td></tr></table></figure></div>

<h4 id="闭包的应用与风险"><a href="#闭包的应用与风险" class="headerlink" title="闭包的应用与风险"></a>闭包的应用与风险</h4><p>闭包常用于实现模块化开发，例如封装私有变量：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> student = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _score = <span class="number">60</span>; <span class="comment">// 私有变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getScore</span>: <span class="function">() =&gt;</span> _score,</span><br><span class="line">    <span class="attr">addScore</span>: <span class="function">(<span class="params">num</span>) =&gt;</span> _score += num</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="title function_">getScore</span>()); <span class="comment">// 60</span></span><br><span class="line">student.<span class="title function_">addScore</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="title function_">getScore</span>()); <span class="comment">// 70</span></span><br></pre></td></tr></table></figure></div>

<p>但不当使用会导致内存泄漏，例如在 DOM 事件中滥用闭包：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindEvents</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> bigData = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">fill</span>(<span class="string">&#x27;*&#x27;</span>); <span class="comment">// 大数据</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myBtn&#x27;</span>).<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bigData.<span class="property">length</span>); <span class="comment">// 闭包长期持有 bigData</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 即使移除按钮，bigData 仍驻留内存</span></span><br></pre></td></tr></table></figure></div>

<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>变量提升是 JavaScript 编译阶段的特殊处理机制，表现为 <strong><code>var</code> 声明的变量会提升到作用域顶部</strong>，但仅提升声明不提升赋值。这种机制容易引发代码理解错位，是许多隐蔽 Bug 的根源：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// 输出 undefined（而非报错）</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;张三&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p>等效于编译后的代码：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;          <span class="comment">// 声明提升到顶部</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// 此时 name 尚未赋值</span></span><br><span class="line">name = <span class="string">&quot;张三&quot;</span>;     <span class="comment">// 赋值留在原地</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li><code>let/const</code> 强制先声明后使用，不会出现变量提升</li>
<li>同一作用域下重复的 <code>var</code> 声明会被合并，而 <code>let/const</code> 会报错</li>
</ol>
<p>现代开发中，使用 <code>let/const</code> 配合严格模式(<code>&#39;use strict&#39;</code>) 可完全规避变量提升问题：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 报错（未声明前不可访问）</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br></pre></td></tr></table></figure></div>

<p>变量提升是早期 JS 设计妥协的产物，ES6 通过块级作用域和 <code>let/const</code> 弥补了这一缺陷。</p>
<h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p><strong>函数声明整体提升</strong><br>函数声明会带着函数体提升到作用域顶端，可在声明前调用：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 正常执行</span></span><br><span class="line"><span class="title function_">getVersion</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getVersion</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;v2.0.0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>函数表达式不提升</strong><br>通过变量赋值的函数遵循变量提升规则，仅提升变量声明：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 报错：not a function</span></span><br><span class="line"><span class="title function_">getPrice</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getPrice = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">99.9</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>等效于：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getPrice;         <span class="comment">// 变量声明提升</span></span><br><span class="line"><span class="title function_">getPrice</span>();           <span class="comment">// 此时 getPrice=undefined</span></span><br><span class="line">getPrice = <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;; <span class="comment">// 赋值留在原地</span></span><br></pre></td></tr></table></figure></div>

<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="动态参数-arguments"><a href="#动态参数-arguments" class="headerlink" title="动态参数 arguments"></a>动态参数 <code>arguments</code></h4><p>处理不确定数量的参数时，JavaScript 提供了两种方案。传统方式通过 <strong><code>arguments</code> 伪数组</strong>获取所有实参，这种方式在箭头函数中不可用且操作受限：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统求和函数（使用 arguments）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 遍历 arguments 对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    total += <span class="variable language_">arguments</span>[i]; <span class="comment">// 通过索引访问每个参数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;总和：&#x27;</span>, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSum</span>(<span class="number">2</span>, <span class="number">3</span>);        <span class="comment">// 输出：总和：5</span></span><br><span class="line"><span class="title function_">getSum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 输出：总和：10</span></span><br></pre></td></tr></table></figure></div>

<h4 id="剩余参数-arg"><a href="#剩余参数-arg" class="headerlink" title="剩余参数 ...arg"></a>剩余参数 <code>...arg</code></h4><p>现代开发更推荐使用 <strong>剩余参数</strong> 语法，直接将多余参数捕获为<strong>真数组</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 现代求和函数（使用剩余参数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">...numbers</span>) &#123; <span class="comment">// 所有参数存入 numbers 数组</span></span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  numbers.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">num</span>) &#123; <span class="comment">// 直接使用数组方法</span></span><br><span class="line">    total += num;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;总和：&#x27;</span>, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSum</span>(<span class="number">5</span>, <span class="number">10</span>);       <span class="comment">// 输出：总和：15</span></span><br><span class="line"><span class="title function_">getSum</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>);  <span class="comment">// 输出：总和：20</span></span><br></pre></td></tr></table></figure></div>

<h4 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h4><p>与剩余参数语法相同但作用相反，<strong>展开运算符</strong> 可拆解数组用于特定场景。经典应用包括：</p>
<ul>
<li>展开数组</li>
<li>合并数组</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算最高温度（参数需要独立数值）</span></span><br><span class="line"><span class="keyword">const</span> temperatures = [<span class="number">22</span>, <span class="number">19</span>, <span class="number">25</span>, <span class="number">18</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 展开运算符，然后直接拆解</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;最高温度（现代）：&#x27;</span>, <span class="title class_">Math</span>.<span class="title function_">max</span>(...temperatures)); <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 合并两个数组（不修改原数组）</span></span><br><span class="line"><span class="keyword">const</span> week1 = [<span class="string">&#x27;周一&#x27;</span>, <span class="string">&#x27;周二&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> week2 = [<span class="string">&#x27;周三&#x27;</span>, <span class="string">&#x27;周四&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> fullWeek = [...week1, ...week2];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullWeek); <span class="comment">// [&#x27;周一&#x27;, &#x27;周二&#x27;, &#x27;周三&#x27;, &#x27;周四&#x27;]</span></span><br></pre></td></tr></table></figure></div>

<p>假设需要实现一个配置函数，同时接收基础 URL 和多个配置项：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法（使用 arguments）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setConfig</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> baseURL = <span class="variable language_">arguments</span>[<span class="number">0</span>]; <span class="comment">// 手动提取第一个参数</span></span><br><span class="line">  <span class="keyword">const</span> options = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>); <span class="comment">// 截取剩余参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;基础地址：&#x27;</span>, baseURL);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;配置选项：&#x27;</span>, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setConfig</span>(<span class="string">&#x27;http://api.com&#x27;</span>, <span class="string">&#x27;timeout=3000&#x27;</span>, <span class="string">&#x27;retry=3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代写法（剩余参数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setConfig</span>(<span class="params">baseURL, ...options</span>) &#123; <span class="comment">// 自动分离参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;基础地址：&#x27;</span>, baseURL);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;配置选项：&#x27;</span>, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setConfig</span>(<span class="string">&#x27;http://api.com&#x27;</span>, <span class="string">&#x27;timeout=3000&#x27;</span>, <span class="string">&#x27;retry=3&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>箭头函数通过简化的语法结构提升代码可读性，其设计哲学在于提供更紧凑的函数表达式方案。<br>与传统函数的关键差异体现在三个方面：</p>
<p><strong>语法演进</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统函数表达式</span></span><br><span class="line"><span class="keyword">const</span> legacyFunc = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数标准形式（等效改写）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrowFunc</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>简写规则</strong></p>
<p>箭头函数通过精简语法让代码更直观，其简写规则针对常见场景做了针对性优化：</p>
<ol>
<li><strong>单参数省略括号</strong></li>
</ol>
<p>当函数<strong>只有一个参数</strong>时，可省略参数外的圆括号，让代码更紧凑：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法（带括号）</span></span><br><span class="line"><span class="keyword">const</span> double = <span class="keyword">function</span>(<span class="params">num</span>) &#123; <span class="keyword">return</span> num * <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数优化（省略括号）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">double</span> = num =&gt; num * <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>这种写法常见于简单的数学运算或数据过滤：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选正数</span></span><br><span class="line"><span class="keyword">const</span> positiveNumbers = [-<span class="number">2</span>, <span class="number">5</span>, -<span class="number">3</span>].<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">0</span>); <span class="comment">// [5]</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>单行返回值隐式返回：</strong></li>
</ol>
<p>当函数体<strong>只有一行代码</strong>时，可省略花括号和<code>return</code>关键字，结果自动返回：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统写法（需写return）</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数优化（自动返回）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br></pre></td></tr></table></figure></div>

<p>适用于简单的计算或转换：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 温度转换（华氏度→摄氏度）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fToC</span> = fahrenheit =&gt; (fahrenheit - <span class="number">32</span>) * <span class="number">5</span>/<span class="number">9</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>返回对象字面量特殊处理：</strong></li>
</ol>
<p>直接返回对象时<strong>必须包裹圆括号</strong>，避免引擎误认为代码块：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法（缺少括号）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createUser</span> = name =&gt; &#123; <span class="attr">name</span>: name &#125;; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法（包裹对象）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createUser</span> = name =&gt; (&#123; <span class="attr">name</span>: name &#125;);</span><br></pre></td></tr></table></figure></div>

<p>这种写法常见于快速构建数据对象：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成颜色配置</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getColor</span> = code =&gt; (&#123;</span><br><span class="line">  <span class="attr">hex</span>: <span class="string">`#<span class="subst">$&#123;code&#125;</span>`</span>,</span><br><span class="line">  <span class="attr">rgb</span>: <span class="string">&#x27;255,255,255&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><strong>运行时特性</strong><br>箭头函数作为表达式函数，不存在函数提升现象。这意味着：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">printHello</span>(); <span class="comment">// 正常执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printHello</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printHi</span>(); <span class="comment">// 报错：初始化前访问</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">printHi</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="箭头函数参数"><a href="#箭头函数参数" class="headerlink" title="箭头函数参数"></a>箭头函数参数</h4><p>参数处理机制体现了对传统函数缺陷的改进，<strong>剩余参数（</strong> 方案解决了 <code>arguments</code> 的伪数组问题：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统 arguments 方案（了解即可）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">legacySum</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    total += <span class="variable language_">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代剩余参数方案（推荐实践）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">modernSum</span> = (<span class="params">...nums</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="箭头函数-this"><a href="#箭头函数-this" class="headerlink" title="箭头函数 this"></a>箭头函数 this</h4><p>this 绑定机制是箭头函数最核心的特性变革，其设计目标为解决传统函数上下文绑定的混乱问题。<br>执行规则为：<strong>继承定义时的词法作用域的 this 值</strong>。</p>
<p><strong>经典场景对比</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统函数 - this 由调用方式决定</span></span><br><span class="line"><span class="keyword">const</span> timer = &#123;</span><br><span class="line">  <span class="attr">seconds</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">start</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">seconds</span>--); <span class="comment">// 错误：this 指向 window</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数 - this 静态继承</span></span><br><span class="line"><span class="keyword">const</span> timer = &#123;</span><br><span class="line">  <span class="attr">seconds</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">start</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">seconds</span>--); <span class="comment">// 正确：继承 start 的 this</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>DOM 事件处理警示</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#actionBtn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险方案（this 指向 window）</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 不符合预期的上下文</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>); <span class="comment">// 运行时错误</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐方案（保留 this 绑定）</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 指向 DOM 元素</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><strong>对象方法陷阱</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="comment">// 错误用法（箭头函数直接作为方法）</span></span><br><span class="line">  <span class="attr">printName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// this 指向外层作用域</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 正确用法（传统方法语法）</span></span><br><span class="line">  <span class="title function_">printNameValid</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// 正常访问对象属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>嵌套作用域穿透</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">child</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 箭头函数继承 parent.child 作用域的 this</span></span><br><span class="line">    <span class="attr">print</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>) <span class="comment">// 输出 undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>通过理解箭头函数的静态 this 绑定特性，我们可以更安全地处理异步回调和嵌套函数场景，但需特别注意在需要动态上下文的场景（如对象方法、DOM 事件）中的使用限制。</p>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>对象解构是一种快速提取对象属性并批量赋值的现代语法，其核心价值在于<strong>简化数据访问逻辑</strong>。<br>与传统逐个赋值的写法相比，这种语法糖（Syntactic Sugar）显著提升了代码的可读性和维护效率。</p>
<blockquote>
<p><strong>语法糖</strong>：编程语言提供的简洁写法，用更易读的形式实现原有功能。例如  <code>const &#123;name&#125; = user</code>  本质仍是属性访问，但代码更清晰直观。</p>
</blockquote>
<h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p>我们可以通过等号左侧的花括号声明需要提取的属性名，实现属性到变量的直接映射：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户数据对象</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统逐个赋值</span></span><br><span class="line"><span class="keyword">const</span> name = user.<span class="property">name</span>;</span><br><span class="line"><span class="keyword">const</span> age = user.<span class="property">age</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象解构方案</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = user;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &quot;小明&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></div>

<p><strong>关键规则</strong>：</p>
<ol>
<li><strong>属性名匹配</strong>：变量名必须与对象属性名一致</li>
<li><strong>作用域隔离</strong>：解构变量与外部作用域同名变量冲突时会报错</li>
<li><strong>安全防护</strong>：未匹配属性返回 <code>undefined</code></li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险操作（变量名冲突）</span></span><br><span class="line"><span class="keyword">let</span> title = <span class="string">&#x27;全局标题&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> post = &#123; <span class="attr">title</span>: <span class="string">&#x27;文章标题&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// const &#123; title &#125; = post; // 报错：重复声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全方案（隔离作用域）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPostInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; title &#125; = post;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(title); <span class="comment">// &quot;文章标题&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="变量重命名"><a href="#变量重命名" class="headerlink" title="变量重命名"></a>变量重命名</h4><p>当需要避免命名冲突或提升语义时，可通过冒号语法指定新变量名：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> product = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;P1001&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">99.9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名解构</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">id</span>: productId, <span class="attr">price</span>: productPrice &#125; = product;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(productId);    <span class="comment">// &quot;P1001&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(productPrice); <span class="comment">// 99.9</span></span><br></pre></td></tr></table></figure></div>

<p>这种写法常见于处理多个数据源的场景，如同时解析用户配置和系统配置：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多配置合并场景</span></span><br><span class="line"><span class="keyword">const</span> userConfig = &#123; <span class="attr">theme</span>: <span class="string">&#x27;dark&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> defaultConfig = &#123; <span class="attr">theme</span>: <span class="string">&#x27;light&#x27;</span>, <span class="attr">fontSize</span>: <span class="number">14</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">theme</span>: userTheme &#125; = userConfig;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">theme</span>: defaultTheme, fontSize &#125; = defaultConfig;</span><br></pre></td></tr></table></figure></div>

<h4 id="数组对象解构"><a href="#数组对象解构" class="headerlink" title="数组对象解构"></a>数组对象解构</h4><p>该语法同样支持从数组元素中解构对象，特别适合处理接口返回的规范化数据结构：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口返回的带元数据数组</span></span><br><span class="line"><span class="keyword">const</span> response = [&#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">data</span>: [&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;商品A&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分级解构获取核心数据</span></span><br><span class="line"><span class="keyword">const</span> [&#123;</span><br><span class="line">  <span class="attr">data</span>: [ firstItem ]</span><br><span class="line">  &#125;] = response;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstItem); <span class="comment">// &#123; id: 1, name: &#x27;商品A&#x27; &#125;</span></span><br></pre></td></tr></table></figure></div>

<p>掌握基于构造函数创建对象，理解实例化过程 2.掌握对象数组字符数字等类型的常见属性和方法，便捷完成功能</p>
<p>新的对象</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>在 JavaScript 中，我们可通过三种典型方式创建对象，其演进路线体现了从简单场景到复杂系统需求的适应过程：</p>
<p><strong>对象字面量</strong><br>作为基础创建方式，适合定义单例对象。其语法直观但复用性有限：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Peppa</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>new Object()</strong><br>是早期提供的工厂模式，本质是对象字面量的语法变体。其局限性在于无法实现定制化对象创建逻辑：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">George</span> = <span class="keyword">new</span> <span class="title class_">Object</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;乔治&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><strong>构造函数(重点)</strong><br>的引入解决了批量对象创建问题。通过将对象模板抽象为可复用的函数结构，我们实现了面向对象编程的核心特征——实例化能力：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Pig</span>(<span class="params">name, age, gender</span>) &#123; <span class="comment">// 构造函数要求**首字母大写**</span></span><br><span class="line">  <span class="comment">// this 绑定新创建实例</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Mum</span> = <span class="keyword">new</span> <span class="title class_">Pig</span>(<span class="string">&#x27;猪妈妈&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Mum</span>); <span class="comment">// Pig &#123;name: &#x27;猪妈妈&#x27;, age: 30, gender: &#x27;女&#x27;&#125;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>构造函数要求<strong>首字母大写</strong>的命名规范（如 Pig）</p>
</blockquote>
<h3 id="构造函数核心机制"><a href="#构造函数核心机制" class="headerlink" title="构造函数核心机制"></a>构造函数核心机制</h3><p>当使用 <code>new</code> 运算符调用函数时，会触发以下隐式操作：</p>
<ol>
<li>创建空对象并绑定到函数上下文（this 指向空对象）</li>
<li>执行构造函数逻辑进行属性赋值</li>
<li><strong>自动返回</strong>新创建的对象实例</li>
</ol>
<p>这一机制解释了为何构造函数中不需要显式 return 语句。</p>
<p>通过家庭成员对象的创建案例，我们可以清晰看到不同方案的适用边界：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量方案：4 次重复代码</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Peppa</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span>, <span class="attr">age</span>: <span class="number">6</span>, <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">George</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;乔治&#x27;</span>, <span class="attr">age</span>: <span class="number">3</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Mum</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;猪妈妈&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Dad</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;猪爸爸&#x27;</span>, <span class="attr">age</span>: <span class="number">32</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数方案：模板化创建</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FamilyMember</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Peppa</span> = <span class="keyword">new</span> <span class="title class_">FamilyMember</span>(<span class="string">&#x27;佩奇&#x27;</span>, <span class="number">6</span>, <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">George</span> = <span class="keyword">new</span> <span class="title class_">FamilyMember</span>(<span class="string">&#x27;乔治&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="comment">// ...其他家庭成员实例化</span></span><br></pre></td></tr></table></figure></div>

<p>当需要创建<strong>同构对象超过 2 个</strong>时，构造函数模式能显著提升代码可维护性。这种模式转变带来的收益随着系统复杂度的提升呈指数级增长。</p>
<h3 id="实例成员-静态成员"><a href="#实例成员-静态成员" class="headerlink" title="实例成员&#x2F;静态成员"></a>实例成员&#x2F;静态成员</h3><p><strong>实例成员</strong></p>
<p>实例成员是通过构造函数创建的<strong>对象专属属性与方法</strong>，每个实例对象都拥有独立的成员副本。<br>这种机制保证了对象间的数据隔离性，是面向对象编程的基础特性：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;大家好~&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>);  <span class="comment">// &quot;小明&quot;（访问实例属性）</span></span><br><span class="line">p1.<span class="title function_">sayHi</span>();            <span class="comment">// 调用实例方法</span></span><br></pre></td></tr></table></figure></div>

<p><strong>核心特性</strong>：</p>
<p>实例成员通过构造函数内的  <code>this</code>  动态绑定到每个新对象，<strong>每个实例都独立存储自己的属性和方法</strong>。<br>例如创建两个  <code>Person</code>  对象时，它们的  <code>sayHi</code>  方法互不影响，修改一个不会改变另一个。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数化构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, grade</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;李雷&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;韩梅梅&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// s1 与 s2 拥有独立数据存储</span></span><br></pre></td></tr></table></figure></div>

<p>通过构造函数参数，我们可以像流水线一样<strong>动态设置不同初始值</strong>，快速生成结构相同但数据不同的对象。</p>
<p><strong>静态成员</strong></p>
<p>静态成员是<strong>构造函数自身的属性与方法</strong>，用于实现与实例无关的公共功能。<br>其设计目标是提供类级别的工具方法：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 实例成员定义...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态属性（所有人类共有特征）</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">eyes</span> = <span class="number">2</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">arms</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法（通用功能）</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">walk</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;人类行走方式&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">eyes</span>); <span class="comment">// this 指向构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">eyes</span>); <span class="comment">// 2（访问静态属性）</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">walk</span>();            <span class="comment">// 调用静态方法</span></span><br></pre></td></tr></table></figure></div>

<p><strong>关键约束</strong>：</p>
<p>静态成员直接挂在构造函数上，<strong>和具体实例无关</strong>。</p>
<p>比如  <code>Person.walk()</code>  方法无法读取实例的  <code>name</code>  属性，就像数学工具  <code>Math.random()</code>  不需要知道具体数字一样。这类方法常用于定义通用工具（如日期格式化）或全局配置（如默认超时时间）。</p>
<h1 id="内置构造函数"><a href="#内置构造函数" class="headerlink" title="内置构造函数"></a>内置构造函数</h1><p>基本类型处理简单数据，引用类型承载复杂结构。<br>JavaScript 的类型系统存在一个精妙设计：<strong>基本数据类型通过包装类型临时对象化</strong>。</p>
<p>当我们操作字符串、数字等基本类型时，引擎会自动创建临时包装对象，这使得如下操作成为可能：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;andy&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>); <span class="comment">// 4（临时 String 对象提供 length 属性）</span></span><br></pre></td></tr></table></figure></div>

<p>这种机制让基本类型在需要也能调用方法（如 <code>&#39;text&#39;.toUpperCase()</code>），操作完成后立即销毁临时对象，回归基本类型状态。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="对象属性访问"><a href="#对象属性访问" class="headerlink" title="对象属性访问"></a>对象属性访问</h4><p>访问对象属性有两种主要方法，各有优势：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;小狼&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 点符号（语法简洁，直观）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);  <span class="comment">// 输出: 小狼</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 方括号表示法（更灵活，可使用变量和特殊键名）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[<span class="string">&#x27;name&#x27;</span>]);  <span class="comment">// 输出: 小狼</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最强大的用法：使用变量作为键</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;age&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[key]);  <span class="comment">// 输出: 25</span></span><br></pre></td></tr></table></figure></div>

<h4 id="键值提取-keys-values"><a href="#键值提取-keys-values" class="headerlink" title="键值提取 .keys()/.values()"></a>键值提取 <code>.keys()/.values()</code></h4><p>这对方法分别提取对象的键和值，返回数组形式。在处理数据格式转换时，它们常与数组方法配合使用：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span>, <span class="attr">age</span>: <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(user);   <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br><span class="line"><span class="keyword">const</span> values = <span class="title class_">Object</span>.<span class="title function_">values</span>(user); <span class="comment">// [&#x27;佩奇&#x27;, 6]</span></span><br></pre></td></tr></table></figure></div>

<p>通过将对象结构转化为数组，可无缝接   接下来提到的数组方法进行深度处理。</p>
<h4 id="对象合并-assign"><a href="#对象合并-assign" class="headerlink" title="对象合并 .assign()"></a>对象合并 <code>.assign()</code></h4><p><strong><code>Object.assign()</code></strong><br>该方法 从左到右覆盖式 合并对象。</p>
<ol>
<li><strong>第一个参数为目标对象</strong>：所有源对象的属性都会拷贝到此对象</li>
<li><strong>后续参数为源对象</strong>：按顺序覆盖同名属性</li>
<li><strong>浅拷贝特性</strong>：嵌套对象仍为引用关系（修改会影响原对象）</li>
</ol>
<p>典型场景是为已有对象追加属性或创建浅拷贝：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础用法：动态添加属性</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; a:1, b:2 &#125;（直接修改原对象）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并逻辑：同名属性被覆盖</span></span><br><span class="line"><span class="keyword">const</span> merged = <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">&#x27;红&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">&#x27;蓝&#x27;</span>, <span class="attr">size</span>: <span class="string">&#x27;M&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">size</span>: <span class="string">&#x27;XL&#x27;</span> &#125;</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(merged); <span class="comment">// &#123; color:&#x27;蓝&#x27;, size:&#x27;XL&#x27; &#125;（最后一个源对象覆盖 size）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝陷阱：修改拷贝对象会影响原对象</span></span><br><span class="line"><span class="keyword">const</span> origin = &#123; <span class="attr">nested</span>: &#123; <span class="attr">value</span>: <span class="number">10</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, origin);</span><br><span class="line">copy.<span class="property">nested</span>.<span class="property">value</span> = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(origin.<span class="property">nested</span>.<span class="property">value</span>); <span class="comment">// 99（共享嵌套对象）</span></span><br></pre></td></tr></table></figure></div>

<p>方括号表示法特别适用于：</p>
<ul>
<li>键名为变量时（如 <code>romanValues[s[i]]</code>）</li>
<li>键名含特殊字符时（如 <code>obj[&#39;hello-world&#39;]</code>）</li>
<li>在算法中动态查找属性时（如罗马数字转换）</li>
</ul>
<p>实际应用案例：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 罗马数字转整数中的应用</span></span><br><span class="line"><span class="keyword">const</span> romanValues = &#123; <span class="string">&#x27;I&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;V&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;X&#x27;</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> romanStr = <span class="string">&quot;IV&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; romanStr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 使用字符作为键名动态查询值</span></span><br><span class="line">  sum += romanValues[romanStr[i]];  <span class="comment">// 等同于 romanValues[&#x27;I&#x27;], romanValues[&#x27;V&#x27;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="键值提取-keys-values-1"><a href="#键值提取-keys-values-1" class="headerlink" title="键值提取 .keys()/.values()"></a>键值提取 <code>.keys()/.values()</code></h4><p>这对方法分别提取对象的键和值，返回数组形式。在处理数据格式转换时，它们常与数组方法配合使用：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span>, <span class="attr">age</span>: <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(user);     <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br><span class="line"><span class="keyword">const</span> values = <span class="title class_">Object</span>.<span class="title function_">values</span>(user); <span class="comment">// [&#x27;佩奇&#x27;, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时获取键值对</span></span><br><span class="line"><span class="keyword">const</span> entries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(user); <span class="comment">// [[&#x27;name&#x27;,&#x27;佩奇&#x27;], [&#x27;age&#x27;,6]]</span></span><br></pre></td></tr></table></figure></div>

<p>通过将对象结构转化为数组，可无缝接接下来提到的数组方法进行深度处理。</p>
<h4 id="对象合并-assign-1"><a href="#对象合并-assign-1" class="headerlink" title="对象合并 .assign()"></a>对象合并 <code>.assign()</code></h4><p><strong><code>Object.assign()</code></strong><br>该方法 从左到右覆盖式 合并对象。</p>
<ol>
<li><strong>第一个参数为目标对象</strong>：所有源对象的属性都会拷贝到此对象</li>
<li><strong>后续参数为源对象</strong>：按顺序覆盖同名属性</li>
<li><strong>浅拷贝特性</strong>：嵌套对象仍为引用关系（修改会影响原对象）</li>
</ol>
<p>典型场景是为已有对象追加属性或创建浅拷贝：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础用法：动态添加属性</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; a:1, b:2 &#125;（直接修改原对象）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并逻辑：同名属性被覆盖</span></span><br><span class="line"><span class="keyword">const</span> merged = <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">&#x27;红&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">&#x27;蓝&#x27;</span>, <span class="attr">size</span>: <span class="string">&#x27;M&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">size</span>: <span class="string">&#x27;XL&#x27;</span> &#125;</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(merged); <span class="comment">// &#123; color:&#x27;蓝&#x27;, size:&#x27;XL&#x27; &#125;（最后一个源对象覆盖 size）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝陷阱：修改拷贝对象会影响原对象</span></span><br><span class="line"><span class="keyword">const</span> origin = &#123; <span class="attr">nested</span>: &#123; <span class="attr">value</span>: <span class="number">10</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, origin);</span><br><span class="line">copy.<span class="property">nested</span>.<span class="property">value</span> = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(origin.<span class="property">nested</span>.<span class="property">value</span>); <span class="comment">// 99（共享嵌套对象）</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Array-重点方法"><a href="#Array-重点方法" class="headerlink" title="Array 重点方法"></a>Array 重点方法</h3><h4 id="基础迭代：-forEach"><a href="#基础迭代：-forEach" class="headerlink" title="基础迭代：.forEach()"></a>基础迭代：<code>.forEach()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">当前元素, 当前索引</span>) &#123;</span><br><span class="line">  <span class="comment">// 对每个元素执行操作（无返回值）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>forEach()</code> 是替代传统 <code>for</code> 循环的现代方案，其核心能力在于 <strong>自动化迭代控制</strong>。通过对比可见其如何简化代码逻辑：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统索引循环</span></span><br><span class="line"><span class="keyword">const</span> prices = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`价格<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>: <span class="subst">$&#123;prices[i]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现代迭代方案</span></span><br><span class="line">prices.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">price, index</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`价格<span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>: <span class="subst">$&#123;price&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>与手动维护索引的传统循环不同，<code>forEach</code> 自动处理数组遍历过程。回调函数始终按 <strong>元素 → 索引 → 原数组</strong> 的顺序接收参数，这种标准化接口降低了认知成本。</p>
<h4 id="数据转换：-map"><a href="#数据转换：-map" class="headerlink" title="数据转换：.map()"></a>数据转换：<code>.map()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 新数组 = 数组.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">当前元素, 当前索引</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 转换后的元素 <span class="comment">// 必须显式返回新值</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>map()</code> 专注于 <strong>元素映射转换</strong>，其设计理念是保持原数组不变并<strong>生成新数组</strong>。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统转换方式</span></span><br><span class="line"><span class="keyword">const</span> prices = [<span class="number">99.8</span>, <span class="number">145.5</span>, <span class="number">32.0</span>];</span><br><span class="line"><span class="keyword">const</span> formatted = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  formatted.<span class="title function_">push</span>(<span class="string">`¥<span class="subst">$&#123;prices[i].toFixed(<span class="number">2</span>)&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明式转换方案</span></span><br><span class="line"><span class="keyword">const</span> formatted = prices.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`¥<span class="subst">$&#123;price.toFixed(<span class="number">2</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><code>map</code> 方法通过返回新数组的特性，天然支持链式调用。在处理数据流水线时，可以流畅衔接其他数组方法形成处理链路，这种特性在组合 <code>filter</code> 等操作时尤为实用。</p>
<h4 id="条件筛选：-filter"><a href="#条件筛选：-filter" class="headerlink" title="条件筛选：.filter()"></a>条件筛选：<code>.filter()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 筛选数组 = 数组.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">当前元素</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 条件表达式 <span class="comment">// 返回true保留元素，false过滤元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>filter()</code> 实现了 <strong>真值测试驱动</strong> 的数据过滤机制，其核心逻辑是将条件判断抽象为独立函数：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统筛选方式</span></span><br><span class="line"><span class="keyword">const</span> users = [<span class="comment">/* 用户数据 */</span>];</span><br><span class="line"><span class="keyword">const</span> adults = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; users.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (users[i].<span class="property">age</span> &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    adults.<span class="title function_">push</span>(users[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式筛选方案</span></span><br><span class="line"><span class="keyword">const</span> adults = users.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> user.<span class="property">age</span> &gt;= <span class="number">18</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>该方法通过返回新数组保持数据不可变性，特别适合与 <code>map</code> 组合使用。当需要处理复合条件时，可通过逻辑运算符组合多个判断条件。</p>
<h4 id="字符串拼接：-join"><a href="#字符串拼接：-join" class="headerlink" title="字符串拼接：.join()"></a>字符串拼接：<code>.join()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 拼接结果 = 数组.<span class="title function_">join</span>(<span class="string">&#x27;分隔符&#x27;</span>) <span class="comment">// 默认分隔符为逗号</span></span><br></pre></td></tr></table></figure></div>

<p><code>join()</code> 方法将数组转换为格式可控的字符串，其分隔符参数提供了灵活的格式定制能力：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径拼接场景</span></span><br><span class="line"><span class="keyword">const</span> pathSegments = [<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;utils&#x27;</span>, <span class="string">&#x27;helper.js&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> fullPath = pathSegments.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>); <span class="comment">// &quot;src/utils/helper.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CSV生成场景</span></span><br><span class="line"><span class="keyword">const</span> headers = [<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> row = [<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(headers.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>)); <span class="comment">// &quot;Name,Age&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(row.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>));     <span class="comment">// &quot;Alice,25&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>该方法在处理数据导出、URL 生成等场景时，能够显著简化字符串拼接逻辑。通过不同分隔符的配置，可快速适配 JSON、CSV 等多种数据格式要求。</p>
<h4 id="累计运算：-reduce"><a href="#累计运算：-reduce" class="headerlink" title="累计运算：.reduce()"></a>累计运算：<code>.reduce()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 最终值 = 数组.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">累计值, 当前元素</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 更新后的累计值</span><br><span class="line">&#125;, 初始值)</span><br></pre></td></tr></table></figure></div>

<p><code>reduce()</code> 的核心在于 <strong>通过遍历逐步收敛为单一值</strong>，</p>
<ol>
<li><strong>初始值决定起点</strong>：若提供初始值，首轮累计值为初始值；否则直接取数组<strong>首元素</strong></li>
<li><strong>链式传递逻辑</strong>：每次迭代的返回值自动成为下一轮累计值</li>
</ol>
<p>其执行逻辑可通过两种典型场景理解：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景1：数组求和（无初始值）</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> sum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur);</span><br><span class="line"><span class="comment">// 执行过程：1+2=3 → 3+3=6 → 6+4=10（结果：10）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景2：带初始值的对象统计</span></span><br><span class="line"><span class="keyword">const</span> words = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> count = words.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, word</span>) =&gt;</span> &#123;</span><br><span class="line">  acc[word] = (acc[word] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="comment">// &#123; apple:2, banana:1 &#125;（初始空对象逐步填充）</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>初始值存在时，首次循环的 <code>acc</code> 为初始值，否则直接取数组第一个元素</li>
<li>每次循环的返回值会成为下次循环的 <code>acc</code></li>
<li>最终收敛值可以是任意类型（数字、对象、数组等）</li>
</ol>
<p>与传统循环相比，<code>reduce</code> 将迭代控制权交给引擎，开发者只需关注 <strong>如何更新累计值</strong>。这种模式在数据聚合、多维数组扁平化等场景中，能显著提升代码可读性。</p>
<h4 id="元素搜索：-find"><a href="#元素搜索：-find" class="headerlink" title="元素搜索：.find()"></a>元素搜索：<code>.find()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 目标元素 = 数组.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">当前元素</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 匹配条件 <span class="comment">// 返回true时停止搜索并返回该元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>find()</code> 的核心价值在于 <strong>短路搜索机制</strong>，其执行逻辑与传统搜索方式的对比：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统搜索方式</span></span><br><span class="line"><span class="keyword">const</span> users = [&#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">admin</span>:<span class="literal">false</span>&#125;, &#123;<span class="attr">id</span>:<span class="number">2</span>, <span class="attr">admin</span>:<span class="literal">true</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> target;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; users.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (users[i].<span class="property">admin</span>) &#123;</span><br><span class="line">    target = users[i];</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 找到后立即中断循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式搜索方案</span></span><br><span class="line"><span class="keyword">const</span> adminUser = users.<span class="title function_">find</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">admin</span>); <span class="comment">// &#123;id:2, admin:true&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>该方法在找到首个匹配元素后立即终止遍历，这种特性在处理大型数组时能显著提升性能。与 <code>filter</code> 返回数组不同，<code>find</code> 直接返回目标元素本身，在需要获取对象引用时更为实用。</p>
<h4 id="全员检测：every"><a href="#全员检测：every" class="headerlink" title="全员检测：every()"></a>全员检测：every()</h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 全员通过 = 数组.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">当前元素</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 检测条件 <span class="comment">// 所有元素都返回true则最终为true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>every()</code> 通过 <strong>全员验证机制</strong> 实现整体性判断，其短路特性体现在：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统验证方式</span></span><br><span class="line"><span class="keyword">const</span> products = [&#123;<span class="attr">stock</span>:<span class="number">5</span>&#125;, &#123;<span class="attr">stock</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">stock</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> allInStock = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; products.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (products[i].<span class="property">stock</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    allInStock = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 遇到不合格立即中断</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式验证方案</span></span><br><span class="line"><span class="keyword">const</span> isAllInStock = products.<span class="title function_">every</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">stock</span> &gt; <span class="number">0</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>

<p>当检测到首个不满足条件的元素时，遍历立即终止。该方法常与 <code>some()</code> 形成逻辑互补（全员满足 vs 至少一个满足），在表单验证、权限检查等场景中极为实用。</p>
<h3 id="Array-其他方法"><a href="#Array-其他方法" class="headerlink" title="Array 其他方法"></a>Array 其他方法</h3><h4 id="存在性检测：some"><a href="#存在性检测：some" class="headerlink" title="存在性检测：some()"></a>存在性检测：<code>some()</code></h4><p>与 <code>every()</code> 形成逻辑互补，当数组中<strong>至少有一个元素</strong>满足条件时即返回 <code>true</code>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasNegative = [<span class="number">1</span>, -<span class="number">5</span>, <span class="number">3</span>].<span class="title function_">some</span>(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p>典型应用场景：权限检查（至少拥有一个权限）、表单验证（存在非法输入）</p>
<h4 id="数组合并：concat"><a href="#数组合并：concat" class="headerlink" title="数组合并：concat()"></a>数组合并：<code>concat()</code></h4><p><strong>安全合并</strong>多个数组（不修改原数组）：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> merged = arr1.<span class="title function_">concat</span>(arr2); <span class="comment">// [1,2,3]（原数组保持不变）</span></span><br></pre></td></tr></table></figure></div>

<p>特别说明：现代开发更常用扩展运算符 <code>[...arr1, ...arr2]</code></p>
<h4 id="排序控制：sort"><a href="#排序控制：sort" class="headerlink" title="排序控制：sort()"></a>排序控制：<code>sort()</code></h4><p><strong>原地排序</strong>（修改原数组），默认按字符串 Unicode 排序：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">40</span>];</span><br><span class="line">nums.<span class="title function_">sort</span>(); <span class="comment">// [10, 40, 5]（字典序排列）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确数字排序需比较函数</span></span><br><span class="line">nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// [5, 10, 40]</span></span><br></pre></td></tr></table></figure></div>

<p>关键注意：比较函数返回负数&#x2F;0&#x2F;正数决定排序顺序</p>
<h4 id="动态修改：splice"><a href="#动态修改：splice" class="headerlink" title="动态修改：splice()"></a>动态修改：<code>splice()</code></h4><p><strong>最灵活</strong>的数组修改方法（可删除&#x2F;替换&#x2F;添加元素）：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">// 从索引1开始删除1个元素，插入&#x27;x&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [&#x27;a&#x27;, &#x27;x&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></div>

<p>参数模式：<br><code>startIndex</code> → 起始位置<br><code>deleteCount</code> → 删除数量<br><code>...items</code> → 插入的新元素</p>
<h4 id="结构反转：reverse"><a href="#结构反转：reverse" class="headerlink" title="结构反转：reverse()"></a>结构反转：<code>reverse()</code></h4><p><strong>原地反转</strong>数组元素顺序：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> letters = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">letters.<span class="title function_">reverse</span>(); <span class="comment">// [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]（原数组被修改）</span></span><br></pre></td></tr></table></figure></div>

<p>典型用途：处理栈结构、展示倒序列表</p>
<h4 id="索引定位：findIndex"><a href="#索引定位：findIndex" class="headerlink" title="索引定位：findIndex()"></a>索引定位：<code>findIndex()</code></h4><p>与 <code>find()</code> 逻辑一致，但返回元素的<strong>索引值</strong>（未找到返回-1）：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [&#123;<span class="attr">id</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">id</span>:<span class="number">2</span>&#125;];</span><br><span class="line"><span class="keyword">const</span> index = users.<span class="title function_">findIndex</span>(<span class="function"><span class="params">u</span> =&gt;</span> u.<span class="property">id</span> === <span class="number">2</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div>

<p>特别适配场景：需要索引进行后续操作（如结合 <code>splice</code> 删除元素）</p>
<h4 id="结构转换：Array-from"><a href="#结构转换：Array-from" class="headerlink" title="结构转换：Array.from()"></a>结构转换：<code>Array.from()</code></h4><p>将类数组结构（含 length 属性）转换为标准数组：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 新数组 = <span class="title class_">Array</span>.<span class="title function_">from</span>(伪数组)</span><br></pre></td></tr></table></figure></div>

<p><strong>典型场景</strong>：处理 DOM 元素集合或 arguments 对象</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DOM 操作场景</span></span><br><span class="line"><span class="keyword">const</span> divList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>); <span class="comment">// NodeList 伪数组</span></span><br><span class="line"><span class="keyword">const</span> realArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(divList); <span class="comment">// 可调用数组方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方案对比</span></span><br><span class="line"><span class="keyword">const</span> oldWay = [].<span class="property">slice</span>.<span class="title function_">call</span>(divList); <span class="comment">// ES5 转换方式</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Array-方法总结"><a href="#Array-方法总结" class="headerlink" title="Array 方法总结"></a>Array 方法总结</h3><h4 id="基础必备"><a href="#基础必备" class="headerlink" title="基础必备"></a>基础必备</h4><p><strong>（处理数据必用，每天写代码都离不开）</strong></p>
<p><strong>1. <code>forEach</code> (重点)</strong><br>最简单的遍历方法，<strong>替代<code>for</code>循环</strong>的最佳选择。就像自动售货机——投币（数组）后自动吐出每个商品（元素），你只需要处理每个商品：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;牛奶&#x27;</span>, <span class="string">&#x27;面包&#x27;</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">商品, 序号</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第<span class="subst">$&#123;序号+<span class="number">1</span>&#125;</span>件：<span class="subst">$&#123;商品&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出：第1件：牛奶 → 第2件：面包</span></span><br></pre></td></tr></table></figure></div>

<p>⚠️ <strong>注意</strong>：不能中途<code>break</code>停止，需要中断时用<code>for</code>循环</p>
<p><strong>2. <code>map</code> (重点)</strong><br><strong>数据变形金刚</strong>，把数组中的每个元素变成新模样，且<strong>不修改原数组</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 价格 = [<span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line"><span class="keyword">const</span> 打折价 = 价格.<span class="title function_">map</span>(原价 =&gt; 原价 * <span class="number">0.8</span>) <span class="comment">// [80, 160]</span></span><br></pre></td></tr></table></figure></div>

<p>🛠️ <strong>经典场景</strong>：接口数据转换（API 返回的数据 → 前端需要的格式）</p>
<p><strong>3. <code>filter</code> (重点)</strong><br><strong>数据过滤器</strong>，只留下符合条件的元素：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 用户列表 = [&#123;年龄:<span class="number">17</span>&#125;, &#123;年龄:<span class="number">20</span>&#125;]</span><br><span class="line"><span class="keyword">const</span> 成年人 = 用户列表.<span class="title function_">filter</span>(用户 =&gt; 用户.年龄 &gt;= <span class="number">18</span>) <span class="comment">// [&#123;年龄:20&#125;]</span></span><br></pre></td></tr></table></figure></div>

<p>⚠️ <strong>陷阱</strong>：<code>filter(item =&gt; item.prop)</code> 会过滤掉<code>prop</code>为<code>0</code>或<code>false</code>的合法值</p>
<h4 id="进阶必备"><a href="#进阶必备" class="headerlink" title="进阶必备"></a>进阶必备</h4><p><strong>（提升代码效率，处理复杂场景）</strong></p>
<p><strong>4. <code>reduce</code> (重点)</strong><br><strong>数据聚合器</strong>，把数组浓缩成一个值（数字&#x2F;对象&#x2F;新数组）：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算总价</span></span><br><span class="line"><span class="keyword">const</span> 购物车 = [&#123;价格:<span class="number">100</span>&#125;, &#123;价格:<span class="number">200</span>&#125;]</span><br><span class="line"><span class="keyword">const</span> 总价 = 购物车.<span class="title function_">reduce</span>(<span class="function">(<span class="params">累计, 商品</span>) =&gt;</span> 累计 + 商品.价格, <span class="number">0</span>) <span class="comment">// 300</span></span><br></pre></td></tr></table></figure></div>

<p>🔥 <strong>高阶用法</strong>：统计词频、扁平化嵌套数组</p>
<p><strong>5. <code>find</code> (重点)</strong><br><strong>精准搜索</strong>，找到第一个符合条件的元素（比<code>filter</code>更快）：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 订单列表 = [&#123;<span class="attr">id</span>:<span class="number">1</span>, 状态:<span class="string">&#x27;未支付&#x27;</span>&#125;, &#123;<span class="attr">id</span>:<span class="number">2</span>, 状态:<span class="string">&#x27;已发货&#x27;</span>&#125;]</span><br><span class="line"><span class="keyword">const</span> 待处理订单 = 订单列表.<span class="title function_">find</span>(订单 =&gt; 订单.状态 === <span class="string">&#x27;未支付&#x27;</span>) <span class="comment">// &#123;id:1...&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>⚠️ <strong>注意</strong>：找不到时返回<code>undefined</code>，要用<code>if</code>判断结果是否存在</p>
<h4 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h4><table>
<thead>
<tr>
<th>方法</th>
<th>一句话功能</th>
<th>使用示例</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td><code>some</code></td>
<td><strong>至少一个满足条件</strong></td>
<td><code>[1, -2].some(n =&gt; n&lt;0) → true</code></td>
<td>和<code>every</code>相反</td>
</tr>
<tr>
<td><code>concat</code></td>
<td><strong>合并数组</strong></td>
<td><code>[1].concat([2]) → [1,2]</code></td>
<td>用<code>[...arr1,...arr2]</code>更现代</td>
</tr>
<tr>
<td><code>sort</code></td>
<td><strong>排序</strong></td>
<td><code>[10,2].sort((a,b)=&gt;a-b) → [2,10]</code></td>
<td>必须传比较函数！</td>
</tr>
<tr>
<td><code>splice</code></td>
<td><strong>增删改元素</strong></td>
<td><code>arr.splice(1,0,&#39;新增&#39;)</code> 插入元素</td>
<td>直接修改原数组</td>
</tr>
<tr>
<td><code>findIndex</code></td>
<td><strong>找元素位置</strong></td>
<td><code>[&#39;a&#39;,&#39;b&#39;].findIndex(v=&gt;v===&#39;b&#39;) → 1</code></td>
<td>找不到返回-1</td>
</tr>
</tbody></table>
<ul>
<li>**<code>forEach</code>**：每个都做点什么</li>
<li>**<code>map</code>**：每个都变个样子</li>
<li>**<code>filter</code>**：好的留下，坏的不要</li>
<li>**<code>reduce</code>**：多个变一个</li>
<li>**<code>find</code>**：抓住第一个符合条件的</li>
</ul>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>String，Number，Boolean 等</p>
<h3 id="String-重点方法"><a href="#String-重点方法" class="headerlink" title="String 重点方法"></a>String 重点方法</h3><h4 id="结构拆分：-split"><a href="#结构拆分：-split" class="headerlink" title="结构拆分：.split()"></a>结构拆分：<code>.split()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 数组 = 字符串.<span class="title function_">split</span>(分隔符)</span><br></pre></td></tr></table></figure></div>

<p><code>split()</code>  实现字符串与数组的高效双向转换，与数组的  <code>join()</code>  方法形成互逆操作，构建字符串 ↔ 数组转换闭环。<br>其核心价值在于<strong>结构化数据处理</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方案：手动拆分</span></span><br><span class="line"><span class="keyword">const</span> csv = <span class="string">&#x27;张三,25,男&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line"><span class="keyword">let</span> temp = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> csv) &#123;</span><br><span class="line">  <span class="keyword">if</span> (char === <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">    data.<span class="title function_">push</span>(temp);</span><br><span class="line">    temp = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    temp += char;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">data.<span class="title function_">push</span>(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代拆分方案</span></span><br><span class="line"><span class="keyword">const</span> data = csv.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// [&quot;张三&quot;, &quot;25&quot;, &quot;男&quot;]</span></span><br></pre></td></tr></table></figure></div>

<p>分隔符支持正则表达式（如  <code>/\s+/</code>  匹配连续空格），连续分隔符会产生空元素，第二参数控制最大分段数量</p>
<h4 id="精准截取：-substring"><a href="#精准截取：-substring" class="headerlink" title="精准截取：.substring()"></a>精准截取：<code>.substring()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串.<span class="title function_">substring</span>(起始索引[, 结束索引]) <span class="comment">// 截取内容不包含结束索引号的内容</span></span><br></pre></td></tr></table></figure></div>

<p>与 <code>slice()</code> 方法类似，但<strong>不支持负索引</strong>，提供更安全的截取控制：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统字符操作</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;前端开发工程师&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">2</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">  result += str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代截取方案</span></span><br><span class="line"><span class="keyword">const</span> result = str.<span class="title function_">substring</span>(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// &quot;开发&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>当起始索引大于结束索引时，<code>substring</code> 会自动调换参数，而 <code>slice</code> 返回空字符串。在表单输入截断等场景下更安全。自动处理起始&gt;结束的情况（交换参数）超范围索引自动截断到有效范围</p>
<h4 id="前缀检测：-startsWith"><a href="#前缀检测：-startsWith" class="headerlink" title="前缀检测：.startsWith()"></a>前缀检测：<code>.startsWith()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串.<span class="title function_">startsWith</span>(检测字符串[, 起始位置])</span><br></pre></td></tr></table></figure></div>

<p>实现精准的头部匹配检测，<strong>替代正则检测的轻量方案</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统方案</span></span><br><span class="line"><span class="keyword">const</span> isHttps = url.<span class="title function_">indexOf</span>(<span class="string">&#x27;https://&#x27;</span>) === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代检测方案</span></span><br><span class="line"><span class="keyword">const</span> isHttps = url.<span class="title function_">startsWith</span>(<span class="string">&#x27;https://&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>典型应用</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由检测</span></span><br><span class="line"><span class="keyword">if</span> (path.<span class="title function_">startsWith</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="number">7</span>)) &#123;</span><br><span class="line">  <span class="comment">// 从第7字符开始检测</span></span><br><span class="line">  <span class="title function_">handleAPIRequest</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="存在性判断：-includes"><a href="#存在性判断：-includes" class="headerlink" title="存在性判断：.includes()"></a>存在性判断：<code>.includes()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串.<span class="title function_">includes</span>(搜索字符串[, 起始位置])</span><br></pre></td></tr></table></figure></div>

<p>提供更直观的包含性检测，<strong>替代 <code>indexOf</code> 的现代方案</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统检测</span></span><br><span class="line"><span class="keyword">const</span> isValid = content.<span class="title function_">indexOf</span>(<span class="string">&#x27;重要通知&#x27;</span>) !== -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语义化检测</span></span><br><span class="line"><span class="keyword">const</span> isValid = content.<span class="title function_">includes</span>(<span class="string">&#x27;重要通知&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p>与数组的 <code>includes</code> 方法形成语法统一，降低记忆成本。注意对大小写敏感，必要时先统一大小写。</p>
<h3 id="String-其他方法"><a href="#String-其他方法" class="headerlink" title="String 其他方法"></a>String 其他方法</h3><h4 id="大小写转换：-toUpper-LowerCase"><a href="#大小写转换：-toUpper-LowerCase" class="headerlink" title="大小写转换：.toUpper/LowerCase()"></a>大小写转换：<code>.toUpper/LowerCase()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符串.<span class="title function_">toUpperCase</span>()  <span class="comment">// 全大写转换</span></span><br><span class="line">字符串.<span class="title function_">toLowerCase</span>()  <span class="comment">// 全小写转换</span></span><br></pre></td></tr></table></figure></div>

<h4 id="位置定位：-indexOf"><a href="#位置定位：-indexOf" class="headerlink" title="位置定位：.indexOf()"></a>位置定位：<code>.indexOf()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串.<span class="title function_">indexOf</span>(搜索值[, 起始位置])</span><br></pre></td></tr></table></figure></div>

<p>返回<strong>首次出现位置的索引</strong>（未找到返回 -1），适合精确查找：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件类型检测</span></span><br><span class="line"><span class="keyword">const</span> fileName = <span class="string">&#x27;report.pdf&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (fileName.<span class="title function_">indexOf</span>(<span class="string">&#x27;.pdf&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="title function_">showPreview</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="后缀检测：-endsWith"><a href="#后缀检测：-endsWith" class="headerlink" title="后缀检测：.endsWith()"></a>后缀检测：<code>.endsWith()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串.<span class="title function_">endsWith</span>(检测字符串[, 检测长度])</span><br></pre></td></tr></table></figure></div>

<p>常用于文件格式验证，<strong>支持限定检测范围</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片格式校验</span></span><br><span class="line"><span class="keyword">const</span> isValidImage = [<span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>].<span class="title function_">some</span>(<span class="function"><span class="params">ext</span> =&gt;</span></span><br><span class="line">  fileName.<span class="title function_">endsWith</span>(<span class="string">`.<span class="subst">$&#123;ext&#125;</span>`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h4 id="模式替换：-replace"><a href="#模式替换：-replace" class="headerlink" title="模式替换：.replace()"></a>模式替换：<code>.replace()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串.<span class="title function_">replace</span>(匹配模式, 替换内容)</span><br></pre></td></tr></table></figure></div>

<p>支持<strong>正则表达式替换</strong>，实现灵活字符串处理：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日期格式转换</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="string">&#x27;2023-08-15&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/-/g</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;2023/08/15&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险字符过滤</span></span><br><span class="line"><span class="keyword">const</span> safeText = input.<span class="title function_">replace</span>(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="模式匹配：-match"><a href="#模式匹配：-match" class="headerlink" title="模式匹配：.match()"></a>模式匹配：<code>.match()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串.<span class="title function_">match</span>(正则表达式)</span><br></pre></td></tr></table></figure></div>

<p>返回匹配结果的数组，<strong>捕获组信息完整保留</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取颜色代码</span></span><br><span class="line"><span class="keyword">const</span> hexCodes = <span class="string">&#x27;色值：#FF0000 #00FF00&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/#[0-9A-F]&#123;6&#125;/g</span>);</span><br><span class="line"><span class="comment">// [&quot;#FF0000&quot;, &quot;#00FF00&quot;]</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><h4 id="数值格式化：-toFixed"><a href="#数值格式化：-toFixed" class="headerlink" title="数值格式化：.toFixed()"></a>数值格式化：<code>.toFixed()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数值.<span class="title function_">toFixed</span>(保留小数位数)</span><br></pre></td></tr></table></figure></div>

<p><code>toFixed()</code> 实现数值的精确舍入与格式化输出，如同会计记账时的金额规范处理。通过对比可见其如何简化数值控制逻辑：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统手工计算方案</span></span><br><span class="line"><span class="keyword">const</span> price = <span class="number">12.345</span>;</span><br><span class="line"><span class="keyword">let</span> fixedPrice = <span class="title class_">Math</span>.<span class="title function_">round</span>(price * <span class="number">100</span>) / <span class="number">100</span>; <span class="comment">// 12.35</span></span><br><span class="line"><span class="comment">// 补足小数点后两位</span></span><br><span class="line">fixedPrice = fixedPrice.<span class="title function_">toString</span>().<span class="title function_">includes</span>(<span class="string">&#x27;.&#x27;</span>) ? fixedPrice : fixedPrice + <span class="string">&#x27;.00&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代格式化方案</span></span><br><span class="line"><span class="keyword">const</span> formatted = price.<span class="title function_">toFixed</span>(<span class="number">2</span>); <span class="comment">// &quot;12.35&quot;（自动补零）</span></span><br></pre></td></tr></table></figure></div>

<p>与手动计算不同，<code>toFixed</code> 自动处理四舍五入和末尾补零，返回<strong>标准化字符串</strong>。此方法与字符串的 <code>parseFloat</code> 形成数据处理闭环：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 金额输入校验场景</span></span><br><span class="line"><span class="keyword">const</span> input = <span class="string">&quot;12.3&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> validValue = <span class="built_in">parseFloat</span>(input).<span class="title function_">toFixed</span>(<span class="number">2</span>); <span class="comment">// &quot;12.30&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>小数位不足时自动补零（如 <code>5.toFixed(2)→&quot;5.00&quot;</code>）采用国际标准四舍六入五成双规则始终返回字符串以避免精度丢失，需配合 <code>Number()</code> 转换使用</p>
<h1 id="深入对象"><a href="#深入对象" class="headerlink" title="深入对象"></a>深入对象</h1><h3 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h3><p><strong>面向过程编程</strong><br>如同制作蛋炒饭的过程：</p>
<p>先热锅、倒油、炒蛋、加饭、翻炒调味，每个步骤都需要严格按照顺序执行。</p>
<p>这种编程方式将问题分解为线性步骤，通过函数调用逐步实现：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 制作蛋炒饭的代码模拟</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heatPan</span>(<span class="params"></span>) &#123; <span class="comment">/* 热锅逻辑 */</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addOil</span>(<span class="params"></span>) &#123; <span class="comment">/* 倒油逻辑 */</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fryEgg</span>(<span class="params"></span>) &#123; <span class="comment">/* 炒蛋逻辑 */</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cookRice</span>(<span class="params"></span>) &#123; <span class="comment">/* 加饭逻辑 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按步骤执行</span></span><br><span class="line"><span class="title function_">heatPan</span>();</span><br><span class="line"><span class="title function_">addOil</span>();</span><br><span class="line"><span class="title function_">fryEgg</span>();</span><br><span class="line"><span class="title function_">cookRice</span>();</span><br></pre></td></tr></table></figure></div>

<p>其优势在于执行效率高（适合硬件操作、单片机开发），但维护困难——若要调整加饭和炒蛋的顺序，需要重写整个流程。<br>如同修改食谱步骤，可能影响最终成品。</p>
<p><strong>面向对象编程（OOP）</strong><br>更像盖浇饭的制作：将食材处理、酱料调配、摆盘装饰等功能拆分给不同厨师（对象），通过分工合作完成菜品。每个对象承担独立职责，彼此通过接口协作：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 盖浇饭对象协作模拟</span></span><br><span class="line"><span class="keyword">const</span> riceChef = &#123;</span><br><span class="line">  <span class="attr">cook</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/* 蒸饭逻辑 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> toppingChef = &#123;</span><br><span class="line">  <span class="attr">prepare</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/* 备浇头逻辑 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> plater = &#123;</span><br><span class="line">  <span class="attr">serve</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/* 摆盘逻辑 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象间协作</span></span><br><span class="line">riceChef.<span class="title function_">cook</span>();</span><br><span class="line">toppingChef.<span class="title function_">prepare</span>();</span><br><span class="line">plater.<span class="title function_">serve</span>();</span><br></pre></td></tr></table></figure></div>

<p>这种模式更易维护和扩展——若要新增「辣味浇头」，只需扩展 <code>toppingChef</code> 对象，无需修改其他部分。其代价是性能略低于面向过程，但为大型项目提供了更好的灵活性和协作性。</p>
<h3 id="构造函数封装"><a href="#构造函数封装" class="headerlink" title="构造函数封装"></a>构造函数封装</h3><p>JavaScript 通过构造函数实现面向对象的<strong>封装性</strong>，将数据与操作数据的方法组合成独立对象：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Wolf</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;  <span class="comment">// 属性封装</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">howl</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  <span class="comment">// 方法封装</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会嚎叫&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">const</span> greyWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;灰太狼&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> redWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;红太狼&#x27;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></div>

<p>此时  <code>greyWolf.howl === redWolf.howl</code>  返回  <code>false</code>，说明每只狼的  <code>howl</code>  方法都是独立创建的。如同为每匹狼单独配备嚎叫设备，虽能正常工作，但造成了资源浪费。</p>
<p>当创建大量狼对象时，重复定义方法会导致显著的内存浪费。<br>这种设计下，若有 1000 匹狼，就会产生 1000 个功能相同的  <code>howl</code>  方法副本，严重消耗内存资源。</p>
<h3 id="构造函数封装-1"><a href="#构造函数封装-1" class="headerlink" title="构造函数封装"></a>构造函数封装</h3><p>JavaScript 通过构造函数实现面向对象的<strong>封装性</strong>，将生物特征与行为模式组合成独立对象：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Wolf</span>(<span class="params">species, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">species</span> = species;  <span class="comment">// 品种属性封装（如北极狼/墨西哥狼）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">howl</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  <span class="comment">// 实例方法封装</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.species&#125;</span>发出低频嚎叫（120-180Hz）`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化不同亚种</span></span><br><span class="line"><span class="keyword">const</span> arcticWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;北极狼&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> mexicanWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;墨西哥狼&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arcticWolf.<span class="property">howl</span> === mexicanWolf.<span class="property">howl</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>

<p>此时每个狼实例都携带独立的 <code>howl</code> 方法副本，如同为每匹狼配备专用声带系统。当建立狼群时（如 1000 匹规模的群体），会造成显著的内存冗余。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h4 id="原型对象-prototype"><a href="#原型对象-prototype" class="headerlink" title="原型对象 prototype"></a>原型对象 <code>prototype</code></h4><p>每个 ​<strong>​ 构造函数 ​</strong>​ 在创建时自动获得一个名为  <code>prototype</code>  的 ​<strong>​ 原型对象 ​</strong>​，该对象专门用于存储同类实例共享的方法。<br>通过将方法定义在原型对象上，所有通过该构造函数生成的实例均可访问这些方法，实现内存的高效利用。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Wolf</span>(<span class="params">species, age</span>) &#123;</span><br><span class="line">  <span class="comment">// 实例独有属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">species</span> = species;  <span class="comment">// 品种学名（如Canis lupus arctos）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;          <span class="comment">// 年龄（月）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享行为定义</span></span><br><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Wolf</span>,  <span class="comment">// 关键构造关联</span></span><br><span class="line">  <span class="attr">howl</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.species&#125;</span>发出领地性嚎叫（持续6-8秒）`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">hunt</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.species&#125;</span>启动群体捕猎模式`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例验证</span></span><br><span class="line"><span class="keyword">const</span> eurasianWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;欧亚狼&#x27;</span>, <span class="number">48</span>);</span><br><span class="line"><span class="keyword">const</span> himalayanWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;喜马拉雅狼&#x27;</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(eurasianWolf.<span class="property">howl</span> === himalayanWolf.<span class="property">howl</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h4 id="原型方法中的-this"><a href="#原型方法中的-this" class="headerlink" title="原型方法中的 this"></a>原型方法中的 this</h4><p>原型方法中的  <code>this</code>  始终指向调用该方法的实例对象，这是实现状态独立的核心。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">establishTerritory</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// this 指向调用实例</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.species&#125;</span>标记 <span class="subst">$&#123;<span class="variable language_">this</span>.age*<span class="number">10</span>&#125;</span> 平方公里领地`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greyWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;灰狼&#x27;</span>, <span class="number">60</span>);</span><br><span class="line">greyWolf.<span class="title function_">establishTerritory</span>();  <span class="comment">// 输出：灰狼标记 600 平方公里领地</span></span><br></pre></td></tr></table></figure></div>

<p>若错误使用箭头函数定义原型方法，会导致  <code>this</code>  绑定失效。</p>
<h3 id="原型链维护规范"><a href="#原型链维护规范" class="headerlink" title="原型链维护规范"></a>原型链维护规范</h3><h4 id="constructor-修复机制"><a href="#constructor-修复机制" class="headerlink" title="constructor 修复机制"></a><code>constructor</code> 修复机制</h4><p>在 JavaScript 的原型继承体系中，每个构造函数的原型对象（prototype）默认包含一个 constructor 属性指向构造函数本身。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E8%BF%9B%E9%98%B6/file-20250409134414448.jpg"
                     
                ></p>
<p>开发中常遇到需批量添加原型方法的场景。若采用直接赋值方式覆盖原型对象（而非属性追加方式），会破坏原型链的完整性：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Wolf</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态 ✅</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Wolf</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险操作：覆盖原型导致关联断裂 ❌</span></span><br><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">trackMigration</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;追踪迁徙路线&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>覆盖原型时必须手动重建构造函数关联：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修复方案 ✅</span></span><br><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Wolf</span>,  <span class="comment">// 重建关联</span></span><br><span class="line">  <span class="attr">trackMigration</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>后续通过  <code>new</code>  创建的实例才能正确继承构造函数类型特征。</p>
<h4 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型 __proto__"></a>对象原型 <code>__proto__</code></h4><p>实例对象的  <code>__proto__</code>  属性（现代规范中对应 <code>[[Prototype]]</code> 内部插槽）构成原型链的核心链路。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E8%BF%9B%E9%98%B6/file-20250409134952442.jpg"
                     
                ></p>
<p>该属性指向其构造函数的原型对象（prototype），实现继承关系：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ArcticWolf</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">furType</span> = <span class="string">&#x27;双层被毛&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义群体通讯协议</span></span><br><span class="line"><span class="title class_">ArcticWolf</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">snowCommunication</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;使用低频震动传递位置信息&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alphaWolf = <span class="keyword">new</span> <span class="title class_">ArcticWolf</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链验证</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(alphaWolf.<span class="property">__proto__</span> === <span class="title class_">ArcticWolf</span>.<span class="property"><span class="keyword">prototype</span></span>);  <span class="comment">// true</span></span><br><span class="line">alphaWolf.<span class="title function_">snowCommunication</span>();  <span class="comment">// 通过原型链访问</span></span><br></pre></td></tr></table></figure></div>

<h3 id="三要素关系体系"><a href="#三要素关系体系" class="headerlink" title="三要素关系体系"></a>三要素关系体系</h3><pre class="mermaid">graph TD
    A[构造函数 Wolf] -->|"prototype 属性"| B[原型对象 Wolf.prototype]
    B -->|"constructor 属性"| A
    A -->|"new 操作符"| C[实例 alphaWolf]
    C -->|"__proto__ 属性"| B
    C -.->|"constructor 查找路径 <br>（通过原型链访问）"| A
    B -.->|"共享方法调用 <br>（如howl/hunt）"| C</pre>

<p><strong>构造函数的 <code>prototype</code></strong><br> 存储当前构造函数所有实例的<strong>共享方法</strong>，该属性是一个独立对象，通过  <code>Wolf.prototype.howl</code>  定义的方法可被所有狼实例调用：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">groupHunt</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.species&#125;</span>发起群体围猎`</span>);</span><br><span class="line">&#125;; <span class="comment">// 所有实例共享此方法</span></span><br></pre></td></tr></table></figure></div>

<p><strong>实例的 <code>__proto__</code></strong><br> 实例对象的隐式链接属性，指向其构造函数的原型对象。通过此属性实现原型链查找机制。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> juvenileWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;幼狼&#x27;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(juvenileWolf.<span class="property">__proto__</span> === <span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 查找 howl 方法流程：juvenileWolf → __proto__ → Wolf.prototype</span></span><br></pre></td></tr></table></figure></div>

<p><strong>原型的 <code>constructor</code></strong><br> 原型对象的反向指针，指向其关联的构造函数。此属性是维护类型系统的关键：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Wolf</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 确保 new 操作符的正确性</span></span><br></pre></td></tr></table></figure></div>

<h2 id="继承机制核心原理"><a href="#继承机制核心原理" class="headerlink" title="继承机制核心原理"></a>继承机制核心原理</h2><p>通过原型链（Prototype Chain）实现属性和方法的层级共享。子类构造函数通过原型对象继承父类特性，形成「实例-子类原型-父类原型」的链式结构。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生物基类（父类）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Creature</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lifeSpan</span> = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Creature</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">breathe</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进行气体交换&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哺乳动物子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Mammal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">bloodType</span> = <span class="string">&#x27;warm&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Mammal</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Creature</span>();  <span class="comment">// 建立继承链</span></span><br><span class="line"><span class="title class_">Mammal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Mammal</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 狼类继承哺乳动物</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Wolf</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">species</span> = <span class="string">&#x27;Canis lupus&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Mammal</span>();</span><br><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Wolf</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arcticWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arcticWolf.<span class="property">lifeSpan</span>); <span class="comment">// 100（通过三级原型链继承）</span></span><br></pre></td></tr></table></figure></div>

<p>当多个子类直接继承同一个原型对象时，会导致意外共享修改：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">genes</span> = <span class="string">&#x27;XY&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 危险继承方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Man</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Woman</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享父类原型</span></span><br><span class="line"><span class="title class_">Man</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="title class_">Woman</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给女性添加专属方法</span></span><br><span class="line"><span class="title class_">Woman</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pregnancy</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;妊娠周期280天&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> male = <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">male.<span class="title function_">pregnancy</span>(); <span class="comment">// 异常：男性实例错误获得女性方法</span></span><br></pre></td></tr></table></figure></div>

<p><code>Man</code> 和 <code>Woman</code> 的原型指向同一内存地址，修改会相互影响。</p>
<p>通过中间构造函数创建独立的原型副本：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">genes</span> = <span class="string">&#x27;XY&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> F = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;  <span class="comment">// 缓冲构造函数</span></span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();  <span class="comment">// 生成独立原型</span></span><br><span class="line">  <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全继承实现</span></span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Man</span>, <span class="title class_">Person</span>);</span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Woman</span>, <span class="title class_">Person</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加专属方法</span></span><br><span class="line"><span class="title class_">Woman</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pregnancy</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> male = <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">male.<span class="title function_">pregnancy</span>(); <span class="comment">// TypeError: 方法不存在</span></span><br></pre></td></tr></table></figure></div>

<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链是基于原型对象的继承查找机制，通过将不同构造函数的原型对象（prototype）按层级关联形成的链状结构。</p>
<p>当访问对象属性&#x2F;方法时，解释器按以下顺序查找：</p>
<ol>
<li><strong>对象自身属性</strong>：优先在对象实例中查找是否存在目标属性</li>
<li><strong>原型对象查找</strong>：未找到时，通过  <code>__proto__</code>  属性（注：对象的内部原型指针）查找其构造函数对应的原型对象（prototype）</li>
<li><strong>原型链追溯</strong>：若仍未找到，则继续向上一级原型对象（Object.prototype）追溯</li>
<li><strong>终止条件</strong>：最终到达 Object.prototype 的  <code>__proto__</code>（值为 null）时停止查找</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E8%BF%9B%E9%98%B6/file-20250409204433251.jpg"
                     
                ></p>
<p><code>instanceof</code>  运算符通过原型链检测对象类型：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 业务场景示例：设备权限校验</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SensorDevice</span> &#123;&#125;  <span class="comment">// 传感器基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemperatureSensor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">SensorDevice</span> &#123;&#125;  <span class="comment">// 温度传感器子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sensor = <span class="keyword">new</span> <span class="title class_">TemperatureSensor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链检测：sensor -&gt; TemperatureSensor.prototype -&gt; SensorDevice.prototype -&gt; Object.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sensor <span class="keyword">instanceof</span> <span class="title class_">SensorDevice</span>);  <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure></div>

<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><p>深浅拷贝仅针对数组、对象等引用类型数据（堆内存存储结构）</p>
<p>直接赋值会导致新旧对象完全关联，而拷贝操作能在堆内存中创建独立的新空间，实现不同程度的独立性。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> directCopy = obj;  <span class="comment">// 直接赋值</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>本质</strong>：复制栈内存中的指针地址</li>
<li><strong>特点</strong>：新旧变量共享同一内存空间，修改任意一方都会影响另一方</li>
</ul>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝仅复制第一层简单类型值，而嵌套的引用类型仍指向原地址。</p>
<p>实现浅拷贝的主要方式包括 - 使用  <code>Object.assign()</code>  方法和展开运算符  <code>...</code><br>对于数组类型，可通过  <code>concat()</code>、<code>slice()</code>  或展开运算符实现。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;pink&#x27;</span>, <span class="attr">info</span>: &#123; <span class="attr">age</span>: <span class="number">18</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> shallowCopy1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="keyword">const</span> shallowCopy2 = &#123; ...obj &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">const</span> shallowArr1 = arr.<span class="title function_">concat</span>();</span><br><span class="line"><span class="keyword">const</span> shallowArr2 = [...arr];</span><br></pre></td></tr></table></figure></div>

<p>这些方法共同特点是：创建新对象并复制原始对象的第一层属性，当属性值为引用类型时，新旧对象会共享该属性的内存地址。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shallowCopy1.<span class="property">name</span> = <span class="string">&#x27;red&#x27;</span>;      <span class="comment">// 修改表层属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);          <span class="comment">// 输出 &#x27;pink&#x27;（未受影响）</span></span><br><span class="line"></span><br><span class="line">shallowCopy1.<span class="property">info</span>.<span class="property">age</span> = <span class="number">20</span>;     <span class="comment">// 修改深层属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">info</span>.<span class="property">age</span>);      <span class="comment">// 输出 20（同步变化）</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>✅ 隔离第一层数据</li>
<li>❌ 共享嵌套引用</li>
<li>⚠️ 适用于单层结构对象</li>
</ul>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝递归复制所有层级属性（创建完全独立的数据副本）。</p>
<p><strong>递归实现</strong><br>递归是深拷贝的核心实现原理，通过函数自调用遍历对象所有层级。基础实现需注意两点：终止条件（处理非对象类型）和特殊对象类型的处理（如数组）。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="comment">// 终止条件：非对象类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span> || target === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建容器（识别数组类型）</span></span><br><span class="line">    <span class="keyword">const</span> clone = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历属性递归拷贝</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            clone[key] = <span class="title function_">deepClone</span>(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: [<span class="number">2</span>, <span class="number">3</span>] &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> cloned = <span class="title function_">deepClone</span>(original);</span><br></pre></td></tr></table></figure></div>

<p><strong>优势</strong>：可处理循环引用<br><strong>注意</strong>：需处理特殊对象类型（如 Date、RegExp）</p>
<p><strong>JSON 序列化</strong><br>利用  <code>JSON.stringify()</code>  和  <code>JSON.parse()</code>  的组合可实现快速深拷贝，但需要注意其局限性：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> deepCopy = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br></pre></td></tr></table></figure></div>

<ul>
<li>会丢失 undefined &#x2F; function</li>
<li>无法处理循环引用</li>
<li>破坏特殊对象（如 Date 转为字符串）</li>
</ul>
<p><strong>使用 Lodash 库</strong><br>Lodash 库的  <code>_.cloneDeep()</code>  方法提供生产级深拷贝方案，能正确处理各种边界情况：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 Lodash 库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 包含特殊类型的对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> complexObj = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),         <span class="comment">// Date 对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">fn</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;测试函数&#x27;</span>),  <span class="comment">// 函数类型</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">regex</span>: <span class="regexp">/pattern/g</span>         <span class="comment">// 正则表达式</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 执行深拷贝</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> perfectCopy = _.<span class="title function_">cloneDeep</span>(complexObj);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>专业选择</strong>：处理各种边界情况的最佳实践</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常处理是构建健壮应用的基石，能有效防止程序意外崩溃。JavaScript 提供了一套完整的错误控制机制，开发者通过合理运用可显著提升代码质量。</p>
<h3 id="异常抛出-throw"><a href="#异常抛出-throw" class="headerlink" title="异常抛出 throw"></a>异常抛出 <code>throw</code></h3><p><code>throw</code>  语句用于主动触发异常流程，通常与内置  <code>Error</code>  对象配合使用。当执行到 throw 语句时，当前函数执行上下文立即终止，控制权移交最近的异常捕获块。基础使用范式：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数必须为有效数值&#x27;</span>); <span class="comment">// 创建错误实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">&#x27;number&#x27;</span> || <span class="keyword">typeof</span> y !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;参数类型必须为数字&#x27;</span>); <span class="comment">// 特定错误类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>错误类型细分</strong>：除基础 Error 外，JavaScript 提供多种派生错误类型 - <code>SyntaxError</code>：语法解析错误 - <code>TypeError</code>：类型操作错误 - <code>RangeError</code>：数值越界错误 - <code>ReferenceError</code>：引用错误</p>
<p><strong>自定义错误扩展</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">url</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(<span class="string">`EC002: <span class="subst">$&#123;url&#125;</span> 请求失败`</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">code</span> = <span class="string">&#x27;NET_ERR&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">timestamp</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NetworkError</span>(<span class="string">&#x27;/api/user&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="标准错误对象-Error"><a href="#标准错误对象-Error" class="headerlink" title="标准错误对象 Error"></a>标准错误对象 <code>Error</code></h3><p>JavaScript 的内置 <code>Error</code> 对象是异常处理机制的核心组件，提供了标准化的错误表示形式。相比简单字符串，Error 对象自动捕获上下文信息，便于调试与追踪。</p>
<p><strong>基本结构与属性</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> error = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;操作失败&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">message</span>); <span class="comment">// &quot;操作失败&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">stack</span>);   <span class="comment">// 错误发生的完整调用堆栈信息</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(error.<span class="property">name</span>);    <span class="comment">// &quot;Error&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>构造函数参数</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本形式</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Error</span>(message)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2022新增 - 错误链接</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Error</span>(message, &#123; <span class="attr">cause</span>: originalError &#125;)</span><br></pre></td></tr></table></figure></div>

<p><strong>内置错误类型</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型错误：当操作的值类型与预期不符</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;参数必须为字符串&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用错误：访问不存在的变量</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ReferenceError</span>(<span class="string">&#x27;变量未定义&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误：代码不符合语言规范</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SyntaxError</span>(<span class="string">&#x27;JSON格式不正确&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围错误：数值超出有效范围</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RangeError</span>(<span class="string">&#x27;数组长度不能为负数&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>实际应用示例</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchUserData</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!userId) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;用户ID不能为空&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userId !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;用户ID必须为数字类型&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 网络请求代码...</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (networkError) &#123;</span><br><span class="line">    <span class="comment">// 错误转换与信息增强</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;获取用户数据失败&#x27;</span>, &#123; <span class="attr">cause</span>: networkError &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用标准错误对象而非简单字符串是专业开发中的最佳实践，能显著提升应用的健壮性与可维护性。</p>
<h3 id="异常捕获-try-catch"><a href="#异常捕获-try-catch" class="headerlink" title="异常捕获 try-catch"></a>异常捕获 <code>try-catch</code></h3><p><strong>try&#x2F;catch&#x2F;finally 结构</strong><br>完整的异常处理单元包含三个逻辑块，执行流程如下图所示：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loadUserProfile</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 可能包含错误的代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123; <span class="comment">// 出错时跳转至 catch</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 无论出错都执行</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>应用场景：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 风险操作区</span></span><br><span class="line">    <span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.dynamic-content&#x27;</span>);</span><br><span class="line">    element.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;button&gt;点击&lt;/button&gt;&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 异常处理区</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`捕获异常: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误堆栈:&#x27;</span>, error.<span class="property">stack</span>);</span><br><span class="line">    <span class="comment">// 异常转换示例</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;界面渲染失败&#x27;</span>, &#123; <span class="attr">cause</span>: error &#125;);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 资源释放区</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;清理临时缓存...&#x27;</span>);</span><br><span class="line">    element = <span class="literal">null</span>; <span class="comment">// 防止内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong>错误隔离性</strong>：catch 仅捕获所在 try 块的异常</li>
<li><strong>作用域限制</strong>：try 内部声明的变量在外部不可访问</li>
<li><strong>资源保障</strong>：finally 区块始终执行，适合执行清理操作</li>
</ol>
<h2 id="浏览器调试-debugger"><a href="#浏览器调试-debugger" class="headerlink" title="浏览器调试 debugger"></a>浏览器调试 <code>debugger</code></h2><p><code>debugger</code>  语句：代码中插入调试断点</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">complexCalculation</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">debugger</span>; <span class="comment">// 自动触发断点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        result += <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>使用场景</strong>：</p>
<ul>
<li>动态调试复杂逻辑</li>
<li>配合浏览器开发者工具进行单步调试</li>
<li>临时插入断点替代 console.log</li>
</ul>
<h1 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h1><p>JavaScript 中的 <code>this</code> 关键字在不同执行环境中具有动态绑定特性，其指向规则是语言的重要特性之一。</p>
<h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p>普通函数的 <code>this</code> 值由<strong>调用方式</strong>决定，遵循”谁调用指向谁”的基本原则。当函数作为独立函数调用时，非严格模式下 <code>this</code> 默认指向全局对象（浏览器环境中为 <code>window</code>），严格模式下则指向 <code>undefined</code>。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础函数定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sayHello = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用（无明确调用者）</span></span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// window（非严格模式）/ undefined（严格模式）</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayHi</span>(); <span class="comment">// 显式绑定调用者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方法调用</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  <span class="attr">walk</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 指向user对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.<span class="property">sayHi</span> = sayHi;</span><br><span class="line">user.<span class="property">sayHello</span> = sayHello;</span><br><span class="line">user.<span class="title function_">sayHi</span>(); <span class="comment">// this指向user对象</span></span><br></pre></td></tr></table></figure></div>

<p>严格模式通过 <code>&quot;use strict&quot;</code> 指令激活，该模式下未指定调用者时 <code>this</code> 值为 <code>undefined</code>。开发时应特别注意模式差异对代码行为的影响。</p>
<h3 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数采用<strong>词法作用域</strong>规则，其 <code>this</code> 值继承自外层最近的非箭头函数的 <code>this</code> 绑定。箭头函数自身不创建 <code>this</code> 绑定，这种特性使其特别适合需要保持上下文一致的场景。</p>
<p>当访问箭头函数中的 <code>this</code> 时，解释器将执行以下操作：</p>
<ol>
<li>检查当前函数作用域是否存在 <code>this</code> 定义</li>
<li>沿作用域链逐层向上查找</li>
<li>使用首个找到的有效 <code>this</code> 绑定</li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型方法误用示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">walk</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 继承全局作用域的this（window）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.<span class="title function_">walk</span>(); <span class="comment">// 输出window对象</span></span><br></pre></td></tr></table></figure></div>

<h3 id="改变-this"><a href="#改变-this" class="headerlink" title="改变 this"></a>改变 this</h3><p>在 JavaScript 中，可通过<code>call()</code>、<code>apply()</code>和<code>bind()</code>三种方法动态控制普通函数内部<code>this</code>的指向。这些方法虽功能相似，但在使用场景和执行逻辑上存在明显差异。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p><strong><code>call()</code>方法通过立即执行函数实现<code>this</code>指向的修改</strong>。其语法为：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.<span class="title function_">call</span>(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></div>

<p>其中<code>thisArg</code>为函数运行时指定的<code>this</code>值，后续参数以逗号分隔逐个传递。例如：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">uname</span>: <span class="string">&#x27;pink&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 输出obj对象</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y); <span class="comment">// 输出3</span></span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="title function_">call</span>(obj, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 立即执行函数，this指向obj</span></span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong>：直接调用函数，适合需要明确参数数量和立即执行的场景。</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p><strong><code>apply()</code>方法与<code>call()</code>的核心区别在于参数传递方式</strong>，它通过数组接收参数：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun.<span class="title function_">apply</span>(thisArg, [argsArray])</span><br></pre></td></tr></table></figure></div>

<p>典型应用场景是处理数组数据，例如结合数学计算：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 输出obj对象</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y); <span class="comment">// 输出3</span></span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="title function_">apply</span>(obj, [<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际应用：求数组最大值</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">20</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, arr)); <span class="comment">// 输出20</span></span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong>：参数需封装为数组，适用于参数数量不确定或已有数组结构的场景。</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p><strong><code>bind()</code>方法通过生成新函数实现<code>this</code>指向的绑定</strong>，但不会立即执行原函数：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newFun = fun.<span class="title function_">bind</span>(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></div>

<p>例如实现延时操作中的<code>this</code>控制：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 输出obj对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newFn = fn.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">newFn</span>(); <span class="comment">// 手动调用新函数才会执行</span></span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong>：返回修改了<code>this</code>指向的函数副本，适用于需要延迟执行或事件回调的场景。</p>
<h4 id="核心差异与选择"><a href="#核心差异与选择" class="headerlink" title="核心差异与选择"></a>核心差异与选择</h4><table>
<thead>
<tr>
<th>特性</th>
<th>call</th>
<th>apply</th>
<th>bind</th>
</tr>
</thead>
<tbody><tr>
<td><strong>执行方式</strong></td>
<td>立即调用</td>
<td>立即调用</td>
<td>返回新函数</td>
</tr>
<tr>
<td><strong>参数形式</strong></td>
<td>逗号分隔参数</td>
<td>单数组参数</td>
<td>逗号分隔参数</td>
</tr>
<tr>
<td><strong>使用频率</strong></td>
<td>中等</td>
<td>较低</td>
<td>高频</td>
</tr>
</tbody></table>
<p><strong>关键结论</strong>：</p>
<ul>
<li>**<code>call</code>**：明确参数数量时，替代普通函数调用</li>
<li>**<code>apply</code>**：处理数组参数或不确定参数数量</li>
<li>**<code>bind</code>**：需要保持<code>this</code>指向的场景（如定时器回调、事件处理）</li>
</ul>
<p>通过理解参数传递方式和执行时机的差异，可根据具体需求选择最合适的方法控制<code>this</code>指向。</p>
<h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><p>防抖：单位时间内，频繁触发事件，只执行最后一次<br>举个栗子：王者荣耀回城，只要被打断就需要重新来<br>使用场景：<br>搜索框搜索输入。只需用户最后一次输入完，再发送请求<br>手机号、邮箱验证输入检测</p>
<p>1．防抖是什么？<br>》单位时间内，频繁触发事件，只执行最后一次<br>2．有什么使用场景呢？<br>N 搜索框搜索输入。只需用户最后一次输入完，再发送请求<br>》手机号、邮箱验证输入检测</p>
<p>利用防抖来处理-鼠标滑过盒子显示文字<br>要求：鼠标在盒子上移动，鼠标停止 500ms 之后，里面的数字才会变化+1<br>const box &#x3D; document.querySelector(‘.box’)<br>let i&#x3D;1<br>function mouseMove(）{<br>box.innerHTML&#x3D;i++<br>&#x2F;&#x2F;如果存在开销较大操作，大量数据处理，大量 dom 操作，可能会卡<br>box.addEventListener(‘mousemove’,mouseMove)<br>实现方式：</p>
<h3 id="lodash-提供的防抖"><a href="#lodash-提供的防抖" class="headerlink" title="lodash 提供的防抖"></a>lodash 提供的防抖</h3><p>&#x2F;&#x2F;利用 Lodash 库实现防抖<br>&#x2F;&#x2F;语法：_.debounce（fun，时间）<br>box.addEventListener（’mousemove’,_.debounce（mouseMove,5oo))</p>
<h3 id="手写防抖函数"><a href="#手写防抖函数" class="headerlink" title="手写防抖函数"></a>手写防抖函数</h3><p>11.声明定时器变量<br>112。每次鼠标移动（事件触发）的时候都要先判断是否有定时名<br>时器<br>1&#x2F;3。如果没有定时器，则开启定时器，存入到定时器变量里面 114.定时器里面写函数调用<br>function debounce(fn,t){<br>let timer<br>&#x2F;&#x2F;return 返回一个匿名函数<br>return function (){<br>1&#x2F;2.3.4<br>if （timer) clearTimeout(timer)<br>timer&#x3D; setTimeout（function ()<br>fn（）&#x2F;&#x2F;加小括号调用 fn 函数<br>}，t)</p>
<h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流-throttle"></a>节流-throttle</h2><p>节流：单位时间内，频繁触发事件，只执行一次</p>
<p>要求：鼠标在盒子上移动，不管移动多少次，每隔 500ms 才+1<br>const box &#x3D; document.querySelector(‘.box’)<br>leti&#x3D;1<br>function mouseMove(){<br>box.innerHTML&#x3D;i++<br>11 如果存在开销较大操作，大量数据处理，大量 dom 操作，可能会卡<br>box.addEventListener(‘mousemove’,mouseMove)<br>6266260<br>实现方式：</p>
<h3 id="lodash-提供的节流函数来处理"><a href="#lodash-提供的节流函数来处理" class="headerlink" title="lodash 提供的节流函数来处理"></a>lodash 提供的节流函数来处理</h3><p>box.addEventListener(‘mousemove’,_.throttle(mouseMove,30o0))</p>
<h3 id="手写一个节流函数来处理"><a href="#手写一个节流函数来处理" class="headerlink" title="手写一个节流函数来处理"></a>手写一个节流函数来处理</h3><p>function throttle（fn,t){<br>let timer &#x3D; null<br>return function (){<br>if（!timer）{<br>timer&#x3D; setTimeout（function （){<br>fn()I<br>11 清空定时器<br>timer &#x3D; nul1<br>}，t)</p>
<p>性能优化说明使用场景<br>防抖单位时间内，频繁触发事件，只执行最后一次搜索框搜索输入、手机号、邮箱验证输入检测<br>节流单位时间内，频繁触发事件，只执行一次高频事件：鼠标移动 mousemove、页面尺寸缩放 resize、<br>滚动条滚动 scroll 等等</p>
<h1 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h1><h2 id="防抖（debounce）-1"><a href="#防抖（debounce）-1" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><p>在单位时间内，若事件被频繁触发，仅执行最后一次操作。如同电梯关门机制——当持续有人进入时，关门动作会被不断延迟，直到无人进入后才真正执行关门。</p>
<h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ul>
<li>搜索框输入联想（用户停止输入 300ms 后发起请求）</li>
<li>表单验证（如手机号&#x2F;邮箱格式校验）</li>
<li>鼠标移动停止后触发操作（如示例中鼠标停留 500ms 后更新数值）</li>
</ul>
<p><strong>实现方案</strong></p>
<h4 id="原生-JavaScript-实现"><a href="#原生-JavaScript-实现" class="headerlink" title="原生 JavaScript 实现"></a>原生 JavaScript 实现</h4><p>通过定时器延迟执行，若重复触发则重置计时：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, t</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;                       <span class="comment">// 声明定时器变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;              <span class="comment">// 返回闭包函数</span></span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 清除前一次定时</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;     <span class="comment">// 重新计时</span></span><br><span class="line">      fn.<span class="title function_">call</span>(<span class="variable language_">this</span>);               <span class="comment">// 绑定正确this指向</span></span><br><span class="line">    &#125;, t);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mouseMove = <span class="title function_">debounce</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  box.<span class="property">innerHTML</span> = i++;             <span class="comment">// 实际业务逻辑</span></span><br><span class="line">&#125;, <span class="number">500</span>);                           <span class="comment">// 500ms防抖阈值</span></span><br><span class="line"></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, mouseMove);</span><br></pre></td></tr></table></figure></div>

<h4 id="Lodash-库实现"><a href="#Lodash-库实现" class="headerlink" title="Lodash 库实现"></a>Lodash 库实现</h4><p>通过现成方法快速应用防抖：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, _.<span class="title function_">debounce</span>(mouseMove, <span class="number">500</span>));</span><br></pre></td></tr></table></figure></div>

<h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p><strong>核心概念</strong>：在单位时间内，无论事件触发多少次，最多执行一次操作。如同水龙头限流——无论快速开关多少次，水流始终以固定频率流出。</p>
<h3 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ul>
<li>页面滚动事件监听（如每 100ms 计算滚动位置）</li>
<li>窗口 resize 时元素重排</li>
<li>高频鼠标移动轨迹采样（如示例中每 500ms 记录一次坐标）</li>
</ul>
<p><strong>实现方案</strong></p>
<h4 id="原生-JavaScript-实现-1"><a href="#原生-JavaScript-实现-1" class="headerlink" title="原生 JavaScript 实现"></a>原生 JavaScript 实现</h4><p>通过定时器控制执行间隔：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, t</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;                <span class="comment">// 初始化定时器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;              <span class="comment">// 返回闭包函数</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;                  <span class="comment">// 判断是否处于冷却期</span></span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">call</span>(<span class="variable language_">this</span>);            <span class="comment">// 执行目标函数</span></span><br><span class="line">        timer = <span class="literal">null</span>;             <span class="comment">// 重置状态允许下次触发</span></span><br><span class="line">      &#125;, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mouseMove = <span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  box.<span class="property">innerHTML</span> = i++;             <span class="comment">// 实际业务逻辑</span></span><br><span class="line">&#125;, <span class="number">500</span>);                           <span class="comment">// 500ms节流间隔</span></span><br><span class="line"></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, mouseMove);</span><br></pre></td></tr></table></figure></div>

<h4 id="Lodash-库实现-1"><a href="#Lodash-库实现-1" class="headerlink" title="Lodash 库实现"></a>Lodash 库实现</h4><p>直接调用现成节流方法：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, _.<span class="title function_">throttle</span>(mouseMove, <span class="number">500</span>));</span><br></pre></td></tr></table></figure></div>

<p><strong>防抖适用场景</strong>：关注最终状态，高频触发中只需最后一次有效（如输入停止后的搜索请求）。<br><strong>节流适用场景</strong>：需要维持固定执行频率，避免高频操作导致性能问题（如滚动事件的位置计算）。</p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> Javascript-进阶</li>
        <li><strong>作者:</strong> Wreckloud_雲之残骸</li>
        <li><strong>创建于
                :</strong> 2025-04-02 12:09:57</li>
        
            <li>
                <strong>更新于
                    :</strong> 2025-04-27 20:24:46
            </li>
        
        <li>
            <strong>链接:</strong> https://www.wreckloud.com/2025/04/02/猎识印记-领域/Javascript-进阶/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            

            
                本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/%E5%89%8D%E7%AB%AF/">#前端</a>&nbsp;
			</li>
			
			<li class="tag-item mx-0.5">
				<a href="/tags/JavaScript/">#JavaScript</a>&nbsp;
			</li>
			
			<li class="tag-item mx-0.5">
				<a href="/tags/%E8%BF%9B%E9%98%B6%E6%8F%90%E9%AB%98/">#进阶提高</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/04/07/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">移动开发-微信小程序入门</span>
						<span class="post-nav-item">上一篇</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/03/07/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/JavaScript-%E5%B8%B8%E7%94%A8API/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">前端-JavaScript API参考</span>
						<span class="post-nav-item">下一篇</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        评论
    </div>
    

        
            
    <div class="twikoo-container">
        <script data-swup-reload-script
                src='https://cdnjs.cloudflare.com/ajax/libs/twikoo/1.6.10/twikoo.all.min.js'
        ></script>
        <div id="twikoo-comment"></div>
        <script data-swup-reload-script>
            function loadTwikoo() {
                twikoo.init({
                    el: '#twikoo-comment',
                    envId: 'https://wreckloud-twikoo.hf.space',
                });
            }

            if ('true') {
                const loadTwikooTimeout = setTimeout(() => {
                    loadTwikoo();
                    clearTimeout(loadTwikooTimeout);
                }, 1000);
            } else {
                window.addEventListener('DOMContentLoaded', loadTwikoo);
            }
        </script>
    </div>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">目录</div>
		<div class="page-title">Javascript-进阶</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">局部作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">全局作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="nav-text">作用域链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="nav-text">变量提升</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6"><span class="nav-text">函数进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87"><span class="nav-text">函数提升</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-text">函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="nav-text">箭头函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="nav-text">对象解构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6"><span class="nav-text">构造函数核心机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">实例成员&#x2F;静态成员</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">内置构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-text">引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Object"><span class="nav-text">Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-%E9%87%8D%E7%82%B9%E6%96%B9%E6%B3%95"><span class="nav-text">Array 重点方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-text">Array 其他方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-text">Array 方法总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="nav-text">包装类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E9%87%8D%E7%82%B9%E6%96%B9%E6%B3%95"><span class="nav-text">String 重点方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="nav-text">String 其他方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Number"><span class="nav-text">Number</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E5%AF%B9%E8%B1%A1"><span class="nav-text">深入对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="nav-text">编程思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85"><span class="nav-text">构造函数封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85-1"><span class="nav-text">构造函数封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B"><span class="nav-text">原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%B4%E6%8A%A4%E8%A7%84%E8%8C%83"><span class="nav-text">原型链维护规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E8%A6%81%E7%B4%A0%E5%85%B3%E7%B3%BB%E4%BD%93%E7%B3%BB"><span class="nav-text">三要素关系体系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="nav-text">继承机制核心原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-text">原型链</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-text">深浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-text">深拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%8A%9B%E5%87%BA-throw"><span class="nav-text">异常抛出 throw</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E9%94%99%E8%AF%AF%E5%AF%B9%E8%B1%A1-Error"><span class="nav-text">标准错误对象 Error</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7-try-catch"><span class="nav-text">异常捕获 try-catch</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95-debugger"><span class="nav-text">浏览器调试 debugger</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this-%E6%8C%87%E5%90%91"><span class="nav-text">this 指向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="nav-text">普通函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0-1"><span class="nav-text">箭头函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98-this"><span class="nav-text">改变 this</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89"><span class="nav-text">防抖（debounce）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lodash-%E6%8F%90%E4%BE%9B%E7%9A%84%E9%98%B2%E6%8A%96"><span class="nav-text">lodash 提供的防抖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0"><span class="nav-text">手写防抖函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E6%B5%81-throttle"><span class="nav-text">节流-throttle</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lodash-%E6%8F%90%E4%BE%9B%E7%9A%84%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E6%9D%A5%E5%A4%84%E7%90%86"><span class="nav-text">lodash 提供的节流函数来处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0%E6%9D%A5%E5%A4%84%E7%90%86"><span class="nav-text">手写一个节流函数来处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81"><span class="nav-text">防抖与节流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89-1"><span class="nav-text">防抖（debounce）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">典型应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89"><span class="nav-text">节流（throttle）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-text">典型应用场景</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">死亡是涅灭,抑或是永恒?</div>
        
        <div class="text-center">
            &copy;
            
              <span>2023</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">Wreckloud_雲之残骸</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共撰写了 40 篇文章
                    </span>
                    
                        <span>
                            共 137.6k 字
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
            
                
        
                
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/Swup.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/utils.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/main.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/runtime.js" ></script>
    <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/assets/odometer-theme-minimal.css">



  <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/plugins/typed.js" ></script>



    
        <script src="https://cdn.jsdelivr.net/npm/mermaid@9.3.0/dist/mermaid.min.js"></script>
    
    <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/plugins/mermaid.js" ></script>



    <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/minimasonry.min.js" ></script>
    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/plugins/masonry.js" ></script>






    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>