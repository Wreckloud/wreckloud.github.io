<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2025/04/18/%E6%9C%AA%E5%91%BD%E5%90%8D%201/</url>
    <content><![CDATA[<p>cursor卡在“正在准备安装”怎么办</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E6%9C%AA%E5%91%BD%E5%90%8D-1/file-20250418155126471.jpg"
                     
                ></p>
<p>taskkill &#x2F;F &#x2F;IM powershell.exe</p>
<h3 id="对于Windows-11（2022年11月后更新的版本）​​"><a href="#对于Windows-11（2022年11月后更新的版本）​​" class="headerlink" title="对于Windows 11（2022年11月后更新的版本）​​"></a><strong>对于Windows 11（2022年11月后更新的版本）​</strong>​</h3><ul>
<li><p>​<strong>​直接搜索​</strong>​：打开任务管理器后，顶部会有一个​<strong>​搜索框​</strong>​，输入进程名称、PID或发布者即可实时过滤</p>
<p>  1</p>
<p>  6</p>
<p>  。</p>
</li>
<li><p>​<strong>​快捷键​</strong>​：按 <code>Alt + F</code> 可快速聚焦到搜索框</p>
<p>  1</p>
<p>  。</p>
</li>
</ul>
<h3 id="​​2-对于旧版Windows或未更新的系统​​"><a href="#​​2-对于旧版Windows或未更新的系统​​" class="headerlink" title="​​2. 对于旧版Windows或未更新的系统​​"></a>​<strong>​2. 对于旧版Windows或未更新的系统​</strong>​</h3><p>如果看不到搜索栏，可能是系统版本较旧（如Windows 10或未更新的Win11），可通过以下方法查找进程：</p>
<ul>
<li>​<strong>​手动筛选​</strong>​：<ol>
<li><p>打开任务管理器（<code>Ctrl + Shift + Esc</code>）。</p>
</li>
<li><p>在“进程”选项卡中，点击列标题（如“名称”“CPU”）排序，滚动查找目标进程</p>
<p> 2</p>
<p> 3</p>
<p> 。</p>
</li>
</ol>
</li>
<li>​<strong>​命令行工具​</strong>​：<ul>
<li>按 <code>Win + R</code> 输入 <code>cmd</code>，运行命令：<br>我在安装windsurf的时候也遇到了类似的问题，是因为vscode的其中的好像是某个版本和windows系统不太兼容来着，这个时候打开任务管理器，搜索powershell，然后把搜索到的powershell的进程都关闭，然后就自动继续安装了</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>hello websites</title>
    <url>/2023/09/17/%E5%95%B8%E6%9C%88%E5%97%B7%E5%A3%B0-%E6%88%90%E9%95%BF/%E5%8D%9A%E5%AE%A2/hello-websites/</url>
    <content><![CDATA[<h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><h2 id="安装-git-和-node-js"><a href="#安装-git-和-node-js" class="headerlink" title="安装 git 和 node.js"></a>安装 git 和 node.js</h2><p>由于 Hexo 是基于 Node.js 驱动的一款博客框架, 所以安装 NodeJS.</p>
<p><a class="link"   href="https://nodejs.org/en/" >下载 node.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>为了能把 hexo 部署到 github 仓库, 还需要安装 git.</p>
<p><a class="link"   href="https://git-scm.com/downloads" >下载 git<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>安装之后可以输入以下命令查看是否安装成功:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>npm（Node Package Manager, Node 包管理器）是 Node.js 的默认包管理工具.</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/hello-websites/file-20241225135656753.jpg"
                     
                ></p>
<h2 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h2><p>环境准备好了就可使用 npm 开始安装 Hexo 了, 在命令行输入执行如下命令:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></div>

<p>可能会出现下载缓慢的情况, 可以尝试使用国内镜像源.<br><a href="../../_posts/Node-js%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE.md">如何更改 npm 源?</a></p>
<p>待到安装完成后, 在一处新建文件夹作为博客的根目录.<br> 然后进入这个文件夹并右键空白处, 选择 “Open git bash here” 打开 git 命令行, 接着依次输入以下命令:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init Blog <span class="comment"># 创建新的 Hexo 博客项目, 文件夹名为 Blog.</span></span><br><span class="line"><span class="built_in">cd</span> Blog <span class="comment"># 进入博客目录.</span></span><br><span class="line">npm install <span class="comment"># 安装 Hexo 所需的依赖包.</span></span><br></pre></td></tr></table></figure></div>

<p>这样就完成了 Hexo 的安装, 并创建了一个新的博客项目.<br>运行以下命令启动本地服务器:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></div>

<p>启动本地服务器后, 就可访问 <a class="link"   href="http://localhost:4000/" >http://localhost:4000<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 看到博客效果.</p>
<h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>Hexo 官方主题站点: <a class="link"   href="https://hexo.io/themes/" >https://hexo.io/themes/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>(可能需要科学上网)</p>
<p>这里推荐我使用的主题 Redefine, 它很简洁, 功能也很强大.</p>
<p><a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine" >Redefine 官方 GitHub 页<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://redefine-docs.ohevan.com/" >Redefine 主题配置指南<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>将下载的主题文件夹放到<strong>博客根目录</strong>下的 <code>themes</code> 文件夹下, 并修改<strong>根目录</strong>下博客配置文件 <code>_config.yml</code> 中的 <code>theme</code> 选项为 <code>主题文件夹名称</code>.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/hello-websites/file-20241225135707412.jpg"
                     
                ></p>
<p>此外, 在 <code>_config.yml</code> 还有许多其他配置选项, 如网站标题, 网站描述等.<br>都可以根据自己的喜好进行修改.</p>
<p>可以随时运行以下命令来在本地服务器 (<a class="link"   href="http://localhost:4000/" >http://localhost:4000<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>) 预览博客效果:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></div>

<h1 id="部署到-GitHub-Pages"><a href="#部署到-GitHub-Pages" class="headerlink" title="部署到 GitHub Pages"></a>部署到 GitHub Pages</h1><h2 id="创建-GitHub-仓库"><a href="#创建-GitHub-仓库" class="headerlink" title="创建 GitHub 仓库"></a>创建 GitHub 仓库</h2><p>首先, 你需要有一个 GitHub 账号, 并创建一个新的仓库.</p>
<p>点击 Start project 或者下面的 new repository 建立一个新的仓库，注意 Github 仅能使用一个同<br>名仓库的代码托管一个静态站点，这里注意仓库名一定要是：<br>用户名.github.io</p>
<h2 id="配置-SSH-密钥"><a href="#配置-SSH-密钥" class="headerlink" title="配置 SSH 密钥"></a>配置 SSH 密钥</h2><p>为了能将本地仓库推送到 GitHub 仓库, 需要使用 git 配置 SSH 密钥.<br>继续在 git bash 中输入以下命令:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置 Git 的全局用户名和邮箱.</span></span><br><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;邮箱地址&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 SSH 密钥对, 用于连接 GitHub 仓库.</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;上面的邮箱&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>接着按照提示, 按三次回车便可在指定的目录下生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件.</p>
<p>也可以使用 cat 命令查看密钥对内容:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></div>

<p>验证 SSH 密钥是否成功配置:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></div>

<p>如果出现 <code>Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code> 字样, 则说明 SSH 密钥配置成功.</p>
<p>将内容复制到 GitHub 仓库的 SSH and GPG keys 页面,<br>依次点击:</p>
<blockquote>
<p>头像&gt;Settings&gt;SSH and GPG keys&gt;New SSH key</p>
</blockquote>
<p>将刚刚的密钥粘贴到 Key 文本框中, 随后点击 Add SSH key 按钮.</p>
<h2 id="推送本地仓库到-GitHub"><a href="#推送本地仓库到-GitHub" class="headerlink" title="推送本地仓库到 GitHub"></a>推送本地仓库到 GitHub</h2><p>接着回到 博客根目录下的 <code>_config.yml</code> 配置文件配置参数.<br>拉到文件末尾, 填上以下配置.</p>
<div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></div>

<p>例如, 我的 Github 用户名是 Wreckloud, 则配置如下:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/hello-websites/file-20241225135716745.jpg"
                     
                ></p>
<p>最后,需要安装 <code>hexo-deployer-git</code> 插件, 运行以下命令:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></div>

<p>然后, 运行以下命令将本地仓库推送到 GitHub 仓库:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g    <span class="comment"># 先生成</span></span><br><span class="line">hexo d    <span class="comment"># 接着部署到Github上</span></span><br></pre></td></tr></table></figure></div>

<p>等待部署完成后, 就可以在浏览器中访问 <code>https://用户名.github.io</code> 访问你的博客了.</p>
<h1 id="写文章并上传"><a href="#写文章并上传" class="headerlink" title="写文章并上传"></a>写文章并上传</h1><p>新建文章:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>生成的文件会在 <code>source/_posts</code> 文件夹下.</p>
<p>文章是 Markdown 格式的, 编辑器推荐使用 Visual Studio Code, 它有丰富的插件支持 Markdown 语法高亮和自动补全.</p>
<p><a class="link"   href="https://markdown.com.cn/basic-syntax/" >markdown 语法<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://code.visualstudio.com/download" >Visual Studio Code 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>文章保存后, 生成并部署到 Github 上, 我比较常用的命令是:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d <span class="comment"># 生成并部署到Github上</span></span><br></pre></td></tr></table></figure></div>

<h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="文章属性自定义"><a href="#文章属性自定义" class="headerlink" title="文章属性自定义"></a>文章属性自定义</h2><p>Hexo 官方文档中有关于文章属性的详细介绍, 这里只介绍一些常用的属性:</p>
<div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">文章标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-09-17 13:50:59</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;标签1&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;标签2&quot;</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">&quot;分类&quot;</span></span><br><span class="line"><span class="attr">excerpt:</span> <span class="string">&quot;文章摘要&quot;</span></span><br><span class="line"><span class="attr">thumbnail:</span> <span class="string">&quot;文章缩略图&quot;</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>文章属性自定义</p>

    </div>
    <div class="notel-content">
      <p><strong>文章时效性</strong><br>expires: 2023-08-31 23:59:59<br><strong>置顶文章:</strong><br>sticky: 值 (值越大,顶置文章越靠前)<br><strong>首页摘要:</strong><br>excerpt: “这是文章摘要”<br><strong>文章缩略图:</strong><br>thumbnail: “图片链接”<br><strong>文章头图:</strong><br>banner: “图片链接”<br>cover: “图片链接”</p>

    </div>
  </div>

<h3 id="文章模块"><a href="#文章模块" class="headerlink" title="文章模块"></a>文章模块</h3><p>此外,主题作者还加入了一些方便的模块让笔记更好看</p>
<p>例如 提示块, 选项卡等.<br>具体查看官网说明: <a class="link"   href="https://redefine-docs.ohevan.com/zh/modules/notes" >redefine 写作模块<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>方便自己随取随用的版本: <a href="/2024/12/25/啸月嗷声-成长/博客/常用物件存放处/">常用物件存放处</a></p>
<h2 id="hexo-快速指令"><a href="#hexo-快速指令" class="headerlink" title="hexo 快速指令"></a>hexo 快速指令</h2><ol>
<li>创建一篇文章</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>运行网页</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line"><span class="comment"># 可以简写为</span></span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>修改网页内容后重新生成网页</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>部署到 github 的仓库</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://hexo.io/" >关于 hexo 的更多信息<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br> <a class="link"   href="https://moren5483.github.io/2022/07/17/github/" >关于 hexo+github 仓库搭建博客<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<blockquote>
<p>希望能在这里留下一些有意思的东西!</p>
</blockquote>
]]></content>
      <categories>
        <category>啸月嗷声-成长</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>攻略</tag>
        <tag>网站</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>常用物件存放处</title>
    <url>/2024/12/25/%E5%95%B8%E6%9C%88%E5%97%B7%E5%A3%B0-%E6%88%90%E9%95%BF/%E5%8D%9A%E5%AE%A2/%E5%B8%B8%E7%94%A8%E7%89%A9%E4%BB%B6%E5%AD%98%E6%94%BE%E5%A4%84/</url>
    <content><![CDATA[<p>只是为了我使用方便和限制篇幅, 这里只展示例子, 详细使用方式请参考:<br><a class="link"   href="https://redefine-docs.ohevan.com/zh/modules/notes" >redefine 写作模块<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="提示块"><a href="#提示块" class="headerlink" title="提示块"></a>提示块</h1><h3 id="大号提示块"><a href="#大号提示块" class="headerlink" title="大号提示块"></a>大号提示块</h3><p>我常用的几个例子:</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p>换行测试<br>换行测试<br>换行测试</p>

    </div>
  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% notel default fa-info 信息 %&#125;</span><br><span class="line">换行测试</span><br><span class="line">换行测试</span><br><span class="line">换行测试</span><br><span class="line">&#123;% endnotel %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>换行测试<br>换行测试<br>换行测试</p>

    </div>
  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% notel blue 提示 %&#125;</span><br><span class="line">换行测试</span><br><span class="line">换行测试</span><br><span class="line">换行测试</span><br><span class="line">&#123;% endnotel %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>自定义标题</p>

    </div>
    <div class="notel-content">
      <p>换行测试<br>换行测试<br>换行测试</p>

    </div>
  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% notel red 自定义标题 %&#125;</span><br><span class="line">换行测试</span><br><span class="line">换行测试</span><br><span class="line">换行测试</span><br><span class="line">&#123;% endnotel %&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="小号提示块"><a href="#小号提示块" class="headerlink" title="小号提示块"></a>小号提示块</h3><p>我常用的几个例子:</p>

  <div class="note p-4 mb-4 rounded-small default">
    <p>default 提示块标签</p>

  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125; default 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small success">
    <p>success 提示块标签 </p>

  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% note success %&#125; success 提示块标签 &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small info">
    <p>info 提示块标签 </p>

  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% note info %&#125; info 提示块标签 &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small warning">
    <p>warning 提示块标签 </p>

  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% note warning %&#125; warning 提示块标签 &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small danger">
    <p>danger 提示块标签 </p>

  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% note danger %&#125; danger 提示块标签 &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small red icon-padding">
    <i class="note-icon fa-solid fa-bolt"></i><p>自定义提示块标签 </p>

  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% note red fa-bolt%&#125; 自定义提示块标签 &#123;%endnote %&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h1><a class="button  [可选大小]" href='[url]' title='[名称]'><i class='[可选图标]'></i> [名称]</a>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% btn [可选大小]::[名称]::[url]::[可选图标] %&#125;</span><br></pre></td></tr></table></figure></div>

<p>不设置任何参数的 <a class="button " href='/' title='按钮'>按钮</a> 适合融入段落中。</p>
<p>regular 按钮适合独立于段落之外：</p>
<a class="button  regular" href='https://www.ohevan.com' title='示例博客'><i class='fa-solid fa-play-circle'></i> 示例博客</a>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% btn regular::示例博客::https://www.ohevan.com::fa-solid fa-play-circle %&#125;</span><br></pre></td></tr></table></figure></div>

<a class="button  regular" href='https://www.ohevan.com' title='示例博客'><i class='fa-solid fa-play-circle'></i> 示例博客</a>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% btn regular::示例博客::https://www.ohevan.com::fa-solid fa-play-circle %&#125;</span><br></pre></td></tr></table></figure></div>

<p>large 按钮更具有强调作用，建议搭配 center 使用：</p>
<a class="button  center large" href='https://redefine-docs.ohevan.com' title='开始使用'><i class='fa-solid fa-download'></i> 开始使用</a>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% btn center large::开始使用::https://redefine-docs.ohevan.com::fa-solid fa-download %&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="分栏选项卡"><a href="#分栏选项卡" class="headerlink" title="分栏选项卡"></a>分栏选项卡</h1><div class="tabs" id="tab-first-unique-name"><ul class="nav-tabs"><li class="tab active"><a class="#first-unique-name-1">First Tab</a></li><li class="tab"><a class="#first-unique-name-2">Second Tab</a></li><li class="tab"><a class="#first-unique-name-3">Third Tab</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-pane" id="first-unique-name-2"><p><strong>This is Tab 2.</strong></p>
<p>This is Tab 2.</p></div><div class="tab-pane" id="first-unique-name-3"><p><strong>This is Tab 3.</strong></p>
<p>This is Tab 3.</p>
<p>This is Tab 3.</p></div></div></div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% tabs First unique name %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab First Tab--&gt;</span><br><span class="line"></span><br><span class="line">**This is Tab 1.**</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab Second Tab--&gt;</span><br><span class="line"></span><br><span class="line">**This is Tab 2.**</span><br><span class="line"></span><br><span class="line">This is Tab 2.</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab Third Tab--&gt;</span><br><span class="line"></span><br><span class="line">**This is Tab 3.**</span><br><span class="line"></span><br><span class="line">This is Tab 3.</span><br><span class="line"></span><br><span class="line">This is Tab 3.</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中，<code>页面内不重复的ID</code>  为你为这个选项卡创建的唯一标识符，可以随便取。</p>
<p>每个栏目内容使用  <code>&lt;!-- tab 栏目名称 --&gt;</code>  和  <code>&lt;!-- endtab --&gt;</code>  来定义。</p>
]]></content>
      <categories>
        <category>啸月嗷声-成长</category>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>未命名小说</title>
    <url>/2025/04/19/%E9%A3%8E%E7%B5%AE%E8%8C%B8%E6%9D%82-%E6%94%B6%E9%9B%86/%E5%B0%8F%E8%AF%B4/%E6%9C%AA%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<p>今日破晓时分的寂静难得令人愉悦，我舒展着肩颈推开卧室门——</p>
<p>直到餐桌上的”艺术品”刺入眼帘。</p>
<hr>
<p>我盯着那根斜插的胫骨，晨光正沿着骨缝里干涸的血丝爬行。这匹狼甚至贴心地在骨腔里插了束野蔷薇——用他昨晚捕猎时撕裂的亚麻衬衫碎片扎成蝴蝶结，沾着露水的花瓣正往我的枫糖浆里滴落某种暗红色液体。</p>
<p>我捏着骨头的指尖开始发烫，已经数不清收到骸云”礼物”的次数。从沼泽巨蜥的毒牙到嵌着碎晶的岩龟壳，现在他居然学会给战利品做造型了。<br>那簇野蔷薇的根部还粘着可疑的暗红碎肉，让整个房间弥漫着铁锈与腐甜的死亡气息。<br>罪魁祸首就蜷在壁炉边，蓬松尾巴盖着鼻尖随呼吸起伏。</p>
<p>我揪住他后颈绒毛的瞬间，那对毛茸茸的耳朵立即软绵绵耷拉成投降姿势。</p>
<p>“早安气味。”<br>他喉咙里滚动出咕噜声，”木屑、铁锈和…愤怒的柠檬香？”</p>
<p>“说过多少次——“<br>我抄起作为礼物的腿骨抵住他抽动的鼻翼。<br>“没有人类会喜欢尸体当装饰品，”<br>“上个月你送给隔壁领主的礼物…”<br>我掰着他的下巴，好让这匹笨狼能够清醒些，”血淋淋的魔熊心脏？”</p>
<p>“是最珍贵的部位，嗷。”骸云挣扎着甩头，”人类不是用红色代表爱吗？”<br>他全然不知那张通缉令正贴在隔壁城镇的公会告示栏——那潦草的炭笔把他画得像头直立的山猪。</p>
<p>我握腿骨的手背暴起青筋，<br>面前这只灰狼貌似清醒了些，看见我手中握着的东西是朝着自己来的，弓着背往后缩。</p>
<p>“这是恐爪兽的胫骨！”他喉咙里挤出讨好的呼噜声，”能磨成三十支箭镞，或者…”<br>我猛地用骨头敲向他的脑门，清脆的”咚”声像打在包铁橡木盾上——这家伙头盖骨硬得能当砧板。<br>他发出幼犬被踩尾般的哀嚎，整具躯体蜷成一团滚到壁炉，哀嚎一声。</p>
<p>“装疼倒是越来越熟练了。”我大步靠近灰狼，一把揪住他的右耳说道。<br>“上次被石化蜥蜴撞飞三米都没见你哼一声。”<br>我抄起’礼物’戳向他真正脆弱的腰侧。<br>这匹比我还高的巨狼瞬间蜷成毛球，爆发的呜咽声震得壁炉灰簌簌下落。</p>
<p>…</p>
<hr>
<p>骸云被早起的突然袭击打败在地，委屈地趴在一旁。<br>烟雨抽出小刀削掉骨头上多余的肉，刀柄上磨损的狼牙硌着掌心。这是骸云用乳牙期脱落的犬齿打磨的礼物，当时这只笨蛋满脸是血叼着它出现，还以为自己要死于换牙了。<br>想到这里，烟雨还是决定原谅他。</p>
<p>“下次直接送花吧。”我扯了扯他垂落的尾巴尖，揪着他的耳朵说到，”人类更喜欢不会蠕动的东西。”</p>
<p>“好！”<br>骸云突然弹起来扑向我，耳朵突然竖成锥形，獠牙精准叼住我束发的皮绳。温热的舌头在离我脸颊半寸处急刹车，改成用鼻尖蹭我的下巴。<br>我确实警告过他管好自己沾满口水的舌头，看来他还记得。</p>
<p>“鼻子离我远点！”<br>我用手肘抵住他胸口，他趁机把毛茸茸的脑袋拱进我颈窝。<br>晨光在我们交叠的影子上织出金线，而餐桌上那支带牙印的野蔷薇，在胫骨里开得比任何魔法造物都鲜活。</p>
]]></content>
      <categories>
        <category>风絮茸杂-收集</category>
        <category>小说</category>
      </categories>
  </entry>
  <entry>
    <title>51单片机原理与应用</title>
    <url>/2024/09/30/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E5%B5%8C%E5%85%A5%E5%BC%8F/51%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="51单片机介绍"><a href="#51单片机介绍" class="headerlink" title="51单片机介绍"></a>51单片机介绍</h1><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先需要安装几个软件</p>
<a class="button  center large" href='https://www.123684.com/s/bCMjVv-z6ot' title='开始使用'><i class='fa-solid fa-download'></i> 开始使用</a>
<h4 id="安装-Keil-集成开发环境"><a href="#安装-Keil-集成开发环境" class="headerlink" title="安装 Keil 集成开发环境"></a>安装 Keil 集成开发环境</h4><p>Keil 是用来写 C 语言程序的, 它还可以将程序编译成单片机可以识别的指令集.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E4%B8%8B%E8%BD%BDkeil.png"
                      alt="alt text"
                ></p>
<h4 id="STC-ISP-安装"><a href="#STC-ISP-安装" class="headerlink" title="STC-ISP 安装"></a>STC-ISP 安装</h4><p>STC-ISP 可以将编译好的程序下载到单片机中, 以让程序能在单片机运行.</p>
<h4 id="USB驱动"><a href="#USB驱动" class="headerlink" title="USB驱动"></a>USB驱动</h4><p>安装了串口驱动后 STC-ISP 才能识别单片机.</p>
<blockquote>
<p>由于我已经安装的时候没有截图写教程, 所以先就不写详细的安装步骤了(</p>
</blockquote>
<h3 id="51-单片机简介"><a href="#51-单片机简介" class="headerlink" title="51 单片机简介"></a>51 单片机简介</h3><p>单片机(MicrocontrollerUnit, MCU)算一种袖珍版计算机, 一个芯片就能构成完整的计算机系统.<br>单片机成本低, 体积小, 结构简单. 在学习使用单片机的过程中, 可以快速了解计算机原理与其结构.  </p>
<p>Intel 公司推出了 8051 单片机内核, 因此这种类似于 8051 内核的单片机, 我们都统称为 51 单片机.  </p>
<p>51 单片机的<br>位数: 8位.<br>RAM: 512字节.<br>ROM: 8K (Flash).<br>工作频率: 12Mhz.  </p>
<blockquote>
<p>RAM: 随机存取存储器, 用于存储程序和数据(会丢失数据, 相当于工作台).<br>ROM: 只读存储器, 用于存储程序(长期存储, 相当于仓库).  </p>
</blockquote>
<h3 id="单片机内部结构图"><a href="#单片机内部结构图" class="headerlink" title="单片机内部结构图"></a>单片机内部结构图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA.png"
                      alt="alt text"
                ></p>
<blockquote>
<p>乱七八糟的我也不爱看</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA.png"
                      alt="alt text"
                ></p>
<h1 id="LED-灯控制"><a href="#LED-灯控制" class="headerlink" title="LED 灯控制"></a>LED 灯控制</h1><h3 id="新建一个-Keil-工程"><a href="#新建一个-Keil-工程" class="headerlink" title="新建一个 Keil 工程"></a>新建一个 Keil 工程</h3><p>为了方便导入和管理代码:</p>
<p>首先, 在电脑中新建一个文件夹, 作为所有 Keil 工程的存放位置.<br>然后, 打开 Keil 软件, 新建第一个工程文件夹.  </p>
<p>如果不这么做, 文件就会散成一团(</p>
<p>接着, 如图所示.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.png"
                      alt="alt text"
                ></p>
<p>然后在跳出的对话框中选中 Atmel 下的 AT89C52.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E9%80%89%E6%8B%A9%E6%A0%B8%E5%BF%83.png"
                      alt="alt text"
                ></p>
<p>会有一个对话框询问是否自动创建开始文件.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E5%AF%B9%E8%AF%9D%E6%A1%86.png"
                      alt="alt text"
                ></p>
<p>推荐选 <code>否</code> ,选了是影响也不大.</p>
<p>接着, 我们要在项目中添加一个 .c 的文件, 作为程序的入口.<br>由于这个版本的 keil 不能直接新建, 所以我们得先在 <strong>系统的文件管理器</strong> 中新建文件.</p>
<p>在文件管理器中找到项目文件夹, 右键新建一个文件, 命名为 <code>main.c</code>.</p>
<p>然后在 keil 中将这个 <code>main.c</code> 文件添加到工程中.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%B7%BB%E5%8A%A0%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6.png"
                      alt="alt text"
                ></p>
<p>这样, 工程就新建完成了!  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%88%90%E5%8A%9F.png"
                      alt="alt text"
                ></p>
<p>接下来就可以开始编写代码了.</p>
<p>为了能在程序编译好后能直接得到 .hex 文件, 我们还得在 Keil 中设置一下编译选项.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E7%BC%96%E8%AF%91%E8%AE%BE%E7%BD%AE.png"
                      alt="alt text"
                ></p>
<p>在 <code>Output</code> 选项卡中, 勾选 <code>Create HEX file</code>.</p>
<h3 id="LED-灯控制-1"><a href="#LED-灯控制-1" class="headerlink" title="LED 灯控制"></a>LED 灯控制</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/LED.png"
                      alt="alt text"
                ></p>
<p>LED 灯是指发光二极管, 它只允许电流从一个方向通过.</p>
<blockquote>
<p>当我们把电池的正极接到P型材料这一端, 负极接到N型材料这一端时, 电流就可以顺利通过LED.<br>因为电子和空穴可以分别从N型和P型材料流向对方, 然后在中间的PN结区域相遇并复合, 发出光来.<br>反之, 电子和空穴都被推向相反的方向, 就无法发光了.</p>
</blockquote>
<p>在开发板中, LED模块连接如图所示:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/LED%E6%8E%A5%E7%BA%BF.png"
                      alt="alt text"
                ></p>
<p>如图所示, LED 模块有八个 LED 灯. 右边接在 VCC ,也就是电源的正极, 左边与单片机的 P2(P2.0~P2.7) 引脚相连.</p>
<p>在 LED 与 电源正极 之间 有两个 1K 的电阻, 起到限流的作用, 防止 LED 灯发光过强而烧毁.</p>
<h4 id="如何点亮-LED-灯"><a href="#如何点亮-LED-灯" class="headerlink" title="如何点亮 LED 灯?"></a>如何点亮 LED 灯?</h4><p>为了让 LED 灯点亮, 需要在 LED 的阳极和阴极之间形成电流的通路.<br>已知 LED 灯的一侧接通的是电源正极, 我们只要能控制另一端引脚的电压即可.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    P2 = <span class="number">0xFE</span>; <span class="comment">// 1111 1110 16进制为0xFE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但程序并不认识 <code>P2</code> 这个寄存器, 这时只需要导入头文件即可.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regx52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    P2 = <span class="number">0xFE</span>; <span class="comment">// 1111 1110 16进制为0xFE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个头文件中就有 <code>P2</code> 这个寄存器的定义.</p>
<p>接着, 将写好的程序编译成 .hex 文件, 下载到单片机中.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F.png"
                      alt="alt text"
                ></p>
<h4 id="LED-流水灯"><a href="#LED-流水灯" class="headerlink" title="LED 流水灯"></a>LED 流水灯</h4><p>让 8 个 LED 灯依次点亮, 然后再依次熄灭.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REG52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>		</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(xms)</span><br><span class="line">	&#123;</span><br><span class="line">	i = <span class="number">500</span>;</span><br><span class="line">	<span class="keyword">while</span> (--i);</span><br><span class="line">	xms--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P2 = <span class="number">0xFE</span>; </span><br><span class="line">        Delay(<span class="number">800</span>);</span><br><span class="line">        P2 = <span class="number">0xFD</span>; </span><br><span class="line">        Delay(<span class="number">400</span>);</span><br><span class="line">        P2 = <span class="number">0xFB</span>; </span><br><span class="line">        Delay(<span class="number">200</span>);</span><br><span class="line">        P2 = <span class="number">0xF7</span>; </span><br><span class="line">        Delay(<span class="number">100</span>);</span><br><span class="line">        P2 = <span class="number">0xEF</span>; </span><br><span class="line">        Delay(<span class="number">100</span>);</span><br><span class="line">        P2 = <span class="number">0xDF</span>; </span><br><span class="line">        Delay(<span class="number">200</span>);</span><br><span class="line">        P2 = <span class="number">0xBF</span>; </span><br><span class="line">        Delay(<span class="number">400</span>);</span><br><span class="line">        P2 = <span class="number">0x7F</span>; </span><br><span class="line">        Delay(<span class="number">800</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<h4 id="单独操作位寄存器"><a href="#单独操作位寄存器" class="headerlink" title="单独操作位寄存器"></a>单独操作位寄存器</h4><p>在头文件 <code>regx52.h</code> 中, 我们可以看到寄存器的定义.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">sbit P2_0 = <span class="number">0xA0</span>;</span><br><span class="line">sbit P2_1 = <span class="number">0xA1</span>;</span><br><span class="line">...</span><br><span class="line">sbit P2_7 = <span class="number">0xA7</span>;</span><br></pre></td></tr></table></figure></div>

<p>我们可以直接操作这些寄存器.</p>
<blockquote>
<p>注意在 <code>reg52.h</code> 中并没有定义, 需要自己声明.</p>
</blockquote>
<h1 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h1><p>按钮在单片机中的接线如图所示:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%8C%89%E9%92%AE.png"
                      alt="alt text"
                ></p>
<p>按钮一端接地(电源负极), 另一端接接在单片机的 IO 口上. 当单片机接电时, IO 口为高电平, 按钮按下, 电路导通, IO 口变为低电平.</p>
<blockquote>
<p>即 按钮按下, IO 口为 ‘0’.<br>按钮松开, IO 口为 ‘1’.</p>
</blockquote>
<h3 id="按键的抖动"><a href="#按键的抖动" class="headerlink" title="按键的抖动"></a>按键的抖动</h3><p>对于机械开关,当机械触点断开, 闭合时,由于机械触点的弹性作用, 一个开关在闭合时不会马上稳定地接通, 在断开时也不会立马完全断开, 所以在开关闭合及断开的瞬间会伴随一连串的抖动.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%8C%89%E9%92%AE%E6%8A%96%E5%8A%A8.png"
                      alt="alt text"
                ></p>
<p>最方便的解决方法就是检测到按下时让程序延时一段时间即可.</p>
<p>用按钮控制 LED 灯亮灭:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REG52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个延时函数, 抹除抖动的影响.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>		</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(xms)</span><br><span class="line">	&#123;</span><br><span class="line">	i = <span class="number">500</span>;</span><br><span class="line">	<span class="keyword">while</span> (--i);</span><br><span class="line">	xms--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P2 = <span class="number">0xFE</span>; <span class="comment">// 点亮全部 LED 灯</span></span><br><span class="line">        <span class="keyword">if</span>(P2_0 == <span class="number">0</span>)&#123; <span class="comment">// 按下按钮</span></span><br><span class="line">            P2 = <span class="number">0x00</span>; <span class="comment">// 熄灭全部 LED 灯</span></span><br><span class="line">        &#125;</span><br><span class="line">        Delay(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<h1 id="定时器-计数器"><a href="#定时器-计数器" class="headerlink" title="定时器&#x2F;计数器"></a>定时器&#x2F;计数器</h1><p>在之前, 我们使用的是 <code>Delay()</code> 函数来延时, 但这种方式很不精确, 而且会占用主程序, 无法在 <code>Delay()</code> 函数执行时执行其他任务.</p>
<p>定时器就能用来实现精确的延时, 其电路的连接和运转均在单片机内部完成.</p>
<p>在 STC89C52 中, 有 T0, T1, T2 这三个定时器.<br>T0 和 T1 与传统的 51单片机 兼容, T2 则是此型号单片机增加的资源.</p>
<p>除了用作定时, 它也可用作计数器.</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>定时器在单片机内部就像一个小闹钟. 根据时钟的输出信号, 每隔 <code>一个时间段</code>, 计数单元的数值就会增加一.<br>当计数单元数值增加到 <code>设定的提醒时间</code> 时, 计数单元就会向 <code>中断系统</code> 发出中断申请, 使程序跳转到中断服务函数中执行.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E6%9D%A5.png"
                      alt="alt text"
                ></p>
<blockquote>
<p><code>中断系统</code> 类似于 <code>定时器</code>, 也是单片机内部的资源.</p>
</blockquote>
<p>STC89C52 的 <code>定时器/计数器</code> T0, T1 都有如下几种工作模式:</p>
<ul>
<li>模式0: 13 位定时器&#x2F;计数器</li>
<li>模式1: 16 位定时器&#x2F;计数器 (常用)</li>
<li>模式2: 8 位自动重装模式</li>
<li>模式3: 两个 8 位计数器</li>
</ul>
<p>工作模式 1 的框图:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%A1%86%E5%9B%BE.png"
                      alt="alt text"
                ></p>
<h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>如图, 在计数器里有</p>
<ul>
<li>TL(Timer Low) : 低字节</li>
<li>TH(Timer High): 高字节</li>
</ul>
<p>两个字节, 它们总共可以存储 65536 个不同的数值.</p>
<p><code>时钟模块</code> 稳定地给 <code>计数器</code> 脉冲. 每来一次脉冲, 计数器就会增加 1.<br>直到 计数数到 65536 , 计数器溢出, 置一个标志位, 并向 <code>中断系统</code> 发出中断申请.</p>
<h4 id="定时器时钟"><a href="#定时器时钟" class="headerlink" title="定时器时钟"></a>定时器时钟</h4><p>系统时钟, 即晶振周期.</p>
<h4 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h4><p>中断系统是为使 CPU 具有对外界紧急事件的实时处理能力而设置的.  </p>
<p>请示 CPU 中断的请求称为中断源, 中断源的轻重缓急称之为中断优先级.<br>高优先级的中断可以打断低优先级的中断.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F%E5%85%AD%E6%88%90.png"
                      alt="alt text"
                ></p>
<p>不同型号的单片机拥有不同的中断资源.<br>在 STC89C52 中, 中断源共有 8 个.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F.png"
                      alt="alt text"
                ></p>
<p>不使用定时器依然可以实现延时, 可以通过查询 TF0 标志位.<br>就像你一直需要检查你的钟一样.</p>
<p>中断号:</p>
<table>
<thead>
<tr>
<th>中断源</th>
<th>中断服务函数</th>
<th>中断号</th>
</tr>
</thead>
<tbody><tr>
<td>外部中断0</td>
<td>Int0_Routine(void)</td>
<td>interrupt 0;</td>
</tr>
<tr>
<td>定时器0</td>
<td>Timer0_Routine(void)</td>
<td>interrupt 1;</td>
</tr>
<tr>
<td>外部中断1</td>
<td>Int1_Routine(void)</td>
<td>interrupt 2;</td>
</tr>
<tr>
<td>定时器1</td>
<td>Timer1_Routine(void)</td>
<td>interrupt 3;</td>
</tr>
<tr>
<td>串口中断</td>
<td>UART_Routine(void)</td>
<td>interrupt 4;</td>
</tr>
<tr>
<td>定时器2</td>
<td>Timer2_Routine(void)</td>
<td>interrupt 5;</td>
</tr>
<tr>
<td>外部中断2</td>
<td>Int2_Routine(void)</td>
<td>interrupt 6;</td>
</tr>
<tr>
<td>外部中断3</td>
<td>Int3_Routine(void)</td>
<td>interrupt 7;</td>
</tr>
</tbody></table>
<h2 id="定时器相关的寄存器"><a href="#定时器相关的寄存器" class="headerlink" title="定时器相关的寄存器"></a>定时器相关的寄存器</h2><p>寄存器是连接软硬件的桥梁, 相当于一个复杂机器的操作按钮.</p>
<p>在单片机中寄存器就是一段特殊的 RAM 存储器.<br>一方面, 寄存器可以存储和读取数据,<br>另一方面, 每一个寄存器背后都连接了一根导线, 控制着电路的连接方式.</p>
<h3 id="TCON-定时器控制寄存器"><a href="#TCON-定时器控制寄存器" class="headerlink" title="TCON 定时器控制寄存器"></a>TCON 定时器控制寄存器</h3><p>TCON(Timer Control) 为定时器&#x2F;计数器 T0, T1 的<strong>控制寄存器</strong>, 同时也锁存 T0, T1 溢出中断源和外部请求中断源等.<br>TF1, IE1, IT1等, 控制<code>定时器 T1</code>;IE0, TF0, IT0等 控制<code>定时器 T0</code>.  </p>
<blockquote>
<p>TCON 可位寻址, 因此能单独操作 TCON 寄存器的各个位.</p>
</blockquote>
<p>TCON 格式如下:</p>
<table>
<thead>
<tr>
<th>SFR name</th>
<th>Address</th>
<th>bit</th>
<th>B7</th>
<th>B6</th>
</tr>
</thead>
<tbody><tr>
<td>TCON</td>
<td>88H</td>
<td>name</td>
<td>TF1</td>
<td>TR1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>B5</th>
<th>B4</th>
<th>B3</th>
<th>B2</th>
<th>B1</th>
<th>B0</th>
</tr>
</thead>
<tbody><tr>
<td>TF0</td>
<td>TR0</td>
<td>IE1</td>
<td>IT1</td>
<td>IE0</td>
<td>IT0</td>
</tr>
</tbody></table>
<ul>
<li>TF(Timer Flag): <code>定时器/计数器 </code> <strong>溢出标志</strong>. 当 <code>定时器</code> 的最高位高位产生溢出时, 会由硬件将 TF 置为 1 ,然后向 CPU 请求中断. 直到 CPU 响应 此中断后, 才由硬件将 TF1 复位为 0.</li>
<li>TR(Timer Run): <code>定时器/计数器 </code> 的<strong>运行控制位</strong>, 该位由软件置位和清零. 0 时停止计数, 1 时开始计数.</li>
<li>IE(Interrupt Enable): <code>定时器/计数器 </code> 的 <strong>中断使能位</strong>. IE1 &#x3D; 1 时外部中断向 CPU 请求中断, 当 CPU 响应该中断时, 由硬件清 0.</li>
<li>IT(Interrupt Type): <code>定时器/计数器 </code> 的 <strong>中断类型位</strong>. 0 时为边沿触发, 1 时为电平触发.</li>
</ul>
<h3 id="TMOD-定时器工作模式寄存器"><a href="#TMOD-定时器工作模式寄存器" class="headerlink" title="TMOD 定时器工作模式寄存器"></a>TMOD 定时器工作模式寄存器</h3><p>定时和计数功能由特<strong>殊功能寄存器</strong> TMOD(Timer Mode) , 控制着 C&#x2F;~T 进行选择.</p>
<blockquote>
<p>TMOD 不可位寻址, 只能整体赋值.</p>
</blockquote>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>GATE</td>
<td>C&#x2F;~T</td>
<td>M1</td>
<td>M0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>GATE</td>
<td>C&#x2F;~T</td>
<td>M1</td>
<td>M0</td>
</tr>
</tbody></table>
<p>其中, 0<del>3 是定时器0的工作模式, 4</del>7 是定时器1的工作模式.</p>
<p>可以看出, 两个定时器各有四种操作模式, 分别是:</p>
<table>
<thead>
<tr>
<th>位</th>
<th>符号</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>TMOD.7&#x2F;<br>TMOD.3&#x2F;</td>
<td>GATE</td>
<td>控制定时器 T1, 当 GATE&#x3D;1 , 需 INT1脚 为高 且 TR1&#x3D;1 时, 才可打开 定时器T1.<br>控制定时器 T0, 当 GATE&#x3D;1 , 需 INT0脚 为高 且 TR0&#x3D;1 时, 才可打开 定时器T0.</td>
</tr>
<tr>
<td>TMOD.6&#x2F;<br>TMOD.2&#x2F;</td>
<td>C&#x2F;~T</td>
<td>控制模式为 <strong>定时(&#x3D; 0)</strong> 还是 <strong>计数(&#x3D; 1)</strong>.</td>
</tr>
<tr>
<td>TMOD.5 &amp; TMOD.4</td>
<td>M1 &amp; M0</td>
<td>控制定时器 T1 的工作模式.</td>
</tr>
<tr>
<td>TMOD.1 &amp; TMOD.0</td>
<td>M1 &amp; M0</td>
<td>控制定时器 T0 的工作模式.</td>
</tr>
</tbody></table>
<p>M1, M0 共两位, 能用来选择定时器的工作模式.<br>具体的工作模式如下:</p>
<table>
<thead>
<tr>
<th>M1</th>
<th>M0</th>
<th>工作模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>模式0:<br>13位定时器&#x2F;计数器</td>
<td>兼容 8084 定时模式, TL只用低 5 位参与分频, TH1 整个 8 位全用.</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>模式1:<br>16位定时器&#x2F;计数器</td>
<td>TL,TH 整个 16 位全用.</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>模式2:<br>8位自动重装模式</td>
<td>当溢出时将 TH1 存放的值自动装入 TL1.</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>模式3:<br>无效</td>
<td>停止计数.</td>
</tr>
</tbody></table>
<h3 id="使用定时器实现-LED-闪烁"><a href="#使用定时器实现-LED-闪烁" class="headerlink" title="使用定时器实现 LED 闪烁"></a>使用定时器实现 LED 闪烁</h3><p>接下来实践一下, 用定时器实现每隔 <strong>一秒</strong> 闪烁一次 LED 灯.</p>
<p>已知 计时器最大只能为 65535 ,我们先让计时器计数 1000 次时就溢出, 也就是先计 1微秒.<br>将计时器的初值设置为 64535 即可.</p>
<p>然后将这个 1微秒 的计时器重复 1000 次, 就是一个一秒的计时器了.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Init</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 设置 TMOD定时器工作模式(不能寻址, 只能整体赋值)</span></span><br><span class="line">	TMOD = <span class="number">0x01</span>; <span class="comment">// 0000 0001 将模式设置为模式1, 使用整个TL0和TH0..</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置 TCON定时器控制寄存器(能寻址, 可以单独赋值)</span></span><br><span class="line">	TF0 = <span class="number">0</span>; </span><br><span class="line">	TR0 = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将 64535 赋值给定时器0, 先把64535分成高8位和低8位, 然后分别赋值给TH0和TL0.</span></span><br><span class="line">	TH0 = <span class="number">64535</span>/<span class="number">256</span>;</span><br><span class="line">	TL0 = <span class="number">64535</span>%<span class="number">256</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打开中断系统</span></span><br><span class="line">	ET0 = <span class="number">1</span>;</span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	PT0 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Timer0_Init; <span class="comment">// 启动配置好的定时器0</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> T0Counter = <span class="number">0</span>; <span class="comment">// 定义一个计算定时器执行了多少次的变量, 以让1毫秒的计时器重复1000次.</span></span><br><span class="line"><span class="comment">// 定时器0中断服务程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新校对计时器, 保证下一次计时也是 1毫秒</span></span><br><span class="line">    TH0 = <span class="number">64535</span>/<span class="number">256</span>;</span><br><span class="line">	TL0 = <span class="number">64535</span>%<span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    T0Counter++; </span><br><span class="line">    <span class="keyword">if</span> (T0Counter &gt;= <span class="number">1000</span>)&#123;</span><br><span class="line">        T0Counter = <span class="number">0</span>;</span><br><span class="line">        P2_0 = ~P2_0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="TMOD-缺陷"><a href="#TMOD-缺陷" class="headerlink" title="TMOD 缺陷"></a>TMOD 缺陷</h3><p>当需要使用两个定时器时, 又由于 TMOD 只能整体赋值, 所以当给其中一个定时器赋值时, 会对另一个定时器造成影响.  </p>
<p>因此, 我们这样修改代码:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旧代码: TMOD = 0x01; 0000 0001, 会影响 T1 的工作模式.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新思路: 只操作 T0 的工作模式.</span></span><br><span class="line">TMOD = TMOD &amp; <span class="number">0x0F</span>; <span class="comment">// 0000 1111 , 把 TMOD 低四位清零, 保留 T1 的工作模式.</span></span><br><span class="line">TMOD = TMOD | <span class="number">0x01</span>; <span class="comment">// 0000 0001 , 给 TMOD 低四位赋值, 使 T0 的工作模式为模式1.</span></span><br></pre></td></tr></table></figure></div>

<p>在数字电路中, 任何数 &amp; 1,都等于自身, 任何树 &amp; 0, 都等于 0.<br>利用这个特征, 我们可以只操作需要赋值的定时器.</p>
<p>让其只操作需要赋值的定时器即可.</p>
<p>在 STC-ISP 软件, 可以很方便地配置定时器: </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E8%87%AA%E5%8A%A8%E8%AE%A1%E7%AE%97%E5%AE%9A%E6%97%B6%E5%99%A8.png"
                      alt="alt text"
                ></p>
<ul>
<li>89C52 是没有 16位自动重载的. 只有 16位 或 8位自动重载.</li>
<li>定时器时钟选中 12T</li>
<li>生成的代码没有配置中断系统, 记得加上:</li>
<li>生成的代码针对新系列单片机, 会有 <code>AUXR</code> 寄存器, 但是我们在学习的单片机没有, 因此记得删除.</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">EA = <span class="number">1</span>; <span class="comment">// 打开总中断</span></span><br><span class="line">ET0 = <span class="number">1</span>; <span class="comment">// 打开定时器0中断</span></span><br><span class="line">PT0 = <span class="number">0</span>; <span class="comment">// 设置优先级为0</span></span><br></pre></td></tr></table></figure></div>

<h1 id="数码管"><a href="#数码管" class="headerlink" title="数码管"></a>数码管</h1><p>LED 数码管是一种简单, 廉价的显示器, 是由多个发光二极管封装在一起组成 “8” 自型的器件.</p>
<p>LED 连接方式有两种</p>
<ul>
<li>共阴极</li>
<li>共阳极</li>
</ul>
<p>也就只是一种连接方式而已, 了解即可.</p>
<p>想要使单个 数码管 显示数字, 根据其接线口, 可以很轻易推出显示数字的值.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%95%B0%E7%A0%81%E7%AE%A1.png"
                      alt="alt text"
                ></p>
<p>例如想要显示数字 1, 则将 b, c 赋值为1.<br>赋值时注意 高位是从 DP 开始. 例如 1 就该赋值为 0000 0110.</p>
<p>其他的数字同理:</p>
<table>
<thead>
<tr>
<th>显示数字</th>
<th>二进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0011 1111</td>
<td>0x3F</td>
</tr>
<tr>
<td>1</td>
<td>0000 0110</td>
<td>0x06</td>
</tr>
<tr>
<td>2</td>
<td>0101 1011</td>
<td>0x5B</td>
</tr>
<tr>
<td>3</td>
<td>0100 1111</td>
<td>0x4F</td>
</tr>
<tr>
<td>4</td>
<td>0110 0110</td>
<td>0x66</td>
</tr>
<tr>
<td>5</td>
<td>0110 1101</td>
<td>0x6D</td>
</tr>
<tr>
<td>6</td>
<td>0111 1101</td>
<td>0x7D</td>
</tr>
<tr>
<td>7</td>
<td>0000 0111</td>
<td>0x07</td>
</tr>
<tr>
<td>8</td>
<td>0111 1111</td>
<td>0x7F</td>
</tr>
<tr>
<td>9</td>
<td>0110 1111</td>
<td>0x6F</td>
</tr>
<tr>
<td>A</td>
<td>0111 1011</td>
<td>0x77</td>
</tr>
<tr>
<td>B</td>
<td>0111 1110</td>
<td>0x7C</td>
</tr>
<tr>
<td>C</td>
<td>0011 1001</td>
<td>0x39</td>
</tr>
<tr>
<td>D</td>
<td>0101 1110</td>
<td>0x5E</td>
</tr>
<tr>
<td>E</td>
<td>0111 1001</td>
<td>0x79</td>
</tr>
<tr>
<td>F</td>
<td>0111 1111</td>
<td>0x71</td>
</tr>
<tr>
<td>空</td>
<td>1111 1111</td>
<td>0x00</td>
</tr>
</tbody></table>
<p>四位一体数码管在单片机上接线如图所示:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/LED%E6%98%BE%E7%A4%BA%E5%99%A8%E6%8E%A5%E7%BA%BF.png"
                      alt="alt text"
                ></p>
<p>如图, 数码管的一端连接着 74HC254 , 能进行数据缓冲.  </p>
<p>由于高电平的驱动能力有限, 因此信号传输都用低电平完成. 但是直接用低电平点亮LED, 效果并不理想.<br>因此, 这个数据缓冲就是用来提高驱动能力的.<br>我们用低电平发送信号, 然后由这个数据缓冲器把信号提高到高电平来驱动 LED.</p>
<p>数码管的另一边接的就是 138 译码器, 是一种3线-8线译码器: </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/138%E8%AF%91%E7%A0%81%E5%99%A8.png"
                      alt="alt text"
                ></p>
<p>138 译码器 只用三个 IO 端(A&#x2F;P2_2, B&#x2F;P2_3, C&#x2F;P2_4) , 就可以控制八个输出端.</p>
<p>它的工作原理是:</p>
<table>
<thead>
<tr>
<th>A, B, C</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>0 (LED 8)</td>
</tr>
<tr>
<td>001</td>
<td>1 (LED 7)</td>
</tr>
<tr>
<td>010</td>
<td>2 (LED 6)</td>
</tr>
<tr>
<td>011</td>
<td>3 (LED 5)</td>
</tr>
<tr>
<td>100</td>
<td>4 (LED 4)</td>
</tr>
<tr>
<td>101</td>
<td>5 (LED 3)</td>
</tr>
<tr>
<td>110</td>
<td>6 (LED 2)</td>
</tr>
<tr>
<td>111</td>
<td>7 (LED 1)</td>
</tr>
</tbody></table>
<p>选中的输出端, 就会输出0.</p>
<h3 id="点亮一个-LED-数码管"><a href="#点亮一个-LED-数码管" class="headerlink" title="点亮一个 LED 数码管"></a>点亮一个 LED 数码管</h3><p>那么一个 LED 数码管, 究竟是怎么样被点亮的呢?</p>
<p>第一步就是通过 138 译码器, 通过这三个口, 使某一位输出为 0 ,选中要显示的LED.<br>接下来通过缓冲送来的信号, 驱动 LED 点亮.</p>
<p>例如, 点亮 LED6, 使其显示数字 6, :<br>代码实现:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 选中 LED6 -&gt; </span></span><br><span class="line">	P2_4=<span class="number">1</span>;</span><br><span class="line">	P2_3=<span class="number">0</span>;</span><br><span class="line">	P2_2=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设定显示的数字</span></span><br><span class="line">	P0=<span class="number">0x7D</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>设计一个数码管显示数字的函数:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设计一个数组存储每个数字对应的二进制数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> numToHex[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>,<span class="number">0x77</span>,<span class="number">0x7C</span>,<span class="number">0x39</span>,<span class="number">0x5E</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="comment">// 设定显示在哪一个数码管上, 以及要显示的数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location, num)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(Location)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">// 数码管8 -&gt; 000</span></span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: </span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: </span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: </span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    P0=numToHex[num]; <span class="comment">// 设定显示的数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="多位数码管动态显示"><a href="#多位数码管动态显示" class="headerlink" title="多位数码管动态显示"></a>多位数码管动态显示</h3><p>由于其设计, 数码管无法做到同时显示多个数字.<br>但是我们可以快速切换显示的数字, 只要切换的足够迅速, 利用人眼的视觉暂留效应, 就可以看到”同时”显示多个数字.</p>
<p>不过如果我们直接这样写</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用刚刚设计的函数 displayNum()</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        displayNum(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 在第一个数码管显示数字 1</span></span><br><span class="line">        displayNum(<span class="number">2</span>, <span class="number">2</span>); </span><br><span class="line">        displayNum(<span class="number">3</span>, <span class="number">3</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>会出现 数码管的残影:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%95%B0%E7%A0%81%E7%AE%A1%E6%AE%8B%E5%BD%B1.jpg"
                      alt="alt text"
                ></p>
<p>影响数字辨认.</p>
<p>这是由于数码管显示数字时, 会先选位选(选择要在哪个数码管上显示), 然后再段选(选择要显示的数字).  </p>
<blockquote>
<p>位选 –&gt; 段选 –&gt; 位选 –&gt; 段选 –&gt; …</p>
</blockquote>
<p>由于这个过程十分迅速, 就会导致数码管串位显示, 数字显示在了错误的位置上.</p>
<p>为了解决这个问题, 可以这样做: </p>
<blockquote>
<p>位选 –&gt; 段选 –&gt; 清零 –&gt; 位选 –&gt; 段选 –&gt; 清零 –&gt; …</p>
</blockquote>
<p>代码层面, 我们可以优化一下 displayNum() 函数:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> numToHex[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>,<span class="number">0x77</span>,<span class="number">0x7C</span>,<span class="number">0x39</span>,<span class="number">0x5E</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>		</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(xms)</span><br><span class="line">	&#123;</span><br><span class="line">	i = <span class="number">500</span>;</span><br><span class="line">	<span class="keyword">while</span> (--i);</span><br><span class="line">	xms--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location, num)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(Location)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: </span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: </span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: </span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    P0=numToHex[num]; </span><br><span class="line">	Delay(<span class="number">5</span>);</span><br><span class="line">    P0=numToHex[<span class="number">0</span>]; <span class="comment">// 清零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		displayNum(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		displayNum(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">		displayNum(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h3><p>众所周知, 程序员最不喜欢一直做重复的事. 像之前提到的 Delay(), 我们可以把它封装成一个函数, 然后在其他地方调用, 就不用每次都要写一遍.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B.png"
                      alt="alt text"
                ></p>
<h4 id="C预编译"><a href="#C预编译" class="headerlink" title="C预编译"></a>C预编译</h4><p>C语言的预编译以 # 开头, 作用是在珍珠的编译开始之前, 对代码做一些预处理(预编译)</p>
<table>
<thead>
<tr>
<th>预编译</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>#include</td>
<td>包含头文件</td>
</tr>
<tr>
<td>#define</td>
<td>定义常量</td>
</tr>
<tr>
<td>#ifndef</td>
<td>防止头文件重复包含</td>
</tr>
<tr>
<td>#endif</td>
<td>结束头文件包含</td>
</tr>
</tbody></table>
<p>接下来, 尝试一下将之前写的 Delay() 函数模块化.</p>
<p>首先创建工程, 完成一些基本操作:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span> <span class="comment">// &lt;&gt; 表示在安装目录寻找头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span> <span class="comment">// &quot;&quot; 表示在当前工程目录寻找头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Dlay(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后在工程目录下创建 delay.h 和 delay.c 文件:</p>
<p>delay.c 存放函数实现:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>		</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(xms)</span><br><span class="line">	&#123;</span><br><span class="line">	i = <span class="number">500</span>;</span><br><span class="line">	<span class="keyword">while</span> (--i);</span><br><span class="line">	xms--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>delay.h 存放函数声明:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__ <span class="comment">// 命名一般以这样的形式定义, 全大写, 下划线分隔.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__ <span class="comment">// 防止头文件重复包含,如果没有这个名字, 就创建.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure></div>

<h1 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h1>]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>单片机</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>远古卷轴</title>
    <url>/2024/04/16/%E9%A3%8E%E7%B5%AE%E8%8C%B8%E6%9D%82-%E6%94%B6%E9%9B%86/%E5%B0%8F%E8%AF%B4/%E8%BF%9C%E5%8F%A4%E5%8D%B7%E8%BD%B4/</url>
    <content><![CDATA[<h1 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h1><p>月光从树冠的獠牙间漏下来，在烟雨垂落的黑发上碎成细小的光斑。她单手拎着羊皮卷轴抖了抖：<br>「能看穿幻象的宝石，应该比你那火蜥蜴尾巴值钱些？」</p>
<p>一旁的狼人正蜷着后腿蹲坐在树根处，尾巴有一搭没一搭地拍打地面。他弓着脊背调试弓弦的姿态，总让人想到铁匠铺里歪斜的招牌。<br>「至少够赔尝上个月烧穿的旅店屋顶。。」</p>
<p>少女突然气愤地把卷轴怼到狼人鼻尖，陈旧的鞣制气味混着他皮毛间的松脂味扑面而来。狼人云的左耳猛地后折成投降的弧度，陈年羊皮的气味让他打了个喷嚏。<br>「那是谁非要叼着活火蜥蜴乱蹦的？」</p>
<p>狼人从喉咙里滚出委屈的呜咽，看样子是拒绝回答这个问题。</p>
<p>她不耐烦地抖了抖羊皮卷轴边缘<br>「还有这地图，你确定这鬼画符指的是东南方？」</p>
<p>「这可是用三张雪貂皮换的……」<br>「瘴气在东北角——大小姐，你地图拿反了。」</p>
<p>“”</p>
<p>为了寻找卷轴中所提到的那颗宝石, 一人一狼按照卷轴所指示的那样, 在这个满月之夜来到了迷雾森林.</p>
<p>「 就是这了, 云, 祭坛就在这迷雾深处. 」<br>少女对着身后的狼说道, 声音中带着一丝不易察觉的期待.<br>「 据卷轴记载, 掌管迷雾之力的宝石就在森林深处的祭坛之上. 」</p>
<p>「 听起来那宝石能值不少金币呢. 」<br>狼轻晃尾巴.<br>「没想到, 白天看起来平淡无奇的森林, 到了夜晚竟然是这个样子.」<br>「说起来这应该是我和烟雨头一次真正意义上的探险吧, 之前都只是接接冒险者工会的委托而已.」</p>
<p>「 哼, 就工会那点委托, 根本不足以让本小姐出汗的. 」</p>
<p>「 行了行了, 大小姐, 知道你很强了. 要是没有那些委托, 我俩早就流落街头了… 」<br>狼调侃道, 一边用指爪清点着箭袋中的羽毛箭矢.</p>
<p>「 流落街头吗… 」<br>少女眼中闪出一只落魄流浪狗的形象, 她想象着眼前这只狼那双原本锐利的野兽眼睛如今变得泛着水光. 可怜巴巴地缩在街边角落, 祈求着过往行人, 希望能得到一点点食物与怜悯.<br>而那只总是自信满满的狼兽人, 此刻只能低着失落的尾巴, 用湿漉漉的鼻头去嗅探着地上每一块面包屑.</p>
<p>「 哦, 一只落魄的流浪狗, 也不赖嘛! 」<br>少女嘴角上扬, 她知道这只会是一个幻想, 因为自打第一次见面, 她就决定与眼前这只狼患难与共了.</p>
<p>「 得了吧, 大小姐. 我可不会沦落到那种地步呢! 」<br>狼一脸苦笑着摇摇头.<br>挂好了箭袋, 随后他用长长的吻轻指面前的迷雾.</p>
<p>「 走吧. 」<br>少女回应到.</p>
<p>就这样, 少女与狼并肩踏入了迷雾之中, 踏上了寻找神秘宝石的冒险之旅, 他们的身影渐渐消失在迷雾中.</p>
<h1 id="PLOT-1"><a href="#PLOT-1" class="headerlink" title="PLOT 1"></a>PLOT 1</h1><p>随着少女烟雨和狼兽人云的脚步深入迷雾森林, 周围的景色越发朦胧, 仿佛整个世界都被一层轻纱所笼罩.<br>月光透过树梢, 洒在蜿蜒的道路上, 为他们指引着方向.<br>两人的心跳在这寂静的夜晚中回响, 伴随着他们前进的脚步, 一种难以言喻的紧张感在空气中弥漫开来.</p>
<p>两人走过一片灌木丛生的地带, 对于经验丰富的冒险者来说, 这里的每一个阴影都可能隐藏着危险.<br>烟雨和云都深知这一点.</p>
<p>就在这时, 一只史莱姆悄无声息地从灌木丛中现身.</p>
<p>少女只需与狼一个对视, 无需多言.</p>
<p>一记准确狼爪挥击, 甚至不需动用弓箭.</p>
<p>然而, 预料之外的是史莱姆并没有像往常那样一招毙命.<br>不过少女长刀在手, 她的身影快速优雅. 银色月华倾洒, 长刀如同划破夜空的流星，一闪即逝.<br>史莱姆利落地溶解在地面上, 轻烟归于迷雾, 只留下地面上闪着微光的粘液.</p>
<p>「 真是轻松. 」<br>暂时解除了危险, 她的身体放松, 倚靠在一旁长满苔藓的岩石上, 长发如墨般流淌.</p>
<p>「 月光强化了它们, 要多加小心了. 」<br>狼舔了舔爪子, 敏锐地辨别出了处境的异样.<br>随即他从背包中掏出小瓶子, 俯下身, 小心翼翼地将那特别的史莱姆粘液收集起来.<br>「 不过这貌似是特别的怪物素材, 要是卖给素材商的话, 不知道这能比一般的凝胶贵多少金币呢? 」<br>狼自言自语道.</p>
<p>「 月又提到金币了啊. 」<br>少女看着云, 心中难免感到不解.</p>
<p>烟雨从小与师傅在深山中长大, 习惯了自力更生的生活, 金币对她来说可有可无.<br>她也明白金币的价值.<br>毕竟自从她独自一人后, 少女也学着与他人交易和收集情报.</p>
<p>在她的认知中, 狼多以凶残狡诈描述, 很难与他们将 「贸易」 这个词相关联.<br>真的不会吓跑交易对象吗?</p>
<p>少女随意的目光落在狼身上, 那只专心致志地收集着粘液的狼.</p>
<p>这只来自寒冷北方的灰狼兽人, 励志成为一只能独当一面的吟游诗人而远飘到这里, 因此远离了自己的族群.<br>虽说在族群中他只是一只年轻的狼崽, 但要论体型, 还是比少女略大一些.</p>
<p>在烟雨看来, 云不过是一只看上去还算不太好惹的狗狗罢了. 对了, 还会自己打理自己的狗.<br>他那灰白的毛发在满月下泛着银色的光泽, 尾巴随意摆动, 看上去稍微有点高兴的样子.</p>
<p>看来 「 人不可貌相 」 确实有道理.<br>或者说, 「 <strong>狼</strong> 」不可貌相?<br>烟雨心中暗想.</p>
<p>此时, 少女心生一计, 目光似笑非笑地盯着狼.<br>随后轻手轻脚地走向云, 尽可能地不发出任何声响.<br>她的手悄无声息地接近云的尾巴, 然后突然一把抓住.</p>
<p>云先是吃惊, 然后猛地一跳, 本能地想摆脱束缚, 手中的瓶子也因此翻倒在地.<br>恶作剧得逞的少女嘴角勾起一抹得意的弧度, 肩膀因偷笑轻轻颤抖着.</p>
<p>「 你知道吗? 你的尾巴真的很好抓! 」<br>她的声音轻快而充满戏虐.</p>
<p>得知是中了烟雨的计谋后, 狼嘴里发出低沉的抗议声.<br>「 放开我, 粘液全撒啦! 」<br>狼不满地吼道.</p>
<p>少女却毫无征兆地松手, 失去重心的灰狼一头扑倒在地.<br>「 这可真是’狼’狈啊, 骸云. 」<br>她走向倒地的灰狼身边, 如往常那般, 戏虐灰狼.</p>
<p>灰狼抱怨着低吼, 明显是不满少女刚刚的举措.<br>重获自由的狼要给少女一个教训, 立刻转身扑向少女.</p>
<p>而少女根本扛不住扑面而来的狼, 跌倒在泥土与草地中, 但她一点也不介意, 反手揉搓着面前这只灰狼的毛茸茸的脸.<br>粗糙的皮毛下隐藏着温暖, 野兽的眼中全是对少女不满.</p>
<p>尽管迷雾森林中仍然涌动着危险, 两人依旧打闹着.<br>不久, 两人收拾好心情, 向着迷雾的深处继续前行.</p>
<h1 id="PLOT-2"><a href="#PLOT-2" class="headerlink" title="PLOT 2"></a>PLOT 2</h1><p>深入迷雾的心脏地带, 烟雨和云的步伐变得更加谨慎.<br>森林深处的小径崎岖不平, 树木的轮廓在月光下若隐若现. 一人一狼小心地穿行在迷雾与灌木中, 树叶在夜风中沙沙作响.</p>
<p>烟雨感受着每一丝风的变化, 她黑色的长发随风飘动, 如同夜色中的流苏. 云的耳朵不时转动, 金黄的眼在黑暗中闪烁着狼的光芒.<br>随着他们深入, 魔物的威胁也愈来棘手.<br>好在烟雨还有余力应付战斗, 她的身姿灵活, 手中的长刀在月光下闪烁着寒光. 云也默契地配合着少女的战斗, 不时使用弓箭辅佑着少女.</p>
<p>经过一番跋涉, 他们最终顺利地来到了远古卷轴所指示的地点 ———— 一个由古老石碑围成的圆形空地.<br>祭坛中的每个石碑刻满了复杂的纹路, 结构古老而庄严.<br>而在中央的石质台座上, 正是迷雾森林所隐藏的宝石, 宝石散发出充满魔力的光辉, 周围空气扭曲着, 显然是一块拥有强大力量的宝石.</p>
<p>「 看! 烟雨, 那块宝石就是我们的战利品了! 」<br>云兴奋地说道, 他手脚并用, 迫不及待地奔向那诱人的宝物.</p>
<p>「 小心, 没那么简单! 」 烟雨警觉地观察四周, 周围的空气湿润而寒冷, 她注意到一股不详的气流从背后袭来.<br>只见一只幽灵狼蓄势待发, 它的眼睛是两团蓝色的火焰, 透露着饥渴和狡猾.</p>
<p>烟雨紧握长刀, 她敏锐的直觉告诉自己, 眼前这只生物并不如之前在迷雾中所遇到的那样简单, 不过现在也无退路可言, 只能走一步看一步了.</p>
<p>「 看来你的亲戚来迎接我们了! 」 危急时刻, 少女都不忘调侃一下狼.</p>
<p>「 哼, 我与这种野蛮的家伙可没什么关系! 」<br>狼紧拉弓弦, 发出低沉的咆哮, 蓄势待发.</p>
<p>「 那么, 有教养的狼先生, 我们能尝试和它沟通吗? 」 烟雨戏谑地问道.</p>
<p>幽灵狼四肢紧贴地面, 肌肉紧绷. 意识到自身行动已经败露, 便发出一声愤怒的咆哮, 向两人扑来.</p>
<p>看来「谈判」破裂了, 战斗一触即发.</p>
<p>幽灵狼的攻击迅猛无比, 云的箭矢很难在迷雾中击中目标. 烟雨不甘示弱, 少女的身影月下穿梭, 她的长刀与幽灵狼的爪牙交错.<br>刀锋一次次触及幽灵狼的身体, 少女的长刀虽然准确锋利, 但对这些半实体的生物来说, 似乎只能造成暂时的伤害.</p>
<p>「 挥砍对它毫无作用! 」 烟雨心中一紧.</p>
<p>狼吹奏长笛, 悦耳的笛声冲破迷雾, 淡蓝色的微光包裹了烟雨的长刀, 为烟雨的攻击附加魔力.<br>「 那试试这样呢! 」</p>
<p>少女将剑舞动, 剑间划过幽灵狼. 瞬时, 一道光芒烙印留在了幽灵狼的腰部, 使其发出痛苦的嚎叫.<br>「 起作用了! 」</p>
<p>少女接着发动一系列攻击, 节节败退的幽灵狼向后撤步, 随之对着月亮发出嚎叫.<br>「 不好! 它这是在召集同伴! 烟雨, 快阻止它! 」 云很清楚, 他明白这声嚎叫的意义.<br>少女迅速的一击挥砍, 将嚎叫的幽灵狼斩断, 使其归于迷雾之中.</p>
<p>「 结束了. 」<br>两人喘息着.</p>
<h1 id="PLOT-3"><a href="#PLOT-3" class="headerlink" title="PLOT 3"></a>PLOT 3</h1><p>「 … 」</p>
<p>结束了…吗?<br>由黑暗所编织的幻影生物如同梦魇般涌现, 它们那双可怖的眼在迷雾中散发出的邪恶蓝色火光.</p>
<p>狼压低身体, 后颈毛发悚立, 耳朵后撇, 发出低吼声警告着危险.<br>「 更多的幽灵来了! 」</p>
<p>一道黑影快速接近少女, 没有丝毫犹豫地, 长刀破空的呼啸声伴随着锐利的笛声, 淡蓝的弧光, 暗影散化迷雾, 融入森林中.</p>
<p>「 现身吧! 」<br>她的声音回荡在森林之中, 紧接着暗影生物如同潮水般汹涌而至, 长刀少女的眼神中没有丝毫恐惧.<br>「 放马过来吧! 无论你们有多少, 我永远不会退缩! 」<br>她挥舞着长刀, 干净利落, 刀光如银蛇般划过, 准备将暗影生物一一斩断.</p>
<p>一人一狼并肩站立, 准备迎接即将到来的挑战.</p>
<p>「 … 」</p>
<p>战斗持续了一段时间, 激烈的程度超出了烟雨和云的预期.<br>幽灵狼的数量似乎无穷无尽, 烟雨可以感觉到长刀上来自云的魔力正在逐渐减弱, 自己的额头上也布满了汗珠, 每一次呼吸都变得沉重.<br>她后退了几步, 将长刀插入地面.</p>
<p>「 这样僵持下去, 不是办法… 」<br>少女咬紧牙关, 如果不能找到突破口, 两人也许会沦陷于此.</p>
<p>刚准备再次迎战的少女, 忽然注意到手中长刀的异样.</p>
<p>长刀认出了迷雾, 刀刃映照着雾气, 闪烁着淡淡的月光.<br>「 这是… 」<br>烟雨心中涌起一股莫名的感觉, 仿佛长刀本身就是迷雾的一部分, 与这片森林息息相关.</p>
<p>迷雾如同有生命一般, 开始涌动, 缭绕在少女周围, 然后猛地冲向少女.</p>
<p>少女的意识被某种强大的力量吞噬, 身体失去了平衡, 摇摇欲坠.</p>
<p>「 烟雨! 」<br>云的呼喊划破了夜空, 他动作比思考的要快, 迅速冲上前去, 烟雨稳稳地落入狼的双臂中.</p>
<p>「 你怎么了! 」<br>云焦急询问少女情况, 但少女没有回应. 他的心中涌起一股前所未有的恐慌.<br>狼知道, 单凭自己根本敌不过这群暗影生物.</p>
<p>冷静, 冷静…<br>云深吸一口气, 试图平复自己急促的呼吸.<br>在这危急时刻, 他的心中涌现出一丝决绝, 开始念动咒语.<br>现在能做的就只有拖延时间.</p>
<p><strong>「 银月之光, 汇聚于此 – Luminous Veil 光之护盾术! 」</strong></p>
<p>稀薄的魔力开始聚集, 一道光明结界将两人包裹.</p>
<p>幽灵狼先是感受到威胁, 它们开始围绕结界, 警惕地在寻找突破的方式.<br>当第一只领头幽灵狼开始攻击结界时, 其他的幽灵狼也纷纷加入攻击.</p>
<p>光芒结界裂开些微缝隙.</p>
<p>这样下去撑不了多久! 只能使出那一招了, 狼心想, 将少女平稳地放在地上.<br>又做了几次深呼吸, 狼的眼神变得专注, 唇边轻启, 吹响长笛.<br>随着笛声的响起, 魔力汇聚速度加快, 但幽灵狼随之也发起了愈加猛烈的攻击.</p>
<p>「 烟雨! 快醒醒! 」<br>云焦急地呼唤着烟雨.<br>「 可恶, 现在可不是开玩笑的时候! 」</p>
<h1 id="PLOT-4"><a href="#PLOT-4" class="headerlink" title="PLOT 4"></a>PLOT 4</h1><p>「 … 」</p>
<p>「 这是… 」</p>
<p>这是年幼的烟雨.<br>树木茂密, 这里是少女最久远的那部分记忆.<br>年幼的她身处同样的森林, 同样的夜晚. 迷雾依旧不散, 她很难过, 踌躇不安.</p>
<p>一阵悠扬的笛声在记忆的森林中逐渐清晰, 烟雨便顺着那引导的旋律, 一步步走向前.</p>
<p>「 真美… 」</p>
<p>随着笛声越来越清晰，那些久远的回忆也逐渐清晰…</p>
<p>这片森林是烟雨曾经被遗弃的森林, 是谁将她遗弃? 为何将她遗弃?<br>少女唯一明白的就是仍深深烙印在她的心中的那份痛苦和绝望.</p>
<p>「 … 」</p>
<p>千钧一发之际, 烟雨的手指微微动了动, 她的意识开始逐渐回归.</p>
<p>回过神来, 眼前是奋力施展结界抵抗敌人的灰狼.<br>狼的力量即将耗尽, 步伐沉重. 但他依旧弓起身体, 试图让自己看起来更加庞大, 强装着威慑.</p>
<p>抬手间, 长刀便回归少女手中, 新的力量在长刀中涌动.</p>
<p>「 你.. 烟雨, 你没事吧. 」 狼已经接近极限.</p>
<p>「 没事了, 已经没事了… 」</p>
<p>少女望着眼前数不尽的敌人, 只是轻蔑地一笑, 她已迫不及待地想尝试自己的新力量了.<br>她感觉到了手中长刀的变化, 那把名为「静寂之风」的武器似乎与这片迷雾森林产生了某种神秘的联系, 它渴望着释放出自己的力量.</p>
<p>就在这时, 光芒结界终究还是支撑不住幽灵狼的猛烈攻击, 一声清脆的碎裂声.<br>云的魔力枯竭, 陷入昏迷状态.</p>
<p>「 吾之长剑, 天命所归, 此刻, 就让我烟雨来终结这片混沌! 」</p>
<h1 id="FINAL"><a href="#FINAL" class="headerlink" title="FINAL"></a>FINAL</h1><p>少女站起身来, 身姿优美而凌厉, 步伐稳健, 灵活而迅猛.<br>击破结界的幽灵狼一拥而上, 她没有丝毫的畏惧. 长刀如同划破夜空的流星, 每一次挥舞都带着风与月光的印记, 将一只又一只的幽灵狼斩于刀下.</p>
<p>直奔少女喉咙的利齿, 被她侧身一闪, 顺势劈中其后颈, 风烙印于伤口上, 一击致命;<br>另一只妄图近身扑咬, 但少女敏锐转身, 一记横劈, 将它的身体从头到尾切成两半, 不留一丝让其复原的机会.</p>
<p>一只又一只的幽灵狼哀嚎着倒地, 烟雨似乎还没尽兴.<br>最后一只幽灵狼嘶吼着扑来, 但少女不退反进.</p>
<p>「 哼, 真是自不量力. 」</p>
<p>她将长刀直插入幽灵狼的胸膛, 光芒贯穿幽灵狼的身体, 随着其发出最后的嘶吼, 最后一只幽灵狼也归于烟尘.</p>
<p>「 结束了! 」<br>少女伸伸懒腰, 长刀归鞘, 将祭坛上失去光泽的蓝色宝石放入背包中.<br>「 话说, 迷雾宝石怎么看着跟一般宝石没区别呢? 」</p>
<p>看来, 宝石之能, 已悄然潜入长刀深处, 如宿命之轨轻启, 静待时光之轮缓缓旋转.</p>
<p>黑暗中的恶灵被击退, 森林的迷雾也随之退散. 满月西沉, 树木的轮廓渐渐清晰, 草地上的露珠闪烁, 如同坠到地上的星晨.</p>
<p>少女双手靠近刚刚搭建起的简易篝火, 稍事休息.<br>她望向一旁熟睡的狼, 心中一丝慰藉.<br>狼静静地蜷缩着, 他的呼吸平稳规律, 伴随着胸腔轻轻的起伏.</p>
<p>「 真是辛苦你了, 好好休息吧, 好梦. 」<br>烟雨轻轻地凑近骸云的耳边.<br>「 我的狼. 」</p>
<p>篝火舒缓的噼啪声在夜空中回荡, 空气中弥漫着令人安心的泥土芬芳和木烟燃烧.<br>黎明即将到来, 东方的天空渐渐泛起一丝淡淡的红色, 夜晚的黑暗渐渐被驱散.</p>
<pre class="mermaid">stateDiagram-v2
    [*] --> 未参加
    未参加 --> 已报名 : 提交报名
    已报名 --> 训练中 : 开始训练
    训练中 --> 请假中 : 申请请假
    请假中 --> 训练中 : 结束请假
    训练中 --> 受伤暂停 : 受伤报告
    受伤暂停 --> 训练中 : 恢复训练
    训练中 --> 已完成 : 完成训练
    已完成 --> [*]</pre>]]></content>
      <categories>
        <category>风絮茸杂-收集</category>
        <category>小说</category>
      </categories>
      <tags>
        <tag>烟雨与云</tag>
        <tag>原创角色</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础语法</title>
    <url>/2024/03/30/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Java-简介"><a href="#Java-简介" class="headerlink" title="Java 简介"></a>Java 简介</h1><p><strong>Java 是一门面向对象编程语言, 其特点是:</strong></p>
<p>面向对象三大特征: <strong>封装</strong> <strong>继承</strong> <strong>多态</strong><br>面向对象基本概念: <strong>类</strong> <strong>对象</strong> <strong>方法</strong> <strong>属性</strong></p>
<blockquote>
<p>常说的 Java 三大版本是:<br><strong>Java SE(Standard Edition)</strong> 标准版, 面向桌面应用的开发环境.<br><strong>Java EE(Enterprise Edition)</strong> 企业版, 面向企业级应用的开发环境.<br><strong>Java ME(Micro Edition)</strong> 微型版, 面向移动终端的开发环境.</p>
</blockquote>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>开发 Java 程序必须先安装好 JDK, JDK 其中也包含了常见的开发工具, 以及 JRE</p>
<ul>
<li>JDK(Java Development Kit): 开发工具包, 包含开发环境, 编译器, 类库, 工具等.</li>
<li>JRE(Java Runtime Environment): 运行环境, 包含 Java 虚拟机(JVM), 类库, 工具等.</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241221131919122.jpg"
                     
                ></p>
<p>在选择版本时, 选择官方指定的长期支持版 LTS 版本(Long Term Support)</p>
<p><a class="link"   href="https://www.oracle.com/cn/java/technologies/downloads/#java21" >官方下载地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h3><p>集成开发环境(Intergrated Development Environment) IDE, 是集成了代码编写功能、分析功能、编译功能、调试功能等一体化集成环境的开发软件.</p>
<p>目前 Java 开发最知名, 最常用的 IDE 就是 Jetbrain 公司出品的<a class="link"   href="https://www.jetbrains.com/idea/" >Intellij IDEA<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>了.</p>
<p><a class="link"   href="https://www.jetbrains.com/idea/download/" >IntelliJ IDEA 下载<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://3.jetbra.in/" >IntelliJ IDEA 激活<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>IDEA 中有很多快捷键可以提高我们的开发效率，常见的有：</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>CTRL + D</td>
<td>复制一行</td>
</tr>
<tr>
<td>CTRL + Y</td>
<td>删除当前行</td>
</tr>
<tr>
<td>CTRL + ALT + L</td>
<td>格式化代码风格</td>
</tr>
<tr>
<td>ALT + SHIFT + ↑，ALT + SHIFT+ ↓</td>
<td>上下移动当前代码</td>
</tr>
<tr>
<td>CTRL + &#x2F;，CTRL + SHIFT + &#x2F;</td>
<td>注释选中的代码</td>
</tr>
</tbody></table>
<h3 id="Java-程序结构"><a href="#Java-程序结构" class="headerlink" title="Java 程序结构"></a>Java 程序结构</h3><p>Java 程序通常由以下几部分组成：</p>
<ul>
<li>方法（Method）: 程序<strong>最基本的功能单位</strong>, 例如计算器上的 ‘+’ 就包含一个求和的<strong>方法</strong>.</li>
<li>类（Class）: 功能相关联的<strong>方法</strong>放在一起, 就是一个 <strong>类</strong>.</li>
<li>包（Package）: 将<strong>类</strong>按照功能模块划分到一个个<strong>不同目录</strong>中, 这些目录称为<strong>包</strong>.</li>
<li>项目&#x2F;工程（Project）: 最后再把所有的<strong>包</strong>放到一个目录中管理，整个目录称之为<strong>项目</strong>或<strong>工程</strong>.</li>
</ul>
<p>特别注意程序的入口, main 方法.<br>程序启动后都会去执行 main 方法, 然后再通过 main 方法调用其它方法.</p>
<p>因此：任何程序都必须写一个<strong>main</strong>方法，而且 main 方法的写法是固定的：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="Java-程序运行原理"><a href="#Java-程序运行原理" class="headerlink" title="Java 程序运行原理"></a>Java 程序运行原理</h1><p>作为程序员编写的, 是由很多英文单词和符号组成的源代码, 是方便人类读写的.<br>计算机目前无法直接理解这种语言, 它只能识别简单的指令.</p>
<p>Java 的解决方式是将 程序员写好的 .java 文件, 使用编译器转换为 .class 文件, 让虚拟机 JVM 转换为机器码以可在计算机上运行.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241221145002966.jpg"
                     
                ></p>
<p>这种提前准备好的指令集, 一旦编译完成, 就可以在没有编译器的帮助下独立运行的语言类型, 我们称之为:</p>
<p><strong>编译型语言</strong></p>
<p>由于 Java 虚拟机的存在, Java 语言可以很轻易地运行在任意平台上.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241221145639854.jpg"
                     
                ></p>
<p>在 CMD 中, 使用</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">javac java文件.java</span><br></pre></td></tr></table></figure></div>

<p>编译 .java 文件<br>接着使用:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java java文件</span><br></pre></td></tr></table></figure></div>

<p>将刚刚编译后生成的 .class 文件运行<br>这就是不使用集成开发环境手动编译和运行的过程.</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>用于在源代码中解释代码, 不会被执行.</p>
<p>写注释是一个好习惯, 不然刚写完的代码只有自己和上帝能, 过几天就只剩上帝能看得懂了…<br>注释有三种写法:</p>
<ol>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一行单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	而这个就是多行注释,</span></span><br><span class="line"><span class="comment">	只要在这两个符号内的文字都会被认定为注释</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这就是文档注释</span></span><br><span class="line"><span class="comment"> * 它可以用在类, 方法, 字段上 来解释其作用</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div>

<p>在 idea 中<br>快捷键 <code>ctrl</code>+<code>/</code> 可以快速单行注释选中的代码.<br>快捷键 <code>ctrl</code>+<code>shift</code>+<code>/</code> 可以快速多行注释.</p>
<h1 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h1><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>指向内存中的一片区域, 可以被读写, 修改.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个变量 数据类型 变量名 = 数据字面量;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>

<p>由于不同的数据类型所需的空间大小不一样的, 又由于 Java 是一种<strong>强类型语言</strong>,<br>强类型语言为了精确地分配变量在内存中的空间大小, 在使用变量前需要先定义它们的类型.<br>变量按数据类型可分为:</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>与变量类似, 都是指向内存中的一片空间, 能够被读取.<br>不同的是, 常量中的数据不可以被改变.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个常量 final 数据类型 变量名 = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 为了区分, 常量一般全大写</span></span><br></pre></td></tr></table></figure></div>

<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul>
<li>标识符: 自己定义的用来命名 变量, 方法, 类 等的字符.</li>
</ul>
<blockquote>
<p>由字母, 数字, 下划线 <code>_</code> 或美元符号 <code>$</code> 组成.<br>不能以 数字 开头, 必须以字母, 下划线 或 美元符号开头.<br>标识符不能与关键字或保留字相同.</p>
</blockquote>
<ul>
<li>关键字: 被 Java 语言赋予特殊含义的单词, 不能作为标识符.</li>
<li>保留字: 现在还未被 Java 语言使用, 但以后版本的 Java 语言可能会使用.</li>
</ul>
<h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p>为了遵循这些规则, 会有一套建议的标识符规范, 如下:</p>
<ul>
<li>包名: 全部小写, 单词之间用点分隔.</li>
<li>类, 接口名: 首字母大写, 驼峰命名法.</li>
<li>方法, 变量名: 首字母小写, 驼峰命名法.</li>
<li>常量名: 全部大写, 下划线连接.</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型:"></a>基本数据类型:</h3><ul>
<li>整数类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>$-128$ 到 $127$</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>$-2^{15}$ 到 $2^{15}-1$</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>$-2^{31}$ 到 $2^{31}-1$</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>$-2^{63}$ 到 $2^{63}-1$</td>
</tr>
</tbody></table>
<p>整数类型默认为 int, 如果要声明一个 long 类型的整数,<br>需要在值的末尾加上 <code>L</code> 注明其是 long 类型.</p>
<ul>
<li>浮点类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>取值范围</th>
<th>精度</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4</td>
<td>$3.4 \times 10^{-38}$ 到 $3.4 \times 10^{38}$</td>
<td>7 位</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>$2.2 \times 10^{-308}$ 到 $2.2 \times 10^{308}$</td>
<td>15 位</td>
</tr>
</tbody></table>
<p>浮点类型默认是 double, 同理声明 float 类型时需加上 <code>F</code></p>
<ul>
<li>布尔类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1</td>
<td>true 或 false</td>
</tr>
</tbody></table>
<ul>
<li>字符类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>2</td>
<td>$0$ 到 $65535$</td>
</tr>
</tbody></table>
<p>字符类型声明赋值时, 值需要 <code>&#39; &#39;</code> (单引号) 包裹.</p>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>不是以上基本数据类型的, 都称作引用数据类型.</p>
<ul>
<li>String 类</li>
</ul>
<p><code>String</code> 不是一个基本类型.是一个真正的类 但是 java 语言对这个类有些特殊处理</p>
<p><code>String</code> 可用 null 赋值.<br><code>String</code> 类是典型的不可变类.</p>
<blockquote>
<p>容量小的数据类型在计算时会自动转换为容量大的类型.<br>byte, short, char 之间不能转换, 他们三者在计算时会自动转换为 int.</p>
</blockquote>
<p>Java 在处理 <code>字符串</code> 和 <code>基本类型</code> 时, + 号有特殊处理(方法的重载), 例如拼接字符串等.</p>
<h1 id="从键盘录入"><a href="#从键盘录入" class="headerlink" title="从键盘录入"></a>从键盘录入</h1><p>从键盘录入分为三步:</p>
<h4 id="1-导入-Scanner-类"><a href="#1-导入-Scanner-类" class="headerlink" title="1. 导入 Scanner 类"></a>1. 导入 Scanner 类</h4><p>在 Java 标准库中, 已经实现了从键盘录入的方法.<br>在 IDEA 等高级开发工具中, 当需要这个包时, 开发工具会自动添加这一行:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-创建-Scanner-对象"><a href="#2-创建-Scanner-对象" class="headerlink" title="2.创建 Scanner 对象"></a>2.创建 Scanner 对象</h4><p>创建这个对象才能使用:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure></div>

<p>后面会详细介绍对象相关.<br>这里括号内的 <code>System.in</code> 是指使用<code>System.in</code>作为输入源.</p>
<p>创建好对象后, 就可在此类中多次使用这个对象.</p>
<h4 id="3-读取不同类型的数据"><a href="#3-读取不同类型的数据" class="headerlink" title="3.读取不同类型的数据"></a>3.读取不同类型的数据</h4><p>Scanner 类中有多种方法来读取不同类型的数据:</p>
<ul>
<li><code>nextInt()</code>: 读取下一个整数</li>
<li><code>nextDouble()</code>: 读取下一个双精度浮点数</li>
<li><code>nextLine()</code>: 读取输入行的剩余部分, 包括空格</li>
</ul>
<p>例如, 如果你想读取一个整数，可以这样做:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> scanner.nextInt();</span><br></pre></td></tr></table></figure></div>

<p>注意, 当需要录入 <code>char</code> 类型时, Scanner 中并没有 <code>.nextchar( )</code> 这个方法.<br>直接:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> scanner.next();</span><br></pre></td></tr></table></figure></div>

<p>不录入 <code>char</code> 而是转为 <code>String</code> 类型 , 效果上是一样的.</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>加减乘除</td>
<td><code>+</code> <code>-</code> <code>*</code> <code>/</code></td>
<td>基本的四则运算符</td>
</tr>
<tr>
<td>取模</td>
<td><code>%</code></td>
<td>两数相除的的余数, 舍去整数部分.</td>
</tr>
<tr>
<td>自增</td>
<td><code>++</code></td>
<td>变量加 1<br>自增在前时先加 1, 再赋值.<br>自增在后时先赋值, 再加 1.</td>
</tr>
<tr>
<td>自减</td>
<td><code>--</code></td>
<td>变量减 1, 与自增同理.</td>
</tr>
</tbody></table>
<blockquote>
<p>注意:<br>除法运算 <code>/</code> 在计算 <code>int</code> 类型时, 结果也会是 <code>int</code> , 会保留整数部分, 舍去余数,<br>其与取模是对立的.<br>如果想要精确的计算, 可以用 <code>double</code> 类型进行除法运算.</p>
</blockquote>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>赋值</td>
<td><code>=</code></td>
<td>简单的赋值运算符</td>
</tr>
<tr>
<td>四则赋值(包括取余)</td>
<td><code>*=</code>, <code>/=</code>, <code>%=</code>, <code>+=</code>, <code>-=</code></td>
<td>先计算右操作数, 再赋值</td>
</tr>
</tbody></table>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>等于</td>
<td><code>==</code></td>
<td>判断两边是否相等</td>
</tr>
<tr>
<td>不等于</td>
<td><code>!=</code></td>
<td>判断两边是否不等</td>
</tr>
<tr>
<td>大于<br>小于</td>
<td><code>&gt;</code> <code>&lt;</code></td>
<td>判断左边是否大于右边<br>判断左边是否小于右边</td>
</tr>
<tr>
<td>大于等于<br>小于等于</td>
<td><code>&gt;=</code> <code>&lt;=</code></td>
<td>判断左边是否大于等于右边<br>判断左边是否小于等于右边</td>
</tr>
</tbody></table>
<p>关系运算符<strong>不能直接</strong>比较 引用数据类型 (如字符串)<br>字符串比较, 需使用 <code>.equals()</code> . 面向对象部分会详细说明.</p>
<blockquote>
<p>关系运算符的结果是 <code>boolean</code> 类型.</p>
</blockquote>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑与</td>
<td>&amp;</td>
<td>两边都为 true, 结果为 true</td>
</tr>
<tr>
<td>逻辑或</td>
<td>|</td>
<td>两边有一个为 true, 结果为 true</td>
</tr>
<tr>
<td>逻辑非</td>
<td>!</td>
<td>取反, 若操作数为 true, 结果为 false, 若操作数为 false, 结果为 true</td>
</tr>
<tr>
<td>逻辑异或</td>
<td>^</td>
<td>两边结果相同 (都为 true 或都为 false), 结果为 true</td>
</tr>
</tbody></table>
<blockquote>
<p>逻辑运算符的结果也是 boolean 类型.</p>
</blockquote>
<p>逻辑运算符还有两个更为智能的符号, 会在满足必定条件后, 忽略不必要的操作.<br>在实际开发中优先使用.</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>短路与</td>
<td>&amp;&amp;</td>
<td>左边为 false ,右边则不执行判断.</td>
</tr>
<tr>
<td>短路或</td>
<td>||</td>
<td>左边为 true, 右边则不执行判断.</td>
</tr>
</tbody></table>
<h3 id="位运算符-了解"><a href="#位运算符-了解" class="headerlink" title="位运算符(了解)"></a>位运算符(了解)</h3><p>在编程中使用较少, 但在底层有用.</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>按位与</td>
<td><code>&amp;</code></td>
<td>两个操作数的对应位都为 1, 结果为 1</td>
<td></td>
</tr>
<tr>
<td>按位或</td>
<td>&#96;</td>
<td>&#96;</td>
<td>两个操作数的对应位有一个为 1, 结果为 1</td>
</tr>
<tr>
<td>按位异或</td>
<td><code>^</code></td>
<td>两个操作数的对应位不同时为 1, 结果为 1</td>
<td></td>
</tr>
<tr>
<td>按位取反</td>
<td><code>~</code></td>
<td>反转操作数的每一位, 即 0 变 1, 1 变 0</td>
<td></td>
</tr>
<tr>
<td>左移</td>
<td><code>&lt;&lt;</code></td>
<td>按位左移, 左操作数的各二进位全部左移若干位, 右操作数指定了移动的位数</td>
<td></td>
</tr>
<tr>
<td>右移</td>
<td><code>&gt;&gt;</code></td>
<td>按位右移, 左操作数的各二进位全部右移若干位, 右操作数指定了移动的位数</td>
<td></td>
</tr>
<tr>
<td>无符号右移</td>
<td><code>&gt;&gt;&gt;</code></td>
<td>逻辑右移, 左操作数的各二进位全部右移若干位, 右操作数指定了移动的位数, 移动后高位丢弃, 低位补 0</td>
<td></td>
</tr>
</tbody></table>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p><strong>只能</strong>由数值<strong>范围小</strong>的类型转换赋值给数值<strong>范围大</strong>的类型, 反之不行.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>Java 的算数运算中, 参与运算的数据都会被子的类型转换为运算中最大的数据类型.</p>
<p>例如:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + <span class="number">200</span>;</span><br></pre></td></tr></table></figure></div>

<p>由于 200 是 <code>int</code> 类型, 因此 x 会被自动转换为 <code>int</code> 类型进行计算.</p>

    </div>
  </div>

<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>使用<strong>圆括号</strong> <code>()</code> 规定类型, 能将一种数据类型强制转换为另一种数据类型.<br>在内存中, 强制转换会舍弃高位, 只保留低位.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">byte</span>) x;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在赋值运算符中, 存在一种强制转换:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a += <span class="number">5</span>; <span class="comment">// a = (byte)(a + 5)</span></span><br></pre></td></tr></table></figure></div>

<p>一定要注意此类情况, 比较难以察觉.</p>

    </div>
  </div>

<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">    执行代码</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">    执行代码</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当需要在条件判断下执行的代码只有一行时, 可以省略大括号.<br>需要执行多行时, 不可省略大括号, 在其他控制语句中同样适用.</p>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>当 if-else 的执行代码是<strong>赋值表达式</strong>(直接将结果赋值给变量的语句)时, 可以使用三目运算符代替.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (判断条件) ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>当条件表达式为 <code>True</code> 执行 表达式 1, 否则执行 表达式 2.</p>
<h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h4><p>当 if-else 的判断分支较多, 而且判断条件都是比较值是否相等, 就可以用 switch 代替.<br>switch 只会将表达式的值比较一次, 相比于 if-else 效率更高.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        执行代码<span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        执行代码<span class="number">2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        执行代码<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>switch-case 存在一种简化写法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (level)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span> -&gt; 执行代码<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span> -&gt; 执行代码<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span> -&gt; 执行代码<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">default</span> -&gt; 执行代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当两种条件所需执行的代码逻辑相同时, 可以合并 case;</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        执行代码<span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">        执行代码<span class="number">2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        执行代码<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简化写法( JDK11 后):</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">0</span> -&gt; 执行代码<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span>, 值<span class="number">2</span> -&gt; 执行代码<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">default</span> -&gt; 执行代码<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>JDK 17 后, switch 可以直接返回结果</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">goal</span> <span class="operator">=</span> <span class="keyword">switch</span> (bodyType) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;值0&quot;</span> -&gt; <span class="string">&quot;结果1&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;值1&quot;</span>, <span class="string">&quot;值2&quot;</span> -&gt; <span class="string">&quot;结果2&quot;</span>;</span><br><span class="line">	<span class="keyword">default</span> -&gt; <span class="string">&quot;结果3&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 迭代) &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure></div>

<p>Java 中提供了 break 和 continue 关键字来控制循环的执行.</p>
<ul>
<li>break: 跳出循环</li>
<li>continue: 跳过本次循环</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>是程序中最基本的功能单位, 是用来实现功能的代码块, 一个程序往往有很多方法组成.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明方法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cleanMemory</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> voud <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="comment">// 调用有返回值的方法</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用无返回值方法</span></span><br><span class="line">	clearMemory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>选中一个方法, IDEA 会自动抽取方法, 选中后快捷键为 <code>Ctrl</code> + <code>Alt</code> + <code>M</code></p>
<p>全部大写: <code>Ctrl</code> + <code>Shift</code> + <code>U</code></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一种存储多个相同类型元素的集合, 数组的声明格式如下:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure></div>

<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>for 循环与 while 循环 功能类似, 但语法更加简洁, 紧凑, 更适合用来遍历数据:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="number">0.</span>初始化变量; <span class="number">1.</span>循环判断条件; <span class="number">2.</span>更新变量)&#123;</span><br><span class="line">	<span class="number">3.</span>执行方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i arr.length; i++)&#123;</span><br><span class="line">	System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组: 如果一个数组的元素类型是一维数组, 那么这个数组就是二维数组.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = &#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>访问时也与一维类似:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">// 索引为0的数组内, 索引为0的数 -&gt; 1</span></span><br><span class="line">arr[<span class="number">1</span>][<span class="number">1</span>]; <span class="comment">// 索引为1的数组内, 索引为1的数 -&gt; 4</span></span><br></pre></td></tr></table></figure></div>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>当一个方法的参数类型确定, 但是参数个数不确定时, 可以使用可变参数:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">返回值 方法名(数据类型 ... 参数名)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例如实现一个任意数求和的方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> ... nums)</span>&#123;</span><br><span class="line">具体方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> add();</span><br><span class="line"><span class="comment">// 可以传入任意数量的参数</span></span><br><span class="line">sum = add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">sum = add(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure></div>

<p>可变参数本质时一个数组, 可以用数组的方式来获取可变参数中的每一个值.</p>

  <div class="note p-4 mb-4 rounded-small red icon-padding">
    <i class="note-icon fa-solid fa-bolt"></i><p>可变参数永远只能放在最后. </p>

  </div>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门-面向对象</title>
    <url>/2024/12/25/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java%E5%85%A5%E9%97%A8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类: 用来描述一类事物的模板.<br>对象: 根据类这个模板创建的具体实例.</p>
<ul>
<li>类中的变量叫成员变量, 表示事物的属性</li>
<li>类中的方法叫成员方法, 表示事物的行为</li>
</ul>
<h3 id="类的语法格式"><a href="#类的语法格式" class="headerlink" title="类的语法格式"></a>类的语法格式</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名 &#123;</span><br><span class="line">    <span class="comment">// 属性声明 (属性, 成员变量, 不用初始化)</span></span><br><span class="line">    数据类型 变量名;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法声明 (行为, 方法 也叫函数)</span></span><br><span class="line">    <span class="keyword">public</span> 数据类型 方法名(参数列表) &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>有了 类 这个模板后, 我们就能实例化出具体的对象了.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用对象的方法</span></span><br><span class="line">对象名.方法名(参数列表);</span><br></pre></td></tr></table></figure></div>

<p>定义的变量会存储在 <strong>栈</strong> 中, 创建的对象会存储在 <strong>堆</strong> 中.</p>
<ul>
<li>局部变量一般存在栈里, 存取快.</li>
<li>对象实例存在堆里, 堆地方大.</li>
<li>对象引用存在栈里, 方便快速找到对象实例.</li>
</ul>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>封装(Encapsulation)是面向对象的核心特点之一, 要求将数据和操作这些数据的方法捆绑在一起, 作为一个整体.</p>
<p>例如, 以下是一个 <strong>过程式编程</strong> 案例, 求最终工资:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalaryDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="comment">//底薪</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">baseSalary</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">	<span class="comment">//奖金</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">bonus</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">	<span class="comment">//绩效等级</span></span><br><span class="line">	<span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span><span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算薪资</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">salary</span> <span class="operator">=</span> calculateSalary(baseSalary，bonus， grade);</span><br><span class="line">	System.out.println(salary);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateSalary</span><span class="params">(<span class="type">int</span> baseSalary，<span class="type">int</span> bonus，<span class="type">char</span> grade）&#123;</span></span><br><span class="line"><span class="params">	<span class="type">double</span> rate = <span class="keyword">switch</span> (grade）&#123;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> -&gt; <span class="number">1.0</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span> -&gt; <span class="number">0.8</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span> -&gt; <span class="number">0.6</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> -&gt; <span class="number">0.4</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">default</span> -&gt;<span class="number">0</span>;</span></span><br><span class="line"><span class="params">	&#125;;</span></span><br><span class="line"><span class="params">	return baseSalary +(<span class="type">int</span>)</span><span class="params">(bonus * rate)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中, 底薪 奖金 绩效等级 就是 数据; 计算薪资 就是 方法.</p>
<p>使用面向对象编程, 将其封装:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义员工模板, 不用赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">	<span class="type">int</span> baseSalary;</span><br><span class="line">	<span class="type">int</span> bonus;</span><br><span class="line">	<span class="comment">// grade 不固定, 不在此处定义</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">calculateSalary</span><span class="params">(<span class="type">char</span> grade）&#123;</span></span><br><span class="line"><span class="params">	// 计算奖金系数</span></span><br><span class="line"><span class="params">	<span class="type">double</span> rate = <span class="keyword">switch</span> (grade）&#123;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> -&gt; <span class="number">1.0</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span> -&gt; <span class="number">0.8</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span> -&gt; <span class="number">0.6</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> -&gt; <span class="number">0.4</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">default</span> -&gt;<span class="number">0</span>;</span></span><br><span class="line"><span class="params">	&#125;;</span></span><br><span class="line"><span class="params">	// 计算薪资</span></span><br><span class="line"><span class="params">	return baseSalary +(<span class="type">int</span>)</span><span class="params">(bonus * rate)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样, 一个员工类就定义好了, 接下来使用它:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="comment">// 使用模板</span></span><br><span class="line">	<span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">	<span class="comment">// 为属性赋值</span></span><br><span class="line">	employee.baseSalary = <span class="number">5000</span>;</span><br><span class="line">	employee.bonus = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用类中计算薪资的方法</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">salary</span> <span class="operator">=</span> employee.calculateSalary( grade: <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">	System.out.println(salary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small default">
    <p>对选中的元素快速定义变量以接收结果: <code>alt</code> + <code>enter</code></p>

  </div>

<h3 id="Getter-and-Setter"><a href="#Getter-and-Setter" class="headerlink" title="Getter and Setter"></a>Getter and Setter</h3><p>为了避免给属性赋错误的值, 我们还需要在类中定义校验方法.</p>
<p>在刚刚封装的类中添加方法</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBaseSalary</span><span class="params">(<span class="type">int</span> baseSalary)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(校验条件)&#123;</span><br><span class="line">		不符合值的处理方法</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 符合的值, 将当前的值赋给类的属性.</span></span><br><span class="line">	<span class="built_in">this</span>.baseSalary = baseSalary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>this</code>. 是为了区分 当前对象 和 方法参数,<br><code>this.baseSalary = baseSalary;</code><br>其含义就是将此方法的参数值赋给当前类</p>
<p>不过此时我们仍然能用老办法 <code>employee.baseSalary = 5000;</code> 的方式赋值,<br>为了只让外部通过 <code>.setBaseSalary</code> , 需要在类的属性添加 <code>private</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> baseSalary;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> bonus;</span><br></pre></td></tr></table></figure></div>

<p>private 限制其只在类的内部使用, 而禁止外部调用.</p>
<p>同理地, 为了安全地获取值, 可以再定义一个 <code>.getBaseSalary</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBaseSalary</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> baseSalary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通常, 在做封装时.<br>成员变量 做 <strong>私有化</strong>, 禁止对外访问.<br>同时, 对外提供 <strong>set 和 get 方法</strong>, 使其能正常获取和赋值.</p>
<p>这些对外提供的方法, 称之为 Getter 和 Setter .<br>他们的作用为:<br>能够设置校验, 避免给属性赋错误的值.</p>
<h3 id="降低耦合"><a href="#降低耦合" class="headerlink" title="降低耦合"></a>降低耦合</h3><p>耦合是指事物之间存在相互依赖, 相互影响, 相互制约的情况.<br>在程序设计中是指一个类依赖另一个类的程度.</p>
<p>类与类之间相互协作, 一些耦合是无法避免的.<br>不重要的方法可以使用 <code>private</code> 修饰, 以减少耦合的可能性.</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>()</span><br></pre></td></tr></table></figure></div>

<p>调用了<strong>构造方法</strong>, 是由 JVM 自动生成的方法, 会自动为成员变量赋初值, 初值类型由数据类型决定.</p>
<p>自定义构造方法, 让其带参数:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> baseSalary, <span class="type">int</span> bonus)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.baseSalary = baseSalary;</span><br><span class="line">	<span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造方法特点:</span></span><br><span class="line"><span class="comment"> *  1.没有返回值</span></span><br><span class="line"><span class="comment"> *  2.方法名与类名完全一致</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div>

<p>为了安全调用成员变量, 我们可以使用写好的 Getter 和 Setter:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> baseSalary, <span class="type">int</span> bonus)</span>&#123;</span><br><span class="line">	setBaseSalary(BaseSalary);</span><br><span class="line">	setBouns(bonus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样, 我们就能更进一步降低耦合, 只将自定义后的构造方法暴露.</p>
<p>当自定义了有参的构造方法, 无参构造就会消失, 可根据实际要求选择是否需要手动定义.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>封装是面向对象的三大特征之一(封装 继承 多态), 简单来说就是:<br>将数据和操作数据的方法放到一起.</p>
<p>封装降低了耦合, 提高程序的可维护性和可复用性.</p>
<h4 id="如何实现封装"><a href="#如何实现封装" class="headerlink" title="如何实现封装"></a>如何实现封装</h4><ul>
<li>将数据和操作数据的方法放到一个类中, 作为类的<strong>成员变量</strong>和<strong>成员方法</strong>.</li>
<li>成员变量私有化, 对外提供 Getter 和 Setter 方法操作成员变量.</li>
<li>对于必须初始化的变量, 以构造方法来接收参数完成初始化.</li>
<li>使用 Private 隐藏不必要的细节, 只对外暴露必要的方法.</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在程序设计中, 继承是指让一个类继承另一个类的成员, 从而提高代码的复用性.<br>被继承的类叫父类, 继承的类就是子类.</p>
<p>例如, 商品分为实体商品和虚拟商品.</p>
<p>它们都属于商品, 都会有 商品名称 商品价格<br>而实体商品又独特拥有 重量;<br>虚拟商品又独特拥有 卡密.</p>
<p>定义一个父类:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类 Produce</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">displayInfo</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;商品名称：&quot;</span> + name + <span class="string">&quot;，商品价格：&quot;</span> + price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 空参构造</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Product</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>extends</code> 定义子类, 只用声明特有的属性行为:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类 PhysicalProduct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhysicalProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">double</span> weight)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>Java 中一切类都直接或者间接地继承了 Object 类.</p>
<h3 id="调用父类构造"><a href="#调用父类构造" class="headerlink" title="调用父类构造"></a>调用父类构造</h3><p>由于共性成员变量(名称&#x2F;价格)在父类中都是私有的, 无法直接在子类中操作.<br>如何让子类的构造和父类的构造相互协作, 共同完成初始化?</p>
<p>使用关键字 <code>super</code> 可访问当前类的父类.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>(); <span class="comment">// 调用当前父类的构造方法</span></span><br><span class="line"><span class="comment">// ()中没有参数, 调用的是空参构造</span></span><br></pre></td></tr></table></figure></div>

<p>这句代码 JVM 默认会自动生成.</p>
<p>因此, 当我们 <code>new PhysicalProduct()</code> 子类对象时, 会首先执行这句自动生成的代码.<br>结果就是调用了父类构造 <code>Product()</code> 的空参构造.</p>
<p>只要通过 super() 传递参数, 再由父类的有参构造接收参数即可:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类 Produce</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">displayInfo</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;商品名称：&quot;</span> + name + <span class="string">&quot;，商品价格：&quot;</span> + price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有参构造</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(String name, <span class="type">double</span> price)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.price = price;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类 PhysicalProduct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhysicalProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">double</span> weight)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有参构造</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">PhysicalProduct</span><span class="params">(String name, <span class="type">double</span> price, <span class="type">double</span> weight)</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>(name, price); <span class="comment">// 调用父类的有参构造, 对父类的成员变量初始化</span></span><br><span class="line">	<span class="built_in">this</span>.weight = wegiht; <span class="comment">// 对自己的成员变量赋值</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>这时只需要调用子类的构造方法即可让子类的构造和父类的构造相互协作, 共同完成初始化:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">Demo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">PhysicalProduct</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhysicalProduct</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意, 一旦使用有参构造, 默认的空参构造会被覆盖, 默认调用的 <code>super();</code> 找不到空参构造会报错.<br>因此 <code>super(name, price);</code> 是不可少的.</p>
<h3 id="方法的覆写"><a href="#方法的覆写" class="headerlink" title="方法的覆写"></a>方法的覆写</h3><p>覆写（override）也叫重写, 是指子类定义了一个与父类中<strong>声明完全相同</strong>, 但实现不同的方法.<br>子类的实现就覆盖了父类的实现.</p>
<p>例如, 之前商品的例子中, 父类的 <code>displayInfo()</code> 只展示了商品的共性(名称&#x2F;价格).<br>要展示子类独特的成员变量显然是不够的.</p>
<p>重写的方法应在开头加入 <code>@Override</code> 标记, 此标记会自动检测重写是否正确.<br>在子类中覆写 <code>displayInfo()</code> 方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">displayInfo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">super</span>.displayInfo() + <span class="string">&quot;,商品重量&quot;</span> + weight + <span class="string">&quot;g&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>super</code> 关键字调用父类的方法, 然后再拼接额外的信息.</p>
<blockquote>
<p>IDEA 覆写快捷键: <code>Ctrl</code> + <code>O</code></p>
</blockquote>
<p>当不希望方法被重写\类被继承, 添加 <code>final</code> 关键字:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br></pre></td></tr></table></figure></div>

<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>权限修饰符 (AccessModifier) 用来修饰类和类的成员, 它约束了类的成员的可访问范围.</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>作用于本类</th>
<th>相同包下的类</th>
<th>子类</th>
<th>其他类</th>
</tr>
</thead>
<tbody><tr>
<td><code>private</code></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>default(默认)</code></td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>protected</code></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td><code>public</code></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态 (Polymorphism) 就是事物具有多种不同形态, 或者同一行为, 具有多种不同表现.</p>
<p>设计一个创建订单的方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PhysicalProduct</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhysicalProduct</span>(<span class="string">&quot;手机&quot;</span>,<span class="number">1999</span>,<span class="number">672</span>);</span><br><span class="line"><span class="type">DigitalProduct</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DigitalProduct</span>(<span class="string">&quot;充值卡&quot;</span>,<span class="number">99.9</span>,<span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类型变量指向子类型的对象, JVM会隐式类型转换, 向上将子类型转换为父类型</span></span><br><span class="line">createOrder(p);</span><br><span class="line">createOrder(d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(Product product)</span>&#123;</span><br><span class="line">	<span class="comment">// 向上转型只能调用父类方法</span></span><br><span class="line">	System.out.println(product.displayInfo())</span><br><span class="line">	System.out.println(<span class="string">&quot;订单已确定&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一般不会使用向下转型, 了解即可:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(Product product)</span>&#123;</span><br><span class="line">	<span class="comment">// 向下转型必须判断类型</span></span><br><span class="line">	<span class="keyword">if</span> (product <span class="keyword">instanceof</span> PhysicalProduct)&#123;</span><br><span class="line">		<span class="type">PhysicalProduct</span> <span class="variable">p</span> <span class="operator">=</span> (PhysicalProduct) product;</span><br><span class="line">		p.setWeight(<span class="number">586.00</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(product.displayInfo())</span><br><span class="line">	System.out.println(<span class="string">&quot;订单已确定&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象 (Abstract) 是与具体相对应的概念, 代表事物中共性的但不确定的特征.</p>
<p>例如实体商品和虚拟商品, 它们都应有一个发货的行为, 但不确定行为的具体表现.<br>实体商品通过邮寄发货, 虚拟商品通过发送卡密信息发货.</p>
<p>“发货”这个方法, 就可以称之为 抽象方法.<br>定义抽象方法的类, 就是抽象类.</p>
<p>在父类 Product 使用 <code>abstract</code> 关键字, 定义 抽象方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sendProduct</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<p>抽象方法必须定义在抽象类中, 被抽象的类无法再用 new 方法实例化</p>
<p>在实体商品和虚拟商品中添加定义发货的方法:</p>
<ul>
<li>实体商品</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendProduct</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;通过物流发货&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>虚拟商品</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendProduct</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;通过网络发货&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>新建测试类:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="type">PhysicalProduct</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhysicalProduct</span>(<span class="string">&quot;华为Mate70&quot;</span>, <span class="number">7299.00</span>, <span class="number">672.00</span>) ;</span><br><span class="line">	<span class="type">DigitalProduct</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DigitalProduct</span>(<span class="string">&quot;Appstore 充值卡&quot;</span>, <span class="number">99.9</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用数组存储多个</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendProducts</span><span class="params">(Product[] products)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; products.length; i++) &#123;</span><br><span class="line">			<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> products[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>IDEA 中 输入 <code>需要遍历的变量名称.fori</code> 回车, 即可自动生成 for 循环.</p>
<h1 id="static-静态"><a href="#static-静态" class="headerlink" title="static 静态"></a>static 静态</h1><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>静态变量就是类中用 static 关键字修饰的变量, 静态变量是属于类的变量, 可以理解为一类事物的共享属性.</p>
<ul>
<li>静态变量随着类首次使用而加载，并且完成初始化</li>
<li>使用静态变量无需创建对象，可以直接使用<code>类名.变量名</code>访问</li>
</ul>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>静态方法就是类中用 static 关键字修饰的方法, 静态方法是属于类的方法.</p>
<ul>
<li>静态方法无需创建对象, 直接用<code>类名.方法名</code>调用.</li>
<li>静态方法中不能直接访问非静态成员（变量和方法）, 只能访问静态成员.</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 静态方法不能使用 this 关键字</span></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><p>静态的实际用途是用来做工具类.</p>
<p>工具类是用来封装某一非业务领域内一些通用的公共方法的类.<br>由于这些方法不需要用到实例变量, 仅仅是作为工具方法使用, 因此通常都是静态的.</p>
<p>例如, 一个角度转弧度的方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathUtil</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">STRAIGHT_ANGLR</span> <span class="operator">=</span> <span class="number">180</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">toRadians</span> <span class="params">(<span class="type">double</span> degrees)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> degrees * <span class="number">3.14</span> / <span class="number">180</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h3><p>静态工厂方法就是在类中提供一个用来创建对象的静态方法来代替构造方法.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span>() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 提供一个用来创建对象的静态方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		ruturn <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为什么要这样多此一举呢?<br>先来几个案例:</p>
<h4 id="简化开发"><a href="#简化开发" class="headerlink" title="简化开发"></a>简化开发</h4><p>例如, 定义一个代表程序运行结果的类 Result, 具备以下属性:</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>int</td>
<td>结果状态码: <br>0 成功, 1 失败</td>
</tr>
<tr>
<td>msg</td>
<td>String</td>
<td>结果描述: <br>ok 表示成功, 失败描述失败原因</td>
</tr>
<tr>
<td>data</td>
<td>Object</td>
<td>运行成功返回的结果数据</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">	<span class="keyword">private</span> String msg;</span><br><span class="line">	<span class="comment">// 使用 Object 顶级父类,以此来接收任意类型</span></span><br><span class="line">	<span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(<span class="type">int</span> code, String msg, Object data)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.code = code;</span><br><span class="line">		<span class="built_in">this</span>.msg  = msg;</span><br><span class="line">		<span class="built_in">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略了Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>假设通过 id 查询学生信息, 有 查询成功(有返回结果) 和失败 两种情况,<br>通过 id 删除学生信息, 有 删除成功(无返回结果) 和 失败 两种情况.<br>如果不使用静态工厂方法:</p>
<ul>
<li>成功,有返回结果:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, <span class="string">&quot;OK&quot;</span>, student)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>成功, 无返回结果:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, <span class="string">&quot;Ok&quot;</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>失败, 返回错误信息, 无返回结果:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>, <span class="string">&quot;id不能小于0&quot;</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// null 代表是空, 通常是指一个引用类型数据不存在</span></span><br></pre></td></tr></table></figure></div>

<p>每一次需要此对象时, 都必须如此声明.<br>虽然编译不报错, 但可以使用 静态工厂方法 来进一步简化.</p>
<p>在 Reslut 类中定义 静态工厂方法.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功,有返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, <span class="string">&quot;OK&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功, 无返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ok(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fail</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>, msg, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在测试类中调用定义的方法:</p>
<ul>
<li>成功,有返回结果:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Result.ok(student);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>成功, 无返回结果:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, <span class="string">&quot;Ok&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>失败, 返回错误信息, 无返回结果:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Result.fail(<span class="string">&quot;id不能小于0&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>增强了可读性和可维护性</p>
<h4 id="避免重复创建对象"><a href="#避免重复创建对象" class="headerlink" title="避免重复创建对象"></a>避免重复创建对象</h4><p>有这样一个需求:<br>定义一个表示性别的类 Gender, 包含以下属性.</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>int</td>
<td>性别标识:<br>0 代表男, 1 代表女</td>
</tr>
<tr>
<td>lable</td>
<td>String</td>
<td>性别标签:<br>男, 女</td>
</tr>
</tbody></table>
<p>首先定义一个传统的 Gender 类.<br>包含 属性, 有参构造和 Getter Setter.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Gender</span><span class="params">(<span class="type">int</span> value String label)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">		<span class="built_in">this</span>.label = label;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getLabel</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> label;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLabel</span><span class="params">(String label)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.label = label;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用这个传统的 Gender 类, 会遇到如下问题:</p>
<ul>
<li>能重复创建对象, 导致空间浪费.</li>
<li>创建对象无限制, 会出现意料之外的错误(创建了两种以上的性别标签).</li>
<li>数字与标识的关联不强(每次用 if 判断来识别标签).</li>
</ul>
<p>为了避免这些问题, 可以这样修改:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.构造方法私有化, 禁止在外部随意创建对象, 只能通过内部的工厂方法创建</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Gender</span><span class="params">(<span class="type">int</span> value String label)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">		<span class="built_in">this</span>.label = label;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3.使用常量预先构造好对象, 避免重复创建</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Gender</span> <span class="variable">MALE</span> <span class="operator">=</span> Gender(<span class="number">0</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Gender</span> <span class="variable">FEMALE</span> <span class="operator">=</span> Gender(<span class="number">2</span>, <span class="string">&quot;女&quot;</span>)</span><br><span class="line">	<span class="comment">// 2.使用工厂方法规定创建的对象类型</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Gender <span class="title function_">male</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MALE</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Gender <span class="title function_">female</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FEMALE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.根据值得到当前类对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Gender <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(value != <span class="number">0</span> &amp;&amp; != <span class="number">1</span> )</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;性别参数不合法.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getLabel</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> label;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLabel</span><span class="params">(String label)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.label = label;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="创建不同子类"><a href="#创建不同子类" class="headerlink" title="创建不同子类"></a>创建不同子类</h4><p>在父类中定义创建子类的方法.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> PhysicalProduct <span class="title function_">createPhysicalProduct</span><span class="params">(String name, <span class="type">double</span> price, <span class="type">double</span> weight)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PhysicalProduct</span>(name, price, weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样定义所有的子类方法后,</p>
<blockquote>
<p>快捷键:<br>快速生成变量 <code>Alt</code> + <code>Enter</code><br>在变量后输入 <code>.var</code> 回车, 也是同样的效果.</p>
</blockquote>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块就是用大括号括起来, 独立于方法之外的代码片段</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CodeBlock</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;无参构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;普通方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//代码块</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>静态代码块在类的加载时执行, 用于处理静态成员变量.<br>构造代码块在每次构造方法加载时执行, 用于处理普通的成员变量.</p>
<p>运行以下代码:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span>&#123;</span><br><span class="line"><span class="comment">// 1.类加载和初始化的顺序</span></span><br><span class="line"><span class="comment">// 1.1 静态成员变量的初始化</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	<span class="comment">// 2.对象创建的流程</span></span><br><span class="line">	<span class="comment">// 2.1 普通成员变量初始化</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="comment">// 2.3 构造方法初始化</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CodeBlock</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">		System.out.println(<span class="string">&quot;无参构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;普通方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2.2 构造代码块初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;num2的初始值:&quot;</span> + num2);</span><br><span class="line">		num2 = <span class="number">20</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 1.2 静态代码块执行, 只在类加载后初始化时执行一次</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;num的初始值:&quot;</span> + num);</span><br><span class="line">	num++;</span><br><span class="line">		System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + CodeBlock.num);</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + CodeBlock.num);</span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">        <span class="type">CodeBlock</span> <span class="variable">cb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeBlock</span>();</span><br><span class="line">        cb1.func();</span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">        <span class="type">CodeBlock</span> <span class="variable">cb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeBlock</span>();</span><br><span class="line">        cb2.func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>所得结果:</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">num的初始值:100</span><br><span class="line">静态代码块</span><br><span class="line">num = 101</span><br><span class="line">num = 101</span><br><span class="line">======================</span><br><span class="line">num2的初始值:10</span><br><span class="line">构造代码块</span><br><span class="line">num2 = 20</span><br><span class="line">无参构造方法</span><br><span class="line">普通方法</span><br><span class="line">======================</span><br><span class="line">num2的初始值:10</span><br><span class="line">构造代码块</span><br><span class="line">num2 = 20</span><br><span class="line">无参构造方法</span><br><span class="line">普通方法</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></div>

<pre class="mermaid">graph TD
    A(类加载) --> B[静态成员变量初始化]
    B --> C[静态代码块执行]
    C --> D(类初始化完成)

    E(对象创建) --> F[普通成员变量初始化]
    F --> G[构造代码块执行]
    G --> H[构造方法执行]
    H --> I(对象创建完成)</pre>

<h4 id="静态代码块案例"><a href="#静态代码块案例" class="headerlink" title="静态代码块案例"></a>静态代码块案例</h4><p>需求: 定义一个表示交通信号灯的类 TrafficLight, 包含下列属性:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrafficLight</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">private</span>  TrafficLight nextLight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TrafficLight</span><span class="params">(String label)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TrafficLight RED;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TrafficLight YELLOW;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TrafficLight GREEN;</span><br><span class="line">	<span class="comment">// 使用静态代码块初始化</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">	    RED = <span class="keyword">new</span> <span class="title class_">TrafficLight</span>(<span class="string">&quot;红&quot;</span>);</span><br><span class="line">	    YELLOW = <span class="keyword">new</span> <span class="title class_">TrafficLight</span>(<span class="string">&quot;黄&quot;</span>);</span><br><span class="line">	    GREEN = <span class="keyword">new</span> <span class="title class_">TrafficLight</span>(<span class="string">&quot;绿&quot;</span>);</span><br><span class="line">	    RED.nextLight = YELLOW;</span><br><span class="line">	    YELLOW.nextLight = GREEN;</span><br><span class="line">	    GREEN.nextLight = YELLOW;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLabel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> label;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TrafficLight <span class="title function_">getNextLight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextLight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(TrafficLight.GREEN.getLabel()+<span class="string">&quot;灯下一个灯是&quot;</span>+TrafficLight.GREEN.getNextLight().getLabel()+<span class="string">&quot;灯&quot;</span>);</span><br><span class="line">    System.out.println(TrafficLight.YELLOW.getLabel()+<span class="string">&quot;灯下一个灯是&quot;</span>+TrafficLight.YELLOW.getNextLight().getLabel()+<span class="string">&quot;灯&quot;</span>);</span><br><span class="line">    System.out.println(TrafficLight.RED.getLabel()+<span class="string">&quot;灯下一个灯是&quot;</span>+TrafficLight.RED.getNextLight().getLabel()+<span class="string">&quot;灯&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">绿灯下一个灯是黄灯</span><br><span class="line">黄灯下一个灯是绿灯</span><br><span class="line">红灯下一个灯是黄灯</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></div>

<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>前面提到过耦合, 耦合是指不同模块 (如类、方法等) 之间相互依赖的程度.<br>为了减少耦合, 尽可能隐藏类中的细节.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/file-20250125131236947.jpg"
                     
                ></p>
<p>不过这种方式终究还是无法避免耦合,<br>接口为此而生.</p>
<p>接口 <strong>(Interface)</strong> 是一种类似于 class 的类型,但是只定义方法的声明, 不定义具体实现.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rollable</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> roll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例如制作饺子皮, 一般都使用擀面杖来制作.<br>不过非得要擀面杖来制作吗?</p>
<p>擀饺子皮，重在不在于用什么’工具’，重点在于’擀’.<br>‘擀’就是接口中的方法，擀面杖、火腿肠、苹果，都是’擀‘的实现类.</p>
<p>这样擀面杖与制作饺子皮就解除耦合了.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/file-20250125131737164.jpg"
                     
                ></p>
<p>接口只定义需要什么样的行为, 具体实现由其他类来实现.<br>接口解除类与类的耦合, 提高代码的拓展性.</p>
<p>新建一个接口:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Coupon</span>&#123;</span><br><span class="line">	<span class="comment">// 接口默认为 public abstract, 可以省略</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">calculateDiscount</span><span class="params">(<span class="type">double</span> totalPrice)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实现这个接口:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriceDiscountCoupon</span> <span class="keyword">implements</span> <span class="title class_">Coupon</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> threshold;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> discount;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">PriceDiscountCoupon</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> discount)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">		<span class="built_in">this</span>.discount = discount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span> <span class="comment">// 加上此注解以便于更好地排查错误</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateDiscount</span><span class="params">(<span class="type">double</span> totalPrice)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> totalPrice &gt;= threshold ? discount : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用接口:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Product product;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> amout;</span><br><span class="line">	<span class="comment">// 使用接口</span></span><br><span class="line">	<span class="keyword">private</span> Coupon coupon;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(Product product, <span class="type">int</span> amount, <span class="type">int</span> amount, <span class="type">int</span> threshold, <span class="type">int</span> discount)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.product = product;</span><br><span class="line">		<span class="built_in">this</span>.amount = amount;</span><br><span class="line">		<span class="comment">// 仍然存在耦合</span></span><br><span class="line">		<span class="built_in">this</span>.coupon = <span class="keyword">new</span> <span class="title class_">PriceDiscountCoupon</span>(threshold, discount);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showOrderInfo</span><span class="params">()</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入(Dependency Injection) 是一种软件设计模式, 它要求类不再创建他所依赖的对象,而是由其他类提供并注入这些依赖项.</p>
<p>依赖注入常见方式:</p>
<h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接接收优惠券对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(Product product, <span class="type">int</span> amount, <span class="type">int</span> amount, Coupon coupon)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.product = product;</span><br><span class="line">		<span class="built_in">this</span>.amount = amount;</span><br><span class="line">		<span class="built_in">this</span>.coupon = coupon;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用者注入对象:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">void</span> main(String[] args)&#123;</span><br><span class="line">	<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> Product.createPhysicalProduct( name:<span class="string">&quot;华为Mate70&quot;</span>, price: <span class="number">7299.00</span>, weight:<span class="number">672.00</span>);</span><br><span class="line">	<span class="comment">// 需要提前创建好对象</span></span><br><span class="line">	<span class="type">Coupon</span> <span class="variable">coupon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriceDiscountCoupon</span>(threshold:<span class="number">9000</span>,discount:<span class="number">1000</span>)</span><br><span class="line">	<span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(product, amount: <span class="number">2</span>,coupon);</span><br><span class="line"></span><br><span class="line">	order.showorderInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>能在创建对象那一刻, 立马将所需要的依赖项都注入.<br>适用于明确知道对象不再变化.</p>
<h4 id="setter-注入"><a href="#setter-注入" class="headerlink" title="setter 注入"></a>setter 注入</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在setter中接收优惠券对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCoupon</span><span class="params">(Coupon coupon)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.coupon = coupon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Coupon</span> <span class="variable">coupon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RateDiscountCoupon</span>(<span class="number">9000</span>,<span class="number">85</span>);</span><br><span class="line">order.setCoupon(coupon);</span><br><span class="line"></span><br><span class="line">order.showorderInfo();</span><br></pre></td></tr></table></figure></div>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>接口时定义要做什么, 尽量不要变化.<br>类时定义怎么做, 可以看作是协议的履行者.</p>
<h3 id="接口分离"><a href="#接口分离" class="headerlink" title="接口分离"></a>接口分离</h3><p>接口分离原则（InterfaceSegregationPrinciple）也叫接口隔离原则.</p>
<ul>
<li>一个接口中应该只包含相同职责的方法, 尽可能少的方法, 方法过多时应考虑拆分接口.</li>
</ul>
<p>注意事项:</p>
<ul>
<li>Java 中 1 个类可以实现多个接口, 但是只能单继承</li>
<li>接口之间是可以继承的, 而且可以多继承.</li>
</ul>
<p>例如三个类只需要接口中的一部分方法.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/file-20250204104044568.jpg"
                     
                ></p>
<p>只需要将接口拆分成三个即可.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/file-20250204104100749.jpg"
                     
                ></p>
<p>实际案例, 实现快捷键和鼠标点击的事件监听:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onclick</span><span class="params">()</span>; <span class="comment">// 处理用户鼠标点击</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onkeydown</span><span class="params">(String key)</span>; <span class="comment">// 处理用户按下键盘</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onchange</span><span class="params">()</span>; <span class="comment">// 监控用户输入内容做补全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如此将全部功能定义在一个接口中, 我们在实现接口时, 就不得不把接口中所有的功能都实现:<br>例如我只想在这个类中实现 <code>onclick()</code> 方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageEventListener</span> <span class="keyword">implements</span> <span class="title class_">EventListener</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onclick</span><span class="params">()</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;展开包中的文件.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 并不需要实现下列方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onkeydown</span><span class="params">(String key)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onchange</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时遵守接口分离原则更为便利<br>将接口按功能和需求拆分:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MouseEventListener</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onclick</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意: 一个类中只能有一个接口</p>
<p>同理的, 接着拆分:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">KeyEventListener</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onkeydown</span><span class="params">(String key)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样, 原接口还剩下:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onchange</span><span class="params">()</span>; <span class="comment">// 监控用户输入内容做补全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样三个接口就独立开来.<br>只想在这个类中实现 <code>onclick()</code> 方法时只需要:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageEventListener</span> <span class="keyword">implements</span> <span class="title class_">EventListener</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onclick</span><span class="params">()</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;展开包中的文件.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>即可.</p>
<h4 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h4><p>如果又同时需要两个接口有以下两种方法:</p>
<h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageEventListener</span> <span class="keyword">implements</span> <span class="title class_">EventListener</span>, KeyEventListener&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onclick</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;展开包中的文件.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onkeydown</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;快捷键被按下了.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实现多个接口, 适用于需要实现的接口数量较少.</p>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>当需要实现的接口数量较多, 可以使用继承的方式组合多个接口:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span> <span class="keyword">extends</span> <span class="title class_">MouseEventListener</span>, EventListener&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onchange</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="其他特性-了解"><a href="#其他特性-了解" class="headerlink" title="其他特性(了解)"></a>其他特性(了解)</h3><p>在 Java 发展的过程中, Interface 添加了很多本来不应该属于它的特性, 例如:</p>
<ul>
<li>接口中的变量默认就是 public static final，也就是静态常量</li>
<li>接口中可以定义静态方法，可以直接用接口名.方法名调用</li>
<li>接口中可以定义默认方法，实现接口的类可以不用实现该方法</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="comment">//静态常量，默认是 public staticfinal</span></span><br><span class="line"><span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159265354979323846</span>;</span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">calculatePerimeter</span><span class="params">(<span class="type">double</span> radius）&#123;</span></span><br><span class="line"><span class="params">return <span class="number">2</span> _ PI _ radius;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">//默认方法</span></span><br><span class="line"><span class="params"><span class="keyword">default</span> <span class="type">double</span> calculateArea(<span class="type">double</span> radius）&#123;</span></span><br><span class="line"><span class="params">return PI * radius * radius;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>什么时候需要使用接口（解除与依赖项之间的耦合关系）？</p>
<ul>
<li>依赖的类将来有可能会升级或替换</li>
<li>与第三方系统对接，可能更换第三方服务提供者，例如支付、发短信</li>
<li>通过接口定义协议，不断开发新的接口实现类来拓展新功能</li>
</ul>
<p>接口和抽象类有什么区别？</p>
<ul>
<li>接口，用来定义协议，实现低耦合、拓展性强的代码</li>
<li>抽象类，部分实现的类，用来在子类之间共享代码</li>
</ul>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>封装与继承</tag>
        <tag>接口与多态</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进阶-常用API</title>
    <url>/2025/02/09/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[<p>API(Application Programing Interface), 也就是应用程序接口, 通常是指应用程序之间交换的协议和标准.<br>有了这一套标准, 每个团队遵循这套标准各自开发对应的内容, 最后完成的项目就能正确的交互和协作.</p>
<p>在 Java 运行环境 中 包含核心类库, 这套核心类库, 就是 Java 为开发者提供的一套核心 API 了.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8api/file-20250219120725524.jpg"
                     
                ></p>
<p><a class="link"   href="https://doc.qzxdp.cn/jdk/17/zh/api/index.html" >Java® 平台、标准版和 Java 开发工具包 版本 17 API 规范<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Java 中所有类, 都直接或间接地继承了 Object 类, 因此都可以使用 Object 中定义方法.</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>比较两个对象是否相等, 比较对象建议用 <code>equals()</code>,<br>而不是 <code>==</code> , 双等号会比较<strong>变量里面的值</strong>, 比较对象时, 其中存储的是地址, 不能达到预期效果.</p>
<p>不过, 在 equals 方法中的默认实现如下, 仍然是用的 <code>==</code> 比较.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在 IDEA 中, 按住 <code>Ctrl</code> 点击方法名可跳转至实现类.</p>
</blockquote>
<p>这是因为 <code>Object</code> 作为所有类的超级父类, 其作用只是提供一个基本的比较逻辑.<br>当没有重写覆盖 <code>equals()</code> 方法时, 才会调用这个默认实现.</p>
<p>而 String 类能够正常比较就是重写了 <code>equals()</code> 方法.</p>
<p>如果我们需要比较自定义的类,<br>例如一个包含 <code>name</code> 和 <code>age</code> 属性的 <code>Person</code> 类, 覆写 <code>equals()</code> 方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))&#123; <span class="comment">// 向下强转需要判断类型, 保证健壮性</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">	retrun <span class="built_in">this</span>.name.equals(p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>equals()</code> 方法通常配合 <code>hashCode()</code> 共同使用.</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>根据对象信息, 计算出一个哈希值(整数), 将来会在哈希表中用到.</p>
<blockquote>
<p>哈希表可以当作一种数据结构.<br>哈希值会影响对象在哈希表中存储的位置.</p>
</blockquote>
<p><code>hashCode()</code> 方法必须满足以下条件:</p>
<ul>
<li>同一个对象, 多次调用该方法, <code>hashCode()</code> 必须始终返回相同整数.</li>
<li>如果两个对象用 <code>equals()</code> 比较:<ul>
<li>若相同, 则两个对象的 <code>hashCode()</code> 必须返回相同结果.</li>
<li>若不同, 则两个对象的 <code>hashCode()</code> 尽量返回不同结果 (不是必须).</li>
</ul>
</li>
</ul>
<p><code>hashcode()</code> 的默认算法是用一种随机数生成法生成 (Marsaglia 的 xor-shift), 使用 C 语言实现.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<p>同一个对象只会在第一次时生成一个随机数, 这个随机数会被缓存, 以保证每次调用始终返回相同值.</p>
<p>若要满足全部的条件,<br><code>hashCode()</code> 需要根据属性计算得到 , 这需要手动重写<code>hashCode()</code> 方法.<br>而刚刚提到的 <code>equals()</code> 方法同样也与属性关联.<br>我们在重写 <code>equals()</code> 方法的同时, 也应该重写 <code>hashCode()</code>.</p>
<p>IDEA 提供了自动生成 这两个方法的功能.</p>
<p>与生成 Getter 和 Setter 类似, 在代码编辑窗口右键:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8api/file-20250219134149639.jpg"
                     
                ></p>
<p>以此自动生成了两个方法.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person person)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>返回对象的字符串表示形式, 以便人们阅读并了解对象中的数据或信息.<br>当我们直接打印一个对象, 或者将对象与字符串拼接时, 默认就会调用对象的 toString 方法.</p>
<p>Objiect 中的默认实现如下:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCOde());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>getClass().getName()</code> 会展示当前类的完整名称 (包名 + 类名)<br><code>Integer.toHexString(hashCode())</code> 会先通过 hashCode 方法计算哈希值, 然后再转换为十六进制展示.</p>
<p>如果要展示自定义的对象, 肯定是想展示其属性, 这时就需要重写此方法.<br>当然, IDEA 已经内置了自动生成 tostring() 方法, 操作方式与之前类似.</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>是一个特殊的引用类型数据, 可以直接用字符串字面量创建对象.<br>(别的引用类型需要<code>new</code>关键字创建.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Wreckloud&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>不过 <code>String 类</code> 当然也能通过 <code>new</code> 关键字创建, 以下是常见的构造方法:</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>String(String original)</td>
<td>基于传入的字符串创建一个字符串对象副本</td>
</tr>
<tr>
<td>String(byte[] bytes)</td>
<td>用默认编码表将字节数组转换为字符串对象</td>
</tr>
<tr>
<td>String(byte[] bytes, Charset charset)</td>
<td>用指定的编码表将字节数组转为字符串对象</td>
</tr>
<tr>
<td>String(char[] value)</td>
<td>用字符数组创建出一个字符串对象</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接用字符串字面量创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用字符串字面量创建一个副本</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strCopy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用字节数组创建一个字符串</span></span><br><span class="line"><span class="type">byte</span>[] bytes = &#123;<span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">44</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">33</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用默认编码表将字节数组转换为字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strFromBytes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用指定的编码表将字节数组转为字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strFromBytesWithCharset</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用字符数组创建出一个字符串对象</span></span><br><span class="line"><span class="type">char</span>[] chars = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">strFromChars</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br></pre></td></tr></table></figure></div>

<p>更推荐使用 直接用字符串字面量创建对象.</p>
<p>无论在哪, 只要<strong>用字面量</strong>创建字符串对象, 都会在堆内存中的字符换常量池中检查是否存在.<br><code>new()</code> 的方式都会额外在堆内存中开辟空间.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8api/file-20250220160603683.jpg"
                     
                ></p>
<h2 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h2><p>当调用时, 检查字符串常量池是否包含当前字符串相等的字符串(通过 <code>.equals()</code> 判断).<br>如果存在, 会直接返回池中字符串对象;<br>否则, 将此字符串添加到池中, 并返回此对象.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个字符串，会自动进入字符串池</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 new 创建字符串，不会自动进入字符串池</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较使用字面量创建的字符串</span></span><br><span class="line">    System.out.println(str1 == str2); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较使用 new 创建的字符串</span></span><br><span class="line">    System.out.println(str3 == str4); <span class="comment">// 输出: false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 intern 方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> str3.intern();</span><br><span class="line">    System.out.println(str5 == str1); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比调用 intern 前后的结果</span></span><br><span class="line">    System.out.println(str3 == str5); <span class="comment">// 输出: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="判断与比较"><a href="#判断与比较" class="headerlink" title="判断与比较"></a>判断与比较</h2><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>大小写敏感</th>
</tr>
</thead>
<tbody><tr>
<td><code>equals(Object obj)</code></td>
<td>严格比较字符串内容是否<strong>完全相同</strong></td>
<td>✔️ 是</td>
</tr>
<tr>
<td><code>equalsIgnoreCase(String str)</code></td>
<td>比较字符串内容是否相同（忽略大小写）</td>
<td>❌ 否</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">System.out.println(str1.equals(<span class="string">&quot;hello&quot;</span>));        <span class="comment">// false</span></span><br><span class="line">System.out.println(str1.equalsIgnoreCase(<span class="string">&quot;HELLO&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>空白字符处理</th>
</tr>
</thead>
<tbody><tr>
<td><code>isEmpty()</code></td>
<td>检查字符串<strong>长度是否为 0</strong>（即 <code>&quot;&quot;</code>）</td>
<td>不识别空格</td>
</tr>
<tr>
<td><code>isBlank()</code></td>
<td>检查字符串是否为空<strong>或全为空白字符</strong></td>
<td>识别空格&#x2F;制表符&#x2F;换行符</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&quot;</span>.isEmpty());        <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;   &quot;</span>.isEmpty());     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;   &quot;</span>.isBlank());     <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot; \t\n&quot;</span>.isBlank());   <span class="comment">// true（含制表符、换行符）</span></span><br></pre></td></tr></table></figure></div>

<h3 id="前后缀检查"><a href="#前后缀检查" class="headerlink" title="前后缀检查"></a>前后缀检查</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>startsWith(String prefix)</code></td>
<td>判断字符串<strong>是否以指定前缀开头</strong></td>
</tr>
<tr>
<td><code>endsWith(String suffix)</code></td>
<td>判断字符串<strong>是否以指定后缀结尾</strong></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/data/images/photo.jpg&quot;</span>;</span><br><span class="line">System.out.println(path.startsWith(<span class="string">&quot;/data&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(path.endsWith(<span class="string">&quot;.png&quot;</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>

<h3 id="内容匹配"><a href="#内容匹配" class="headerlink" title="内容匹配"></a>内容匹配</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>匹配方式</th>
</tr>
</thead>
<tbody><tr>
<td><code>contains(CharSequence cs)</code></td>
<td>判断是否包含<strong>指定子字符串</strong></td>
<td>精确字符匹配</td>
</tr>
<tr>
<td><code>matches(String regex)</code></td>
<td>判断是否符合<strong>正则表达式规则</strong></td>
<td>正则模式匹配<br>[[正则表达式|正则表达式]]</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查是否包含子字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Java编程基础&quot;</span>;</span><br><span class="line">System.out.println(text.contains(<span class="string">&quot;编程&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则表达式验证手机号</span></span><br><span class="line">System.out.println(<span class="string">&quot;13800138000&quot;</span>.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h4 id="综合应用案例"><a href="#综合应用案例" class="headerlink" title="综合应用案例"></a>综合应用案例</h4><p><strong>场景</strong>：验证文件名合法性<br>要求：</p>
<ol>
<li>必须以 <code>report_</code> 开头</li>
<li>必须包含日期格式 <code>2023-12-31</code></li>
<li>必须以 <code>.pdf</code> 结尾</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;report_销售数据_2023-10-05.pdf&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> filename.startsWith(<span class="string">&quot;report_&quot;</span>)</span><br><span class="line">               &amp;&amp; filename.contains(<span class="string">&quot;2023-&quot;</span>)</span><br><span class="line">               &amp;&amp; filename.endsWith(<span class="string">&quot;.pdf&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(isValid); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong>：</p>
<ol>
<li><code>equals()</code> 比较的是<strong>字符串内容</strong>，不是内存地址（与 <code>==</code> 不同）</li>
<li><code>isBlank()</code> 需 Java 11+ 支持，低版本可用 <code>trim().isEmpty()</code> 替代</li>
<li><code>matches()</code> 要求<strong>完全匹配</strong>整个字符串（相当于正则表达式自动添加 <code>^...$</code>）</li>
</ol>
<p>String 类中提供的判断或比较字符串的方法, 返回值都是 boolean 类型.</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>equals(Object obj)</code><br><code>equalsIgnoreCase(String anotherString)</code></td>
<td>将当前字符串与指定对象比较<br>忽略大小写比较</td>
</tr>
<tr>
<td><code>isEmpty()</code><br><code>isBlank()</code></td>
<td>判断字符串是否为空字符串<br>判断字符串是否为空或全是空白</td>
</tr>
<tr>
<td><code>endsWith(String suffix)</code><br><code>startsWith(String prefix)</code></td>
<td>判断字符串是否以指定后缀结尾<br>判断字符串是否以指定前缀开始</td>
</tr>
<tr>
<td><code>matches(String regex)</code></td>
<td>判断字符串是否与指定的正字表达式匹配</td>
</tr>
<tr>
<td><code>contains(CharSequence cs)</code></td>
<td>判断当前字符串是否包含指定的子字符串</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. equals(): 比较两个字符串是否相等（区分大小写）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    System.out.println(user.equals(<span class="string">&quot;alice&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// 2. equalsIgnoreCase(): 比较两个字符串是否相等（忽略大小写）</span></span><br><span class="line">    System.out.println(user.equalsIgnoreCase(<span class="string">&quot;alice&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. isEmpty(): 判断字符串是否为空字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">empty</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    System.out.println(empty.isEmpty()); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 4. isBlank(): 判断字符串是否为空或仅包含空白字符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">blank</span> <span class="operator">=</span> <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    System.out.println(blank.isBlank()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. startsWith(): 判断字符串是否以指定前缀开头</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;data/users.txt&quot;</span>;</span><br><span class="line">    System.out.println(path.startsWith(<span class="string">&quot;data&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 6. endsWith(): 判断字符串是否以指定后缀结尾</span></span><br><span class="line">    System.out.println(path.endsWith(<span class="string">&quot;.txt&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. matches(): 判断字符串是否匹配指定的正则表达式</span></span><br><span class="line">    System.out.println(<span class="string">&quot;13800138000&quot;</span>.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. contains(): 判断字符串是否包含指定的子字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">article</span> <span class="operator">=</span> <span class="string">&quot;Java 是一种编程语言。&quot;</span>;</span><br><span class="line">    System.out.println(article.contains(<span class="string">&quot;Java&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><h3 id="基础属性获取"><a href="#基础属性获取" class="headerlink" title="基础属性获取"></a>基础属性获取</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>参数说明</th>
<th>返回值说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length()</code></td>
<td>获取字符串<strong>字符数量</strong></td>
<td>无</td>
<td>字符串长度（int）</td>
</tr>
<tr>
<td><code>charAt(int index)</code></td>
<td>获取指定索引位置的字符</td>
<td>索引范围：<code>0</code> 到 <code>length()-1</code></td>
<td>对应位置的字符（char）</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串长度</span></span><br><span class="line">System.out.println(str.length());   <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 获取索引为3的字符（索引从0开始）</span></span><br><span class="line">System.out.println(str.charAt(<span class="number">3</span>));  <span class="comment">// &#x27;l&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="切割与截取"><a href="#切割与截取" class="headerlink" title="切割与截取"></a>切割与截取</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>split(String regex)</code></td>
<td>按正则表达式规则拆分字符串</td>
<td>支持复杂分隔符（如逗号、空格等）</td>
</tr>
<tr>
<td><code>substring(int beginIndex, int endIndex)</code></td>
<td>截取指定索引范围的子字符串</td>
<td>含头不含尾（包含 begin，不包含 end）</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按空格拆分字符串</span></span><br><span class="line">String[] words = <span class="string">&quot;Java Python C++&quot;</span>.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(words)); <span class="comment">// [Java, Python, C++]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取索引2到5的字符（含2不含5）</span></span><br><span class="line">System.out.println(<span class="string">&quot;ABCDEFG&quot;</span>.substring(<span class="number">2</span>,<span class="number">5</span>)); <span class="comment">// &quot;CDE&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="类型转换与查找定位"><a href="#类型转换与查找定位" class="headerlink" title="类型转换与查找定位"></a>类型转换与查找定位</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>返回值说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toCharArray()</code></td>
<td>将字符串转为字符数组</td>
<td>包含所有字符的 char[]</td>
</tr>
<tr>
<td><code>indexOf(String str)</code></td>
<td>查找子字符串首次出现的位置</td>
<td>未找到返回 <code>-1</code></td>
</tr>
<tr>
<td><code>lastIndexOf(String str)</code></td>
<td>查找子字符串最后次出现的位置</td>
<td>未找到返回 <code>-1</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换为字符数组</span></span><br><span class="line"><span class="type">char</span>[] letters = <span class="string">&quot;Hello&quot;</span>.toCharArray();</span><br><span class="line">System.out.println(Arrays.toString(letters)); <span class="comment">// [H, e, l, l, o]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找子字符串位置</span></span><br><span class="line">System.out.println(<span class="string">&quot;apple&quot;</span>.indexOf(<span class="string">&quot;pl&quot;</span>));    <span class="comment">// 2</span></span><br><span class="line">System.out.println(<span class="string">&quot;apple&quot;</span>.indexOf(<span class="string">&quot;banana&quot;</span>));<span class="comment">// -1</span></span><br></pre></td></tr></table></figure></div>

<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><table>
<thead>
<tr>
<th>方法变体</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>substring(int beginIndex)</code></td>
<td>从指定位置截取到字符串末尾</td>
</tr>
<tr>
<td><code>indexOf(int ch)</code></td>
<td>查找字符首次出现的位置</td>
</tr>
<tr>
<td><code>indexOf(String str, int fromIndex)</code></td>
<td>从指定位置开始查找子字符串</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从索引3截取到末尾</span></span><br><span class="line">System.out.println(<span class="string">&quot;0123456789&quot;</span>.substring(<span class="number">3</span>)); <span class="comment">// &quot;3456789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找字符 &#x27;a&#x27; 的位置</span></span><br><span class="line">System.out.println(<span class="string">&quot;banana&quot;</span>.indexOf(<span class="string">&#x27;a&#x27;</span>));     <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引2开始查找 &quot;na&quot;</span></span><br><span class="line">System.out.println(<span class="string">&quot;banana&quot;</span>.indexOf(<span class="string">&quot;na&quot;</span>,<span class="number">2</span>));  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>

<h4 id="综合应用案例-1"><a href="#综合应用案例-1" class="headerlink" title="综合应用案例"></a>综合应用案例</h4><p><strong>场景</strong>：解析日志条目<br>日志格式：<code>[2023-10-05] [ERROR] Connection timeout</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">log</span> <span class="operator">=</span> <span class="string">&quot;[2023-10-05] [ERROR] Connection timeout&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 提取日期部分</span></span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> log.substring(<span class="number">1</span>, <span class="number">11</span>);  <span class="comment">// &quot;2023-10-05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 拆分日志级别和内容</span></span><br><span class="line">String[] parts = log.split(<span class="string">&quot;\\] \\[&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">level</span> <span class="operator">=</span> parts[<span class="number">1</span>].substring(<span class="number">0</span>, parts[<span class="number">1</span>].indexOf(<span class="string">&#x27;]&#x27;</span>)); <span class="comment">// &quot;ERROR&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取错误描述</span></span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> log.substring(log.lastIndexOf(<span class="string">&#x27;]&#x27;</span>)+<span class="number">2</span>); <span class="comment">// &quot;Connection timeout&quot;</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;日期：&quot;</span> + date);       <span class="comment">// 2023-10-05</span></span><br><span class="line">System.out.println(<span class="string">&quot;级别：&quot;</span> + level);      <span class="comment">// ERROR</span></span><br><span class="line">System.out.println(<span class="string">&quot;描述：&quot;</span> + message);    <span class="comment">// Connection timeout</span></span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong>：</p>
<ol>
<li><code>substring</code> 的结束索引不包含在结果中（类似 Python 切片）</li>
<li><code>split</code> 使用正则表达式时，特殊字符需转义（如 <code>.</code> 要写成 <code>\\.</code>）</li>
<li><code>charAt</code> 索引越界会抛出 <code>StringIndexOutOfBoundsException</code></li>
</ol>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="基础替换操作"><a href="#基础替换操作" class="headerlink" title="基础替换操作"></a>基础替换操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用说明</th>
<th>匹配方式</th>
</tr>
</thead>
<tbody><tr>
<td><code>replace(CharSequence target, CharSequence replacement)</code></td>
<td><strong>精确替换</strong>指定字符&#x2F;字符串</td>
<td>普通文本匹配</td>
</tr>
<tr>
<td><code>replaceAll(String regex, String replacement)</code></td>
<td><strong>正则替换</strong>匹配内容</td>
<td>正则表达式匹配</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 精确替换字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">System.out.println(text.replace(<span class="string">&quot;l&quot;</span>, <span class="string">&quot;*&quot;</span>));  <span class="comment">// He**o Wor*d!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则替换数字为星号</span></span><br><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;Room 205, ID: A123&quot;</span>;</span><br><span class="line">System.out.println(code.replaceAll(<span class="string">&quot;\\d&quot;</span>, <span class="string">&quot;*&quot;</span>));  <span class="comment">// Room ***, ID: A***</span></span><br></pre></td></tr></table></figure></div>

<h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用说明</th>
<th>语言敏感处理</th>
</tr>
</thead>
<tbody><tr>
<td><code>toLowerCase()</code></td>
<td>转换为全小写</td>
<td>✔️ 支持多语言</td>
</tr>
<tr>
<td><code>toUpperCase()</code></td>
<td>转换为全大写</td>
<td>✔️ 支持多语言</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小写互转</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Java编程&quot;</span>;</span><br><span class="line">System.out.println(str.toUpperCase());  <span class="comment">// JAVA编程</span></span><br><span class="line">System.out.println(<span class="string">&quot;ÄÖÜ&quot;</span>.toLowerCase());  <span class="comment">// äöü（德语字符正确处理）</span></span><br></pre></td></tr></table></figure></div>

<h3 id="空格处理"><a href="#空格处理" class="headerlink" title="空格处理"></a>空格处理</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用说明</th>
<th>空白字符识别范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>strip()</code></td>
<td>删除<strong>前后</strong>所有空白字符（包括全角空格）</td>
<td>空格&#x2F;制表符&#x2F;换行符&#x2F;全角空格</td>
</tr>
<tr>
<td><code>trim()</code></td>
<td>删除前后半角空白字符（兼容旧版本）</td>
<td>仅半角空格&#x2F;制表符&#x2F;换行符</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理含全角空格的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;　 Hello　&quot;</span>;</span><br><span class="line">System.out.println(s.strip());       <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">System.out.println(s.trim());        <span class="comment">// &quot;　Hello&quot;（仍保留全角空格）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理常规空白</span></span><br><span class="line">System.out.println(<span class="string">&quot;  data\n  &quot;</span>.strip());  <span class="comment">// &quot;data&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="扩展方法与案例"><a href="#扩展方法与案例" class="headerlink" title="扩展方法与案例"></a>扩展方法与案例</h3><table>
<thead>
<tr>
<th>方法变体</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>replaceFirst(String regex, String replacement)</code></td>
<td>仅替换<strong>第一个</strong>匹配项</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换首个数字</span></span><br><span class="line">System.out.println(<span class="string">&quot;A1B2C3&quot;</span>.replaceFirst(<span class="string">&quot;\\d&quot;</span>, <span class="string">&quot;*&quot;</span>));  <span class="comment">// A*B2C3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除字符串首尾星号</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;**重要通知**&quot;</span>;</span><br><span class="line">System.out.println(s.replaceAll(<span class="string">&quot;^\\*+|\\*+$&quot;</span>, <span class="string">&quot;&quot;</span>));  <span class="comment">// 重要通知</span></span><br></pre></td></tr></table></figure></div>

<h3 id="综合应用案例-2"><a href="#综合应用案例-2" class="headerlink" title="综合应用案例"></a>综合应用案例</h3><p><strong>场景</strong>：格式化用户输入的手机号<br>要求：</p>
<ol>
<li>去除所有空格</li>
<li>将区号中的 <code>0086</code> 统一转为 <code>+86</code></li>
<li>隐藏中间 4 位号码</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot; 0086 138 0013 8000 &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> input</span><br><span class="line">    .strip()                          <span class="comment">// 去空格 → &quot;0086 138 0013 8000&quot;</span></span><br><span class="line">    .replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>)                  <span class="comment">// 删空格 → &quot;008613800138000&quot;</span></span><br><span class="line">    .replaceFirst(<span class="string">&quot;0086&quot;</span>, <span class="string">&quot;+86&quot;</span>)       <span class="comment">// 改区号 → &quot;+8613800138000&quot;</span></span><br><span class="line">    .replaceAll(<span class="string">&quot;(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)&quot;</span>, <span class="string">&quot;$1****$2&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(formatted);  <span class="comment">// +86138****8000</span></span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong>：</p>
<ol>
<li><code>replaceAll</code> 使用正则时，需对特殊符号转义（如 <code>.</code> 要写成 <code>\\.</code>）</li>
<li><code>strip()</code> 需要 Java 11+，低版本可用 <code>trim()</code> + 正则处理全角空格</li>
<li>所有转换方法均<strong>返回新字符串</strong>，原始字符串不可变（符合字符串不可变性原则）</li>
</ol>
<h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><h3 id="静态拼接方案"><a href="#静态拼接方案" class="headerlink" title="静态拼接方案"></a>静态拼接方案</h3><p><strong>核心方法</strong>：<code>String.join()</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用分隔符拼接多个元素</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> String.join(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;2023&quot;</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;05&quot;</span>);</span><br><span class="line">System.out.println(result); <span class="comment">// &quot;2023-10-05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接集合元素</span></span><br><span class="line">List&lt;String&gt; colors = Arrays.asList(<span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">System.out.println(String.join(<span class="string">&quot; | &quot;</span>, colors)); <span class="comment">// &quot;Red | Green | Blue&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>特点</strong>：</p>
<ul>
<li>适合已知元素数量的场景</li>
<li>自动处理分隔符插入</li>
<li>可接收数组&#x2F;集合作为参数</li>
</ul>
<h3 id="动态拼接工具：StringBuilder"><a href="#动态拼接工具：StringBuilder" class="headerlink" title="动态拼接工具：StringBuilder"></a>动态拼接工具：StringBuilder</h3><p><strong>核心方法</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>链式调用示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>append()</code></td>
<td>追加任意类型数据</td>
<td><code>sb.append(&quot;A&quot;).append(123)</code></td>
</tr>
<tr>
<td><code>insert(int, obj)</code></td>
<td>在指定位置插入内容</td>
<td><code>sb.insert(2, &quot;X&quot;)</code></td>
</tr>
<tr>
<td><code>reverse()</code></td>
<td>反转字符串内容</td>
<td><code>sb.reverse()</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建与基础使用</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;订单号：&quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;TX&quot;</span>)</span><br><span class="line">  .append(System.currentTimeMillis())</span><br><span class="line">  .append(<span class="string">&quot;\n商品：&quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;手机&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 订单号：TX1633425600000</span></span><br><span class="line"><span class="comment">// 商品：手机</span></span><br></pre></td></tr></table></figure></div>

<p><strong>性能优势场景</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 低效做法（产生多个中间字符串）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">    str += i; <span class="comment">// 每次循环创建新对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效做法（单对象操作）</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="综合应用案例-3"><a href="#综合应用案例-3" class="headerlink" title="综合应用案例"></a>综合应用案例</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 SQL 语句</span></span><br><span class="line">List&lt;String&gt; conditions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">conditions.add(<span class="string">&quot;age &gt; 18&quot;</span>);</span><br><span class="line">conditions.add(<span class="string">&quot;status = 1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">query</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;SELECT * FROM users&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!conditions.isEmpty()) &#123;</span><br><span class="line">    query.append(<span class="string">&quot; WHERE &quot;</span>)</span><br><span class="line">         .append(String.join(<span class="string">&quot; AND &quot;</span>, conditions));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(query);</span><br><span class="line"><span class="comment">// 输出：SELECT * FROM users WHERE age &gt; 18 AND status = 1</span></span><br></pre></td></tr></table></figure></div>

<h4 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h4><table>
<thead>
<tr>
<th>场景</th>
<th><code>+</code> 操作符</th>
<th><code>StringBuilder</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>单次拼接</strong></td>
<td>直接使用（编译器优化）</td>
<td>不必要</td>
</tr>
<tr>
<td><strong>循环内拼接</strong></td>
<td>产生大量临时对象</td>
<td>单对象高效操作</td>
</tr>
<tr>
<td><strong>需要中间操作</strong></td>
<td>无法实现</td>
<td>支持插入&#x2F;删除&#x2F;替换等</td>
</tr>
</tbody></table>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><p><strong>字面量合并机制</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span> + <span class="string">&quot;B&quot;</span>;  <span class="comment">// 编译后优化为 &quot;AB&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> a + b;     <span class="comment">// 运行时创建新对象</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>类型自动转换</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringBuilder可接受任意类型</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="number">100</span>)</span><br><span class="line">                   .append(<span class="literal">true</span>)</span><br><span class="line">                   .append(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>线程安全替代方案</strong>：</p>
<ul>
<li>多线程环境使用 <code>StringBuffer</code>（方法同步）</li>
<li>单线程优先使用 <code>StringBuilder</code>（更高效）</li>
</ul>
</li>
</ol>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>包装类 是八种基本数据类型对应的 <strong>引用类型</strong>.</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
<p>八种包装类的关系如图:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8api/file-20250226154409061.jpg"
                     
                ></p>
<p><strong>存在意义</strong>：</p>
<ol>
<li>让基本类型具备对象特性（可放入集合&#x2F;支持 null 值&#x2F;实现泛型）</li>
<li>提供类型转换、进制转换等工具方法</li>
<li>符合面向对象设计原则</li>
</ol>
<p><strong>内存差异</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;                <span class="comment">// 栈内存直接存储值</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">objNum</span> <span class="operator">=</span> <span class="number">10</span>;         <span class="comment">// 堆内存存储对象（包含方法区引用）</span></span><br></pre></td></tr></table></figure></div>

<h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><p>JDK5 开始 , Java 引入了自动装箱和自动拆箱机制, 实现了包装类与基本类型之间的自动转换.</p>
<p><strong>装箱</strong>：基本类型 → 包装类型（自动调用<code>valueOf()</code>）<br><strong>拆箱</strong>：包装类型 → 基本类型（自动调用<code>xxxValue()</code>）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8api/file-20250226160910528.jpg"
                     
                ></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;        <span class="comment">// 等价于 Integer.valueOf(100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;              <span class="comment">// 等价于 a.intValue()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合中的自动装箱</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">5</span>);            <span class="comment">// 自动装箱为 Integer</span></span><br></pre></td></tr></table></figure></div>

<p><strong>风险点</strong>：</p>
<p>空指针风险（重点规避）</p>
<p><strong>典型场景</strong>：包装类对象为 <code>null</code> 时执行拆箱操作</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> getFromDB(); <span class="comment">// 可能返回 null</span></span><br><span class="line"><span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> price + <span class="number">10</span>;      <span class="comment">// 抛出 NullPointerException</span></span><br></pre></td></tr></table></figure></div>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1. 类型转换"></a>1. 类型转换</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>Integer.parseInt(&quot;123&quot;)</code></td>
<td>字符串 → 基本类型</td>
<td><code>int x = Integer.parseInt(&quot;42&quot;)</code></td>
</tr>
<tr>
<td><code>Integer.valueOf(&quot;101&quot;)</code></td>
<td>字符串 → 包装类型</td>
<td><code>Integer y = Integer.valueOf(&quot;101&quot;)</code></td>
</tr>
<tr>
<td><code>numObj.toString()</code></td>
<td>包装类型 → 字符串</td>
<td><code>&quot;Value: &quot; + Integer.valueOf(5)</code></td>
</tr>
</tbody></table>
<h4 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二进制转换</span></span><br><span class="line">System.out.println(Integer.toBinaryString(<span class="number">10</span>));    <span class="comment">// 1010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制转换</span></span><br><span class="line">System.out.println(Integer.toHexString(<span class="number">255</span>));      <span class="comment">// ff</span></span><br></pre></td></tr></table></figure></div>

<h4 id="3-极值常量"><a href="#3-极值常量" class="headerlink" title="3. 极值常量"></a>3. 极值常量</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE;   <span class="comment">// 2147483647</span></span><br><span class="line"><span class="type">double</span> <span class="variable">min</span> <span class="operator">=</span> Double.MIN_VALUE; <span class="comment">// 4.9E-324</span></span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="对象缓存机制"><a href="#对象缓存机制" class="headerlink" title="对象缓存机制"></a>对象缓存机制</h3><p><strong>缓存范围</strong>：</p>
<ul>
<li><code>Integer</code>: -128 ~ 127</li>
<li><code>Boolean</code>: true&#x2F;false 全部缓存</li>
<li><code>Character</code>: 0 ~ 127</li>
</ul>
<p><strong>影响比较逻辑</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b);       <span class="comment">// true（使用缓存对象）</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(c == d);       <span class="comment">// false（新建对象）</span></span><br></pre></td></tr></table></figure></div>

<p><strong>正确比较方式</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 equals() 比较内容</span></span><br><span class="line">System.out.println(c.equals(d));  <span class="comment">// true（值相同）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 compareTo() 比较大小</span></span><br><span class="line">System.out.println(c.compareTo(<span class="number">200</span>)); <span class="comment">// -72（小于返回负数）</span></span><br></pre></td></tr></table></figure></div>

<h5 id="1-优先使用基本类型场景"><a href="#1-优先使用基本类型场景" class="headerlink" title="1. 优先使用基本类型场景"></a>1. 优先使用基本类型场景</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例：无意义的对象创建</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> i;  <span class="comment">// 产生大量临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正例：基本类型更高效</span></span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;        <span class="comment">// 基本类型无对象开销</span></span><br></pre></td></tr></table></figure></div>

<h5 id="2-Null-安全处理方案"><a href="#2-Null-安全处理方案" class="headerlink" title="2. Null 安全处理方案"></a>2. Null 安全处理方案</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> getFromDB();  <span class="comment">// 可能返回null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案一：默认值处理</span></span><br><span class="line"><span class="type">int</span> <span class="variable">safePrice</span> <span class="operator">=</span> (price != <span class="literal">null</span>) ? price : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案二：Optional处理</span></span><br><span class="line"><span class="type">int</span> <span class="variable">safePrice</span> <span class="operator">=</span> Optional.ofNullable(price).orElse(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<h5 id="3-性能敏感场景优化"><a href="#3-性能敏感场景优化" class="headerlink" title="3. 性能敏感场景优化"></a>3. 性能敏感场景优化</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 低效做法（反复拆箱装箱）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">    total += i;  <span class="comment">// 等效于 total = Integer.valueOf(total.intValue() + i)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效做法（使用基本类型）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">    total += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ol>
<li><p><strong>数据库字段映射</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 允许字段值为null</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;  <span class="comment">// 使用包装类表示年龄可能未知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>JSON 数据解析</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理可能缺失的数值字段</span></span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> getApiResponse();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">score</span> <span class="operator">=</span> data.has(<span class="string">&quot;score&quot;</span>) ? data.getInt(<span class="string">&quot;score&quot;</span>) : <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>泛型集合操作</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 基本类型不能用于泛型</span></span><br><span class="line">ids.add(<span class="number">1001</span>);</span><br><span class="line">ids.add(<span class="literal">null</span>);  <span class="comment">// 允许存储空值</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>自定义异常 就是自定义类并继承 Exception 或 Runtime Exception.</p>
<p>自定义异常有以下好处:</p>
<ul>
<li>能够针对不同业务定义不同异常</li>
<li>避免了臃肿的方法声明</li>
<li>简化异常处理逻辑</li>
<li>更清晰地展示错误信息</li>
</ul>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常就是程序执行过程中导致程序正常执行流程被中断的不确定事件.</p>
<p>Java 对异常进行了总结归类, 然后把他们封装成了不同的类, 形成了一整套的异常继承体系.<br>其中, 最顶级的父类是 <code>Throwable</code> .</p>
<pre class="mermaid">graph TD
    Throwable --> Error(系统错误<br>Error)
    Throwable --> Exception(程序异常<br>Exception)
    Error --> StackOverflowError(栈溢出错误<br>StackOverflowError)
    Error --> OutOfMemoryError(内存溢出错误<br>OutOfMemoryError)
    Exception --> RuntimeException(运行时异常<br>RuntimeException)
    Exception --> CheckedException(受检异常<br>CheckedException)</pre>

<p>Error 是程序之外的错误, 例如:</p>
<ul>
<li>StackOverflowError: 栈溢出错误.</li>
<li>OutOfMemoryFeeoe: 内存溢出错误</li>
</ul>
<p>Exception 是程序本身的异常, 可以分为</p>
<ul>
<li>运行期异常, 也叫 unchecked 异常</li>
<li>编译期异常, 也叫 checked 异常</li>
</ul>
<p><strong>高频异常类型</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行时异常（无需提前处理）</span></span><br><span class="line">NullPointerException <span class="comment">// 空指针</span></span><br><span class="line">ArrayIndexOutOfBoundsException <span class="comment">// 数组越界</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 受检异常（必须处理）</span></span><br><span class="line">IOException <span class="comment">// 文件操作异常</span></span><br><span class="line">SQLException <span class="comment">// 数据库操作异常</span></span><br></pre></td></tr></table></figure></div>

<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>编译期异常, 也就是<strong>受检异常</strong>(checked Exception) 是需要在开发时显式处理的, 不然程序编译不会通过.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8api/file-20250228142321052.jpg"
                     
                ><br>处理方案之一就是 <code>try-carch</code> 捕获异常.</p>
<p><strong>基础模板</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能出问题的代码</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// 处理文件未找到的情况</span></span><br><span class="line">    System.out.println(<span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">    e.printStackTrace(); <span class="comment">// 打印错误栈</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否异常都会执行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;资源清理操作&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>多异常处理</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr[<span class="number">5</span>]); <span class="comment">// 可能数组越界</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    num.toString(); <span class="comment">// 可能空指针</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException | NullPointerException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发生运行时异常：&quot;</span> + e.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h3><p>异常除了 <code>try-catch</code> 捕获以外, 也可通过 <code>throw</code> 抛出.<br>如果抛出的是编译期异常, 还需要再抛出的方法上用 <code>throws</code> 声明抛出的异常.</p>
<p><strong>方法声明抛出</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取配置文件方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readConfig</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> Files.readString(Path.of(<span class="string">&quot;config.cfg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>手动抛出异常</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">throws</span> InsufficientFundsException &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount &gt; balance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientFundsException</span>(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="自定义异常-1"><a href="#自定义异常-1" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>自定义异常 就是自定义类并继承 <code>Exception</code> 或 <code>Runtime Exception</code>.<br>自定义异常有以下好处:</p>
<ul>
<li>能够针对不同业务定义不同异常</li>
<li>避免了臃肿的方法声明</li>
<li>简化异常处理逻辑</li>
<li>更清晰地展示错误信息</li>
</ul>
<p><strong>创建自定义异常</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承RuntimeException（非受检异常）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InvalidAgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvalidAgeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Exception（受检异常）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentFailedException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PaymentFailedException</span><span class="params">(String errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;支付失败，错误码：&quot;</span> + errorCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>实际使用</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAgeException</span>(<span class="string">&quot;年龄必须≥18岁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p><strong>不要吞掉异常</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误做法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    riskyOperation();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 空catch块隐藏问题！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>精准捕获原则</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    parseData();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;  <span class="comment">// 明确异常类型</span></span><br><span class="line">    handleNumberError();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    handleIOError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>finally 资源释放</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 读取操作...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(br != <span class="literal">null</span>) &#123;</span><br><span class="line">        br.close(); <span class="comment">// 确保文件流关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="Date-类（旧版-API，线程不安全）"><a href="#Date-类（旧版-API，线程不安全）" class="headerlink" title="Date 类（旧版 API，线程不安全）"></a>Date 类（旧版 API，线程不安全）</h3><p><strong>作用</strong>：表示时间戳（1970-01-01 00:00:00 GMT 至今的毫秒数），适用于简单时间记录和系统间传输</p>
<h4 id="构造方法表"><a href="#构造方法表" class="headerlink" title="构造方法表"></a>构造方法表</h4><table>
<thead>
<tr>
<th>方法签名</th>
<th>示例代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Date()</code></td>
<td><code>Date now = new Date()</code></td>
<td>创建当前系统时间实例（含毫秒）</td>
</tr>
<tr>
<td><code>Date(long milliseconds)</code></td>
<td><code>Date date = new Date(1672531200000L)</code></td>
<td>创建指定时间戳实例（对应 2023-01-01 00:00:00 GMT）</td>
</tr>
</tbody></table>
<h4 id="常用方法表"><a href="#常用方法表" class="headerlink" title="常用方法表"></a>常用方法表</h4><table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>应用场景</th>
<th>典型返回值示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>after(Date when)</code></td>
<td>boolean</td>
<td>验证票据有效期</td>
<td><code>true</code>&#x2F;<code>false</code></td>
</tr>
<tr>
<td><code>before(Date when)</code></td>
<td>boolean</td>
<td>判断活动是否已开始</td>
<td><code>true</code>&#x2F;<code>false</code></td>
</tr>
<tr>
<td><code>compareTo(Date)</code></td>
<td>int</td>
<td>时间排序（任务调度队列）</td>
<td><code>1</code>&#x2F;<code>0</code>&#x2F;<code>-1</code></td>
</tr>
<tr>
<td><code>getTime()</code></td>
<td>long</td>
<td>生成唯一 ID（时间戳+随机数）</td>
<td><code>1690012345678</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 场景1：验证订单有效期</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">createTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1690000000000L</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">expireTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1690000000000L</span> + <span class="number">3600_000L</span>); <span class="comment">// 1小时后过期</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().before(expireTime); <span class="comment">// 检查当前是否在有效期内</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景2：生成唯一ID</span></span><br><span class="line">String <span class="title function_">generateOrderId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">    <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> timestamp + <span class="string">&quot;-&quot;</span> + random; <span class="comment">// &quot;1690012345678-742&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景3：时间排序</span></span><br><span class="line">List&lt;Date&gt; dates = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1690000000000L</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1680000000000L</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1700000000000L</span>)</span><br><span class="line">);</span><br><span class="line">Collections.sort(dates); <span class="comment">// 自然顺序排序</span></span><br></pre></td></tr></table></figure></div>

<h3 id="LocalDate（日期处理）"><a href="#LocalDate（日期处理）" class="headerlink" title="LocalDate（日期处理）"></a>LocalDate（日期处理）</h3><p><strong>作用</strong>：处理年月日（YYYY-MM-DD），不包含时间及时区</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>now()</code></td>
<td>LocalDate</td>
<td>获取当前日期</td>
</tr>
<tr>
<td><code>of(year, month, day)</code></td>
<td>LocalDate</td>
<td>创建指定日期</td>
</tr>
<tr>
<td><code>parse(String)</code></td>
<td>LocalDate</td>
<td>解析标准格式字符串（ISO 8601）</td>
</tr>
<tr>
<td><code>plusDays(long)</code></td>
<td>LocalDate</td>
<td>日期加法（天）</td>
</tr>
<tr>
<td><code>minusMonths(long)</code></td>
<td>LocalDate</td>
<td>日期减法（月）</td>
</tr>
<tr>
<td><code>isBefore(LocalDate)</code></td>
<td>boolean</td>
<td>日期比较</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建示例</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nationalDay</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">parsedDate</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2023-07-20&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用场景：计算有效期</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">orderDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">expireDate</span> <span class="operator">=</span> orderDate.plusDays(<span class="number">30</span>);  <span class="comment">// 30天后过期</span></span><br></pre></td></tr></table></figure></div>

<h3 id="LocalDateTime（日期时间处理）"><a href="#LocalDateTime（日期时间处理）" class="headerlink" title="LocalDateTime（日期时间处理）"></a>LocalDateTime（日期时间处理）</h3><p><strong>作用</strong>：处理年月日时分秒（精确到纳秒），不包含时区</p>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>now()</code></td>
<td>LocalDateTime</td>
<td>获取当前日期时间</td>
</tr>
<tr>
<td><code>of(year, month, day, hour, minute)</code></td>
<td>LocalDateTime</td>
<td>创建指定日期时间</td>
</tr>
<tr>
<td><code>plusHours(long)</code></td>
<td>LocalDateTime</td>
<td>时间加法（小时）</td>
</tr>
<tr>
<td><code>toLocalDate()</code></td>
<td>LocalDate</td>
<td>提取日期部分</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建与操作示例</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">meetingTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2023</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用场景：会议提醒</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">nextMeeting</span> <span class="operator">=</span> meetingTime.plusWeeks(<span class="number">1</span>).withHour(<span class="number">15</span>);  <span class="comment">// 下周同时间，改为15点</span></span><br></pre></td></tr></table></figure></div>

<h4 id="DateTimeFormatter（格式化解析）"><a href="#DateTimeFormatter（格式化解析）" class="headerlink" title="DateTimeFormatter（格式化解析）"></a>DateTimeFormatter（格式化解析）</h4><p><strong>作用</strong>：线程安全的日期格式处理</p>
<h4 id="常用模式"><a href="#常用模式" class="headerlink" title="常用模式"></a>常用模式</h4><table>
<thead>
<tr>
<th>模式符号</th>
<th>说明</th>
<th>示例输出</th>
</tr>
</thead>
<tbody><tr>
<td><code>yyyy</code></td>
<td>四位年份</td>
<td>2023</td>
</tr>
<tr>
<td><code>MM</code></td>
<td>两位月份</td>
<td>08</td>
</tr>
<tr>
<td><code>dd</code></td>
<td>两位日期</td>
<td>15</td>
</tr>
<tr>
<td><code>HH</code></td>
<td>24 小时制小时</td>
<td>14</td>
</tr>
<tr>
<td><code>mm</code></td>
<td>分钟</td>
<td>30</td>
</tr>
<tr>
<td><code>ss</code></td>
<td>秒</td>
<td>45</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式化示例</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> now.format(formatter);  <span class="comment">// &quot;2023-07-20 14:30&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析示例</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">parsed</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2023-12-31 23:59&quot;</span>, formatter);</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="Duration（时间间隔）"><a href="#Duration（时间间隔）" class="headerlink" title="Duration（时间间隔）"></a>Duration（时间间隔）</h3><p><strong>作用</strong>：精确计算时间差（支持纳秒级精度）</p>
<h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>between(start, end)</code></td>
<td>Duration</td>
<td>计算两个时间的间隔</td>
</tr>
<tr>
<td><code>toHours()</code></td>
<td>long</td>
<td>转换为小时总数</td>
</tr>
<tr>
<td><code>plusMinutes(long)</code></td>
<td>Duration</td>
<td>增加分钟数</td>
</tr>
<tr>
<td><code>isNegative()</code></td>
<td>boolean</td>
<td>判断是否为负时间间隔</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算代码执行时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">// ...执行操作...</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(start, end);</span><br><span class="line">System.out.println(<span class="string">&quot;耗时：&quot;</span> + duration.toMillis() + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间增量操作</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">extended</span> <span class="operator">=</span> duration.plusHours(<span class="number">2</span>).plusMinutes(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/2023/09/23/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>大二上学期选修报名了Python,实际上也有点想学习的念头.早听说python处理一些重复性的事很在行?  </p>
<p>课程笔记来自:<a class="link"   href="https://www.bilibili.com/video/BV1qW4y1a7fU/?spm_id_from=333.999.0.0&vd_source=b19220b8f372f3a81aa8463fde694a63" >Python基础<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h1 id="Python-基础语法"><a href="#Python-基础语法" class="headerlink" title="Python 基础语法"></a>Python 基础语法</h1><h3 id="字面量、数据类型"><a href="#字面量、数据类型" class="headerlink" title="字面量、数据类型"></a>字面量、数据类型</h3><p>被写下来的固定值称之为字面量,有以下6种常用数据类型:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>数字(Number)</td>
<td>整数(int)<br>浮点(float)<br>复数(complex)<br>布尔(bool)</td>
<td>复数形如4+3j,以j结尾表示的数</td>
</tr>
<tr>
<td>字符串(string)</td>
<td>描述文本的一种数据类型</td>
<td>由任意数量字符组成</td>
</tr>
<tr>
<td>列表(List)</td>
<td>有序的可变序列</td>
<td>Python中最频繁使用的数据类型</td>
</tr>
<tr>
<td>元组(Tuple)</td>
<td>有序的不可变序列</td>
<td>有序记录不可变的Python数据</td>
</tr>
<tr>
<td>集合(Set)</td>
<td>无序不重复集合</td>
<td>可无序记录不重复的数据</td>
</tr>
<tr>
<td>字典(Dictionary)</td>
<td>无序Key-Value集合</td>
<td>无序记录Key-Value型数据</td>
</tr>
</tbody></table>
<p><code>type()</code>能够查看字面量和变量的数据类型</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">114</span></span><br><span class="line"><span class="number">5.14</span></span><br><span class="line"><span class="string">&quot;我去!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 甚至都不用声明类型...</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">另外关于注释,单行注释是一个井号就ok,</span></span><br><span class="line"><span class="string">多行注释是像这样三个引号.</span></span><br><span class="line"><span class="string">不过md的代码块好像没给显示出来</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><table>
<thead>
<tr>
<th>语句(函数)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int(x)</td>
<td>将x转换为整数</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换为浮点数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将x转换为字符串</td>
</tr>
</tbody></table>
<ul>
<li>任何类型都可以转换成字符串</li>
<li>字符串只有数字才能转换成数字</li>
<li>浮点转换整数会丢失精度(小数部分)</li>
</ul>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>是用户在编程时用于给变量、类、方法等自定义的命名.<br>能自定义标识符的有:</p>
<ul>
<li>变量的名字</li>
<li>方法的名字</li>
<li>类的名字,等等…</li>
</ul>
<p>注意:  </p>
<ul>
<li>标识符不能以数字开头  </li>
<li>标识符不能使用关键字</li>
<li>标识符不推荐使用中文</li>
<li>标识符大小写敏感</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>除加减乘除外Python还有:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;&#x2F;</td>
<td>取整</td>
<td>返回商的整数部分</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>返回商的余数部分</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
<td>就是指数运算</td>
</tr>
</tbody></table>
<p>除了基本运算,Python也支持赋值运算.<br><strong>注意: Python 中是没有 ++ 和 – 的</strong></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol>
<li>单引号定义法: <code>name=&#39;雲之残骸&#39;</code></li>
<li>双引号定义法: <code>name=&quot;雲之残骸&quot;</code></li>
<li>三引号定义法: <code>name=&quot;&quot;&quot;雲之残骸&quot;&quot;&quot;</code></li>
</ol>
<p>其中,三引号定义法和多行注释写法相同,同样支持换行<br>当使用变量接收它时,会变成字符串.<br>不使用变量接收时,就可以当作多行注释.   </p>
<p>除了用 “+” 号拼接字符串, 我们还能使用占位符快速拼接字符串和变量  </p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;雲之残骸&quot;</span></span><br><span class="line">year = <span class="number">114514</span></span><br><span class="line">price = <span class="number">19.5</span></span><br><span class="line">massage = <span class="string">&quot;我去,是 %s.今年是 %d 年,衬衫的价格是 %2.1f&quot;</span> % (name,year,price)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>输出: &gt; 我去,是 雲之残骸 .今年是 114514 年,衬衫的价格是 19.5</p>
</blockquote>
<p>其中,%s:</p>
<ul>
<li>% 表示:占位</li>
<li>s 表示:将变量变成字符串放入占位的地方</li>
</ul>
<p>这一点与c语言相同,包括支持 %f 浮点数.<br>使用格式 %m.nf 能实现控制精度.</p>
<p>快速写法:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;雲之残骸&quot;</span></span><br><span class="line">year = <span class="number">114514</span></span><br><span class="line">price = <span class="number">19.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;我去,是<span class="subst">&#123;name&#125;</span>.今年是 <span class="subst">&#123;year&#125;</span> 年,衬衫的价格是 <span class="subst">&#123;price&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>此方法不限数字类型,也不关心精度控制.</p>
<h3 id="数据输入输出"><a href="#数据输入输出" class="headerlink" title="数据输入输出"></a>数据输入输出</h3><ul>
<li>输出: print<br>print输出默认换行,若想让输出换行,则可以:</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">```    </span><br><span class="line">可以在结尾加上 `end=<span class="string">&#x27;&#x27;</span>` 即可不换行.</span><br><span class="line">* 输入: <span class="built_in">input</span></span><br><span class="line"></span><br><span class="line">```Python</span><br><span class="line"><span class="comment"># 可以直接把提示语句写在input中:</span></span><br><span class="line"></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;你是?&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;明白了,你是 %s&quot;</span> % name)</span><br></pre></td></tr></table></figure></div>

<p>input输入的数据默认都会当成<strong>字符串</strong><br>可以使用强制转换: num &#x3D; input(num)</p>
<h1 id="Python-判断语句"><a href="#Python-判断语句" class="headerlink" title="Python 判断语句"></a>Python 判断语句</h1><p><strong>True &#x3D; 1<br>False &#x3D; 0</strong></p>
<h3 id="if-判断语句"><a href="#if-判断语句" class="headerlink" title="if 判断语句"></a>if 判断语句</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 要判断的条件<span class="number">1</span>:</span><br><span class="line">    条件成立要做的事<span class="number">1</span></span><br><span class="line">    条件成立要做的事<span class="number">2</span></span><br><span class="line"><span class="keyword">elif</span> 要判断的条件<span class="number">2</span>:</span><br><span class="line">    条件成立要做的事</span><br><span class="line"><span class="keyword">elif</span> 要判断的条件<span class="number">3</span>:</span><br><span class="line">    条件成立要做的事</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    条件不成立做的事</span><br></pre></td></tr></table></figure></div>

<p>注意冒号不能省略,<br>以及归属于if的代码块,需要四个空格缩进.      </p>
<p>可将input( )写入if中简化代码:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(<span class="built_in">input</span>(请输入数字:))&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure></div>
<p>例如将输入的数字与 3 比较判断大小.</p>
<h1 id="Python-循环语句"><a href="#Python-循环语句" class="headerlink" title="Python 循环语句"></a>Python 循环语句</h1><p>条件满足,便会去做对应的操作</p>
<h3 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    条件满足,要做的事.</span><br></pre></td></tr></table></figure></div>

<p>嵌套循环时,一定要注意空格缩进来确定关系.</p>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 待处理数据集:</span><br><span class="line">    循环满足条件时执行的代码</span><br></pre></td></tr></table></figure></div>

<ul>
<li>for循环无法定义循环条件,只能被动取出数据处理</li>
<li>依旧注意缩进格式</li>
</ul>
<h4 id="for-循环的变量作用域"><a href="#for-循环的变量作用域" class="headerlink" title="for 循环的变量作用域"></a>for 循环的变量作用域</h4><p>临时变量, 在 <strong>编程规范</strong> 上, 作用范围(作用域), 只限定 for 循环内部.</p>
<p>如果在 for 循环外部访问的临时变量:</p>
<ul>
<li>实际上是能访问的.</li>
<li>在规范上, 是不允许的. <strong>不建议</strong> 这样做.</li>
<li>如需访问, 可以在循环外定义它.</li>
</ul>
<h3 id="range-语句"><a href="#range-语句" class="headerlink" title="range 语句"></a>range 语句</h3><p>本质上是遍历: 序列类型</p>
<ul>
<li>语法 1</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(num)</span><br></pre></td></tr></table></figure></div>

<p>获取一个从 0 开始, 到 num 结束的数字序列 (<strong>不含</strong>num本身)</p>
<ul>
<li>语法 2</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(num1,num2)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">获得一个从 num1 开始, 到 num2 结束的数字序列 (**不含**num2本身)</span><br><span class="line"></span><br><span class="line">* 语法 <span class="number">3</span></span><br><span class="line"></span><br><span class="line">```Python</span><br><span class="line"><span class="built_in">range</span>(num1,num2,step)</span><br></pre></td></tr></table></figure></div>
<p>获得一个从 num1 开始,到 num2 结束的数字序列 (<strong>不含</strong>num2本身)<br>数字之间的步长为step的值 (step默认为 1 )</p>
<h3 id="continue-和-break-关键字"><a href="#continue-和-break-关键字" class="headerlink" title="continue 和 break 关键字"></a>continue 和 break 关键字</h3><ul>
<li>临时跳过: contine</li>
</ul>
<p>中断本次循环, 直接进入下一次循环  </p>
<ul>
<li>直接结束: break</li>
</ul>
<p>直接结束循环</p>
<h1 id="Python-函数"><a href="#Python-函数" class="headerlink" title="Python 函数"></a>Python 函数</h1><p>函数是 <strong>组织好的</strong>, <strong>可重复使用的</strong>, 用来<strong>实现特定功能的</strong> 代码段.</p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><ul>
<li>def关键字</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">传入参数</span>):</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br></pre></td></tr></table></figure></div>
<p>def关键字, 可以定义带有名称的函数.<br>传入参数和返回值不需要可以省略.</p>
<ul>
<li>lambda关键字(匿名函数)</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">add</span>):</span><br><span class="line">    result = add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">func(<span class="keyword">lambda</span> x,y:x+y)</span><br></pre></td></tr></table></figure></div>

<p>函数体只能写一行</p>
<h3 id="函数的传入参数"><a href="#函数的传入参数" class="headerlink" title="函数的传入参数"></a>函数的传入参数</h3><p>作用是能让函数接收外部传入数据</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>): <span class="comment"># 多个参数用逗号隔开</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明文档</span></span><br><span class="line"><span class="string">    :param x: 形参x的说明</span></span><br><span class="line"><span class="string">    :param y: 形参y的说明</span></span><br><span class="line"><span class="string">    :return: 返回值的说明</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    result = x + y <span class="comment"># &lt;--形式参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span>+<span class="subst">&#123;y&#125;</span>=<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>函数定义中的参数为 <strong>形式参数</strong><br>函数调用中的参数为 <strong>实际参数</strong></p>
<p>传入的参数要与形式参数一一对应.</p>
<ul>
<li><strong>多个传入参数</strong></li>
</ul>
<p>根据使用方式的不同, 函数有4种常见的参数使用方式.</p>
<ol>
<li><p><strong>位置参数</strong>: 调用函数时根据函数定义的参数位置来传递参数.</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name,age,gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;名字<span class="subst">&#123;name&#125;</span>,年龄<span class="subst">&#123;age&#125;</span>,性别<span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&quot;TOM&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>关键字参数</strong>: 调用时用”键&#x3D;值”形式传递参数</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name,age,gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;名字<span class="subst">&#123;name&#125;</span>,年龄<span class="subst">&#123;age&#125;</span>,性别<span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">user_info(gender=<span class="string">&quot;男&quot;</span>,name=<span class="string">&quot;TOM&quot;</span>,age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>缺省参数</strong>: 也就是设置默认值</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name,age,gender=<span class="string">&quot;男&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;名字<span class="subst">&#123;name&#125;</span>,年龄<span class="subst">&#123;age&#125;</span>,性别<span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&quot;TOM&quot;</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>不定长参数</strong>: 也叫可变参数, 用于不确定调用的时候会传递多少个参数.</p>
</li>
</ol>
<p>(1) 位置传递:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">*arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&quot;男&quot;</span>,<span class="string">&quot;TOM&quot;</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure></div>
<p>传进的参数会被args变量收集, 成为一个元组.</p>
<p>(2) 关键字传递:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line">user_info(gender=<span class="string">&quot;男&quot;</span>,name=<span class="string">&quot;TOM&quot;</span>,age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure></div>
<p>传进的参数会被kwargs变量收集, 成为一个”键&#x3D;值”的字典.</p>
<h4 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h4><p>传入函数的不仅可以是数据, 也可以是计算逻辑.  </p>
<p>传入数据:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></div>

<p>传入一个计算逻辑(函数):</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">add</span>):</span><br><span class="line">    result = add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></div>

<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>函数的返回值能在函数执行完毕后, 返回 <strong>给调用者</strong> 结果.</p>
<ul>
<li>注意: 函数体在遇到return后就结束了, 不会执行return后的代码.</li>
</ul>
<p>当函数没有使用return语句返回数据时, 会返回 <strong>字面量 None</strong>,   </p>
<blockquote>
<p>无返回值的函数, 返回的内容是: None<br>无返回值的函数, 返回的内容类型是: &lt;class ‘NoneType’&gt;</p>
</blockquote>
<p>表示空的, 没有意义.</p>
<p>在if判断中, None等同于False  </p>
<ul>
<li><strong>多个返回值</strong></li>
</ul>
<p>要使函数返回多个返回值, 可以用逗号分隔.</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_return</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"></span><br><span class="line">x,y,z = test_return()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span>,<span class="subst">&#123;y&#125;</span>,<span class="subst">&#123;z&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>变量的作用域指的是变量的<strong>作用范围</strong>.<br>主要分为两类: <strong>局部变量</strong> 和 <strong>全局变量</strong></p>
<ol>
<li><strong>局部变量</strong></li>
</ol>
<p>定义在函数体内部的变量, 只在函数体内部生效  </p>
<p>能在函数体内部临时保存数据, 函数调用完后销毁</p>
<ol start="2">
<li><strong>全局变量</strong></li>
</ol>
<p>能在函数体内外都能生效的变量.</p>
<ol start="3">
<li><strong>global关键字</strong></li>
</ol>
<p>可以让函数内定义的局部变量转换为全局变量以修改.</p>
<h1 id="Python-数据容器"><a href="#Python-数据容器" class="headerlink" title="Python 数据容器"></a>Python 数据容器</h1><p>数据容器是能够存储多个元素的Python数据类型</p>
<p><strong>list [列表]</strong><br><strong>tuple (元组)</strong><br><strong>str “字符串”</strong><br><strong>set {集合}</strong><br><strong>dict(字典)</strong>  </p>
<p>它们各自有各自的特点</p>
<h2 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字面量</span></span><br><span class="line">[元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,元素<span class="number">4</span>,...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义变量</span></span><br><span class="line">变量名称 = [元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,元素<span class="number">4</span>,...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义空列表</span></span><br><span class="line">变量名称 = []</span><br><span class="line">变量名称 = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure></div>

<p>元素的数据类型没有任何限制, 甚至元素也可以是列表, 这样就定义了嵌套列表</p>
<h3 id="列表的下标索引"><a href="#列表的下标索引" class="headerlink" title="列表的下标索引"></a>列表的下标索引</h3><p>列表的每个元素, 都有编号称之为下标索引</p>
<p>从前向后看, 下标索引从 <strong>0 开始递增.</strong><br>从后向前看, 下标索引从 <strong>-1开始递减.</strong></p>
<p><code>列表名称[ 下标 ]</code>即可使用下标索引取出元素</p>
<h3 id="列表的方法"><a href="#列表的方法" class="headerlink" title="列表的方法"></a>列表的方法</h3><p>把一个函数封装到类当中, 这个函数就会被称作为 <strong>方法</strong></p>
<ul>
<li><p>查找某元素的下标<br><code>列表. index(要查找的元素)</code></p>
</li>
<li><p>修改特定下标索引的值<br><code>列表[下标] = 要修改的值</code></p>
</li>
<li><p>插入元素<br><code>列表.insert(下标, 插入的元素)</code></p>
</li>
<li><p>追加元素(到末尾)<br><code>列表.append(要插入的元素)</code><br>也可以批量追加元素:<br><code>列表.extend(其他数据容器)</code></p>
</li>
<li><p>删除元素(匹配下标)<br><code>del列表[下标]</code><br>也可以通过pop取出元素达到删除效果:<br><code>列表.pop(下标)</code><br>pop能得到取出的元素.</p>
</li>
<li><p>删除匹配(指定)的元素<br><code>列表.remove(元素)</code><br>只能删掉第一个匹配的元素.</p>
</li>
<li><p>清空<br><code>列表.clear()</code></p>
</li>
<li><p>统计指定元素在列表内的数量<br><code>列表.count(元素)</code></p>
</li>
<li><p>统计列表内总元素个数<br><code>len(列表)</code></p>
</li>
</ul>
<h3 id="列表的特点"><a href="#列表的特点" class="headerlink" title="列表的特点"></a>列表的特点</h3><ul>
<li>可以容纳 <strong>多个, 类型不同</strong> 的元素</li>
<li>元素是 <strong>有序存储</strong> 的</li>
<li>允许 <strong>增加删除</strong> 元素, 允许 <strong>重复数据</strong> 存在.</li>
</ul>
<h3 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h3><ol>
<li>while 循环</li>
</ol>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="built_in">len</span>(列表):</span><br><span class="line">    元素 = 列表[index]</span><br><span class="line">    对元素进行处理</span><br><span class="line">    index += <span class="number">1</span></span><br></pre></td></tr></table></figure></div>
<p>while循环更灵活</p>
<ol start="2">
<li>for 循环</li>
</ol>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 数据容器:</span><br><span class="line">    对临时变量进行处理</span><br></pre></td></tr></table></figure></div>
<p>for循环更简单</p>
<h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h2><p>定义完成后, 就不可修改. 其他特点与列表类似.</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义元组字面量</span></span><br><span class="line">(元素,元素,...,元素,)</span><br><span class="line"><span class="comment"># 定义元组变量</span></span><br><span class="line">变量名称 = (元素,元素,...,元素,)</span><br><span class="line"><span class="comment"># 定义空元组</span></span><br><span class="line">变量名称 = () <span class="comment"># 方式1</span></span><br><span class="line">变量名称 = <span class="built_in">tuple</span>() <span class="comment">#方式2</span></span><br></pre></td></tr></table></figure></div>

<p>虽然元组元素不能修改, 但是元组嵌套中的列表能修改.</p>
<h3 id="元组的方法"><a href="#元组的方法" class="headerlink" title="元组的方法"></a>元组的方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>元组.index(&quot;元素&quot;)</code></td>
<td>查找某个数据, 如果数据存在返回对应的下标, 否则报错</td>
</tr>
<tr>
<td><code>元组.count(&quot;元素&quot;)</code></td>
<td>统计某个数据在当前元组出现的次数</td>
</tr>
<tr>
<td><code>len(元组)</code></td>
<td>统计元组内的元素个数</td>
</tr>
</tbody></table>
<h2 id="字符串-str"><a href="#字符串-str" class="headerlink" title="字符串(str)"></a>字符串(str)</h2><p>是字符的容器, 一个字符串可以存放任意数量的字符.</p>
<p>字符串同元组一样, 是 <strong>无法修改</strong> 的数据容器.</p>
<h3 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h3><ul>
<li><p>字符串的替换<br><code>字符串.replace(字符串1, 字符串2)</code><br>能将老字符串替换成一个新的字符串</p>
</li>
<li><p>字符串分割<br><code>字符串.split(分隔符字符)</code><br>字符串本身不变, 得到一个新的列表对象</p>
</li>
<li><p>字符串规整操作<br><code>字符串.strip()</code> 去掉前后空格<br><code>字符串.strip(字符串)</code> 去掉前后指定字符串</p>
</li>
<li><p>统计字符串某个字符串的出现次数<br><code>字符串.count(&quot;字符串&quot;)</code></p>
</li>
<li><p>统计字符串长度<br><code>len(字符串)</code></p>
</li>
</ul>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>内容连续, 有序, 可使用下标索引的一类数据容器.  </p>
<p>列表, 元组, 字符串, 均可视为序列.</p>
<h3 id="序列的常用操作"><a href="#序列的常用操作" class="headerlink" title="序列的常用操作"></a>序列的常用操作</h3><ul>
<li>切片<br><code>序列[起始下标:结束下标:步长]</code><br>从一个序列中, 取出一个子序列, 会得到一个新字符串<br>步长表示取元素的间隔</li>
</ul>
<p>起始下标不写 表示从头<br>结束下标不写 表示到尾<br>步长为负 表示倒序</p>
<h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h2><p>不支持元素重复(自带去重功能), 并且内容无序.</p>
<p>内容无序, 导致不支持下标索引访问.</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义集合字面量</span></span><br><span class="line">&#123;元素, 元素, ... , 元素&#125;</span><br><span class="line"><span class="comment"># 定义集合变量</span></span><br><span class="line">变量名称 = &#123;元素, 元素, ... , 元素&#125;</span><br><span class="line"><span class="comment"># 定义空集合</span></span><br><span class="line">变量名称 = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure></div>

<h3 id="集合的常用操作"><a href="#集合的常用操作" class="headerlink" title="集合的常用操作"></a>集合的常用操作</h3><ul>
<li><p>添加新元素<br><code>集合.add(元素)</code><br>将指定元素, 添加到集合内.<br>修改集合本身, 添加了新元素.</p>
</li>
<li><p>移除元素<br><code>集合.remove</code><br>将指定元素, 从集合中移除.<br>集合本身被修改, 移除了元素.</p>
</li>
<li><p>从集合中随机取出元素<br><code>集合.pop</code><br>由于集合无序, 无法指定取出. 因此达到随机取出的效果.<br>集合本身被修改, 元素被移除.</p>
</li>
<li><p>清空集合<br><code>集合.clear</code></p>
</li>
<li><p>取出2个集合的差集<br><code>集合1.difference(集合2)</code><br>原集合1,2不变, 得到一个新集合.</p>
</li>
<li><p>消除2个集合的差集<br><code>集合1.difference_updata(集合2)</code><br>集合1被修改, 集合2不变.</p>
</li>
<li><p>2个集合合并<br><code>集合1.union(集合2)</code><br>原集合1,2不变, 得到一个新集合.</p>
</li>
<li><p>统计元素个数<br><code>len(集合)</code></p>
</li>
</ul>
<h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><p>由于无序, 因此不支持while循环.  </p>
<p>但支持for循环遍历:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> 集合:</span><br><span class="line">    要对element的操作</span><br></pre></td></tr></table></figure></div>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义字典字面量</span></span><br><span class="line">&#123;key:value,key:value,...,key:value&#125;</span><br><span class="line"><span class="comment"># 定义字典变量</span></span><br><span class="line">my_dict = &#123;key:value,key:value,...,key:value&#125;</span><br><span class="line"><span class="comment"># 定义空字典</span></span><br><span class="line">my_dict = &#123;&#125;</span><br><span class="line">my_dict = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure></div>

<p>可以通过Key, 取到对应的Value.<br>存储的元素 Key:value 键值对.<br>不支持下标索引.</p>
<blockquote>
<p>字典嵌套:</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>语文</th>
<th>数学</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>95</td>
<td>92</td>
</tr>
<tr>
<td>李四</td>
<td>94</td>
<td>98</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">  socre_dict = &#123;</span><br><span class="line">   <span class="string">&quot;张三&quot;</span>:&#123;</span><br><span class="line">          <span class="string">&quot;语文&quot;</span>:<span class="number">95</span></span><br><span class="line">          <span class="string">&quot;数学&quot;</span>:<span class="number">92</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h3 id="字典的常用操作"><a href="#字典的常用操作" class="headerlink" title="字典的常用操作"></a>字典的常用操作</h3><ul>
<li><p>新增&#x2F;更新元素<br><code>字典[Key] = Value</code><br>对已经存在的Key执行, 就会更新Value值.</p>
</li>
<li><p>删除元素<br><code>字典.pop(Key)</code>  </p>
</li>
<li><p>清空元素<br><code>字典.clear()</code></p>
</li>
<li><p>获取全部的key<br><code>字典.keys()</code></p>
</li>
</ul>
<p>遍历字典  </p>
<p>第一种方法:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">keys = my_dict.keys()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    要执行的操作</span><br></pre></td></tr></table></figure></div>

<p>第二种方法:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> my_dict:</span><br><span class="line">    要执行的操作</span><br></pre></td></tr></table></figure></div>

<ul>
<li>统计字典内元素数量:<br><code>len(字典)</code></li>
</ul>
<h2 id="数据容器总结"><a href="#数据容器总结" class="headerlink" title="数据容器总结"></a>数据容器总结</h2><p>数据容器可以从以下视角进行简单分类:  </p>
<ul>
<li><p><strong>是否支持下标索引</strong><br>序列类型(支持): 列表, 元组, 字符串<br>非序列类型(不支持):集合, 字典</p>
</li>
<li><p><strong>是否支持重复元素</strong><br>序列类型(支持): 列表, 元组, 字符串<br>非序列类型(不支持):集合, 字典</p>
</li>
<li><p><strong>是否可以修改</strong><br>支持: 列表, 集合, 字典<br>不支持: 元组, 字符串</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>列表</th>
<th>元组</th>
<th>字符串</th>
<th>集合</th>
<th>字典</th>
</tr>
</thead>
<tbody><tr>
<td>元素类型</td>
<td>任意</td>
<td>任意</td>
<td>仅字符</td>
<td>任意</td>
<td>key:除字典外任意类型 <br> value:任意类型</td>
</tr>
<tr>
<td>下标索引</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>重复元素</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>不支持</td>
<td>key不支持</td>
</tr>
<tr>
<td>可修改性</td>
<td>-</td>
<td>不支持</td>
<td>不支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>数据有序</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>无序</td>
<td>无序</td>
</tr>
<tr>
<td>使用场景</td>
<td>可修改的, <br>带重复的数据记录</td>
<td>不可修改, <br>带重复的数据记录</td>
<td>一串字符的记录</td>
<td>去重的数据记录</td>
<td>以Key检索Value的记录</td>
</tr>
</tbody></table>
<h1 id="Python-文件操作"><a href="#Python-文件操作" class="headerlink" title="Python 文件操作"></a>Python 文件操作</h1><p>文件操作步骤分为: 打开, 读写, 关闭</p>
<h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><p><code>open(name,mode,encoding)</code><br>name: 文件的名称&#x2F;路径<br>mode: 有只读(r), 写入(w), 追加(a)等.<br>encoding: 编码格式(推荐使用UTF-8)  </p>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><ol>
<li><p>read()方法<br><code>文件对象.read(num)</code><br>num表示要从文件中读取的数据的长度(单位是字节), 如果省略, 就会读取文件中所有的数据.</p>
</li>
<li><p>readlines()方法<br><code>文件对象.readlines()</code><br>readlines可以按照行的方式把整个文件一次性读取, 返回一个列表, 其中每一行的数据为一个元素.</p>
</li>
<li><p>readline()方法<br><code>文件对象.readline()</code><br>一次读取一行内容</p>
</li>
</ol>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p><code>文件对象.write(&quot;写入内容&quot;)</code></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f.write(hello world)</span><br><span class="line"></span><br><span class="line">f.flush()</span><br></pre></td></tr></table></figure></div>
<p>为避免频繁操作硬盘而导致效率低, 内容会先积攒到程序的内存中(缓冲区), 当调用flush时, 内容才会真正写进文件.<br>.close()方法也会自带.flush()方法  </p>
<p>w模式下写入时, 文件不存在, 会创建新文件. 文件存在, 会清空原有内容.</p>
<h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><p>方法同w, 有:</p>
<p>wirte(), 写入内容<br>flush(), 刷新内容到硬盘</p>
<p>a同w, 文件不存在, 会创建新文件. 不同的是:文件存在, 会在原有内容后继续写入.</p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><ol>
<li><p><code>文件对象.close()</code><br>解除文件占用</p>
</li>
<li><p><code>with open() as 文件对象</code><br>自动关闭文件</p>
</li>
</ol>
<h1 id="Python-异常"><a href="#Python-异常" class="headerlink" title="Python 异常"></a>Python 异常</h1><h3 id="异常处理-捕获异常"><a href="#异常处理-捕获异常" class="headerlink" title="异常处理&#x2F;捕获异常"></a>异常处理&#x2F;捕获异常</h3><p>基本语法:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能发生错误的代码</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    如果出现异常要执行的代码</span><br><span class="line"></span><br><span class="line"><span class="comment"># [ ]中括号代表代码可选</span></span><br><span class="line">[<span class="keyword">else</span>:]</span><br><span class="line">    没有异常时执行的代码</span><br><span class="line"></span><br><span class="line">[<span class="keyword">finally</span>:]</span><br><span class="line">    无论是否异常, 都会执行的代码</span><br></pre></td></tr></table></figure></div>

<p>若要捕获指定的异常:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">except</span> 错误类型 <span class="keyword">as</span> e(别名):</span><br><span class="line">    出现异常要执行的操作</span><br></pre></td></tr></table></figure></div>

<p>若要捕获多个异常, 可以通过元组书写:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">except</span> (错误类型<span class="number">1</span>,错误类型<span class="number">2</span>) <span class="keyword">as</span> e:</span><br><span class="line">    出现异常要执行的操作</span><br></pre></td></tr></table></figure></div>

<p>捕获所有异常:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    出现异常要执行的操作</span><br></pre></td></tr></table></figure></div>

<p>异常具有传递性.</p>
<h1 id="Python-模块"><a href="#Python-模块" class="headerlink" title="Python 模块"></a>Python 模块</h1><p>是一个Python文件(以.py结尾), 里面有类, 函数, 变量等. 我们可以导入模块使用.</p>
<p>导入方式:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">from</span> 模块名] <span class="keyword">import</span> [模块|类|变量|函数|*][<span class="keyword">as</span> 别名]</span><br><span class="line"></span><br><span class="line"><span class="comment">#import会导入整个模块, 通过 . 能使用其中所有功能</span></span><br><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span>, 模块名<span class="number">2</span></span><br><span class="line">模块名.功能名()</span><br><span class="line"></span><br><span class="line"><span class="comment">#form import 能具体导入某个功能</span></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 功能名</span><br><span class="line">功能名()</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 * 导入模块的全部功能, 只是写法不同而已. </span></span><br><span class="line">form 模块名 <span class="keyword">import</span> *</span><br><span class="line">功能名()</span><br></pre></td></tr></table></figure></div>
<p>如果使用这种方式导入, 模块文件含有<code>__all__</code>变量, 就只会导入列表all中记录的元素:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [函数<span class="number">1</span>,函数<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">函数<span class="number">1</span></span><br><span class="line"></span><br><span class="line">函数<span class="number">2</span></span><br><span class="line"></span><br><span class="line">函数<span class="number">3</span></span><br><span class="line"><span class="comment"># 只会导入 1 和 2</span></span><br></pre></td></tr></table></figure></div>
<h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><p>新建一个<code>my_module1.py</code>的文件,内容如下:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure></div>

<p>在另一个文件中,使用这个Python模块:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> my_module1</span><br><span class="line"></span><br><span class="line">my_module1.test(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure></div>

<p>当导入两个同名的模块时, 后调用的会覆盖先调用的.</p>
<p>如果想让模块调用时不执行, 而在测试时执行, 可以添加:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">导入模块要执行的代码</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    导入模块不会执行的代码</span><br></pre></td></tr></table></figure></div>

<h3 id="Python-包"><a href="#Python-包" class="headerlink" title="Python 包"></a>Python 包</h3><p>本质是一个包含 <code>__init__.py</code> 文件的文件夹, 能存放模块.</p>
<p>没有 <code>__init__.py</code> ,就不是包.</p>
<p>在Python程序的生态中, 有许多第三方包,例如: </p>
<ul>
<li>科学计算的 numpu 包</li>
<li>数据分析的 pandas 包</li>
<li>大数据计算的 pyspark apache-flink 包</li>
<li>图形可视化的 matplotlib pyrcharts</li>
<li>人工智能的 tensorflow</li>
<li>等等</li>
</ul>
<h4 id="安装第三方包"><a href="#安装第三方包" class="headerlink" title="安装第三方包"></a>安装第三方包</h4><p>使用Python内置的pip程序, 在命令提示符中输入:</p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install 包名称</span><br></pre></td></tr></table></figure></div>
<p>即可通过网络安装包.</p>
<h4 id="优化下载的方法"><a href="#优化下载的方法" class="headerlink" title="优化下载的方法"></a>优化下载的方法</h4><p>让其链接国内的网站进行下载</p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">pip instal -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://pypi.tuna.tsinghua.edu.cn/simple" >https://pypi.tuna.tsinghua.edu.cn/simple<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 是清华大学提供的一个网站, 可供pip程序下载第三方包.</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="数据的组织"><a href="#数据的组织" class="headerlink" title="数据的组织"></a>数据的组织</h3><p>生活中, 可以设计一个表格, 将数据整齐地统计出来, 在程序中也有相同的思路.</p>
<ol>
<li>在程序中设计表格, 称之为: <strong>设计类(class)</strong></li>
<li>在程序中打印生产表格, 称之为: <strong>创建对象</strong></li>
<li>在程序中填写表格, 称之为: <strong>对象属性赋值</strong></li>
</ol>
<h3 id="类的定义和使用"><a href="#类的定义和使用" class="headerlink" title="类的定义和使用"></a>类的定义和使用</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># classs是关键字, 表示要定义类了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">类名称</span>:</span><br><span class="line">    <span class="comment"># 类的属性: 定义在类中的变量(成员变量)</span></span><br><span class="line">    name = <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类的行为: 定义在类中的函数(成员方法)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>self关键字是成员方法定义时, 必须填写.<br>它用来表示类对象自身的意思.<br>在方法内部, 想要访问类的成员变量, 必须使用self.</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>基于类创建对象的语法: <code>对象名 = 类名称()</code>  </p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:</span><br><span class="line">    name = <span class="literal">None</span></span><br><span class="line">    age = <span class="literal">None</span></span><br><span class="line">    fur = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">wolf1 = Wolf()</span><br><span class="line">wolf1.name = <span class="string">&quot;沃里克&quot;</span></span><br><span class="line">wolf1.age = <span class="number">31</span></span><br><span class="line">wolf1.fur = <span class="string">&quot;gray&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(wolf1.name)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>Python类也可以使用:  <code>__init__</code> (方法)构造方法  </p>
<p>能使创建类对象 (构造类) 的时候, 会自动执行.<br>在创建类对象 (构造类) 的时候, 将传入参数自动传递给 <code>__init__</code> 方法使用</p>
<p>例如:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, tel</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">        <span class="variable language_">self</span>.fur = fur</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;此构造方法会自动执行&quot;</span>)</span><br><span class="line"></span><br><span class="line">Wolf1 = Wolf(<span class="string">&quot;沃里克&quot;</span>, <span class="number">31</span>, <span class="string">&quot;gray&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(wolf1.name)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<h3 id="常用的类内置方法"><a href="#常用的类内置方法" class="headerlink" title="常用的类内置方法"></a>常用的类内置方法</h3><p>除了 <code>__init__</code> 构造方法外, Python类中还有其他的类内置方法.<br>这些内置的类方法, 各有各自特殊的功能, 这些内置方法我们称之为: <strong>魔术方法</strong></p>
<h4 id="str-字符串方法"><a href="#str-字符串方法" class="headerlink" title="__str__ 字符串方法"></a><code>__str__</code> 字符串方法</h4><p>当类对象需要被转换为字符串之时: </p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">wolf1 = Wolf(<span class="string">&quot;沃里克&quot;</span>, gray)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(wolf1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(wolf1)) <span class="comment">#输出地址值, 没什么实际作用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>会输出内存地址.<br>我们可以通过 <code>__str__</code> 方法, 控制类转换为指定的字符串</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;有一只名叫<span class="subst">&#123;self.name&#125;</span>的<span class="subst">&#123;self.fur&#125;</span>毛狼!&quot;</span></span><br><span class="line"></span><br><span class="line">wolf1 = Wolf(<span class="string">&quot;沃里克&quot;</span>, gray)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(wolf1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(wolf1)) <span class="comment">#会按照__str__设定的输出.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="lt-小于大于符号比较方法"><a href="#lt-小于大于符号比较方法" class="headerlink" title="__lt__小于大于符号比较方法"></a><code>__lt__</code>小于大于符号比较方法</h4><p>无法直接对两个对象进行比较.<br>但使用 <code>__lt__</code> 方法, 可以同时完成 大于和小于 的比较.</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.age &lt; other.age</span><br><span class="line"></span><br><span class="line">wolf1 = Wolf(<span class="string">&quot;沃里克&quot;</span>, <span class="number">31</span>)</span><br><span class="line">wolf2 = Wolf(<span class="string">&quot;布莱泽&quot;</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(wolf1 &lt; wolf2) <span class="comment">#返回 false</span></span><br><span class="line"><span class="built_in">print</span>(wolf1 &gt; wolf2) <span class="comment">#返回 true </span></span><br></pre></td></tr></table></figure></div>

<p>而小于等于大于等于可以使用: <code>__le__</code><br>同理, 判断两个对象是否相等: <code>__eq__</code><br>用法都同 <code>__lt__</code></p>
<h1 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h1><p>面向对象编程, 是许多编程语言都支持的一种编程思想.<br>简单理解就是: 基于模板 (类) 去创建实体对象 (对象), 使对象完成功能开发.</p>
<p>面向对象包含 3 大主要特性:</p>
<ol>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ol>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装表示将现实世界事物的:</p>
<ul>
<li>属性</li>
<li>行为</li>
</ul>
<p>封装到类中, 称为:</p>
<ul>
<li>成员变量</li>
<li>成员方法</li>
</ul>
<p>从而完成程序对现实世界事物的描述</p>
<h3 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h3><p>有的属性呵行为不公开, 我没将其称之为私有成员形式, 定义私有成员的方式非常简单, 只要:</p>
<ul>
<li>私有成员变量: 变量名以__开头(2个下划线)</li>
<li>私有成员方法: 方法名以__开头(2个下划线)</li>
</ul>
<p>私有成员只能被内部类中的其他成员访问.</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><blockquote>
<p>wow! 基础学完力!<br>不过速通疏漏还挺多, 继续加油吧!</p>
</blockquote>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>入门基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2024/06/23/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式是用特殊字符组合描述文本规则的强大工具.<br>在 Java 中，正则表达式是通过 <code>str.matches(正则表达式规则)</code> 来实现的。</p>
<p>以下是核心语法和案例：</p>
<h3 id="中括号表达式"><a href="#中括号表达式" class="headerlink" title="[] 中括号表达式"></a><code>[]</code> 中括号表达式</h3><p>匹配中括号中的任意一个字符.</p>
<ul>
<li><code>[a-z]</code>  表示字母 a 到 z 的范围</li>
<li><code>[^abc]</code>  表示排除 a&#x2F;b&#x2F;c 的任意字符</li>
<li><code>^</code>  在中括号内表示”排除”</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配单个元音字母</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[aeiou]&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配非数字字符</span></span><br><span class="line">System.out.println(<span class="string">&quot;k&quot;</span>.matches(<span class="string">&quot;[^0-9]&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配 1 个大写字母或数字</span></span><br><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>.matches(<span class="string">&quot;[A-Z0-9]&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="转义字符与元字符"><a href="#转义字符与元字符" class="headerlink" title="\ 转义字符与元字符"></a><code>\</code> 转义字符与元字符</h3><p>转义字符将其后紧跟的字符标记为有特殊含义的<strong>元字符</strong>（Metacharacter）</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>作用</th>
<th>Java 正则写法</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>匹配任意字符（除换行符）</td>
<td><code>\\.</code></td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配数字</td>
<td><code>\\d</code></td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配非数字</td>
<td><code>\\D</code></td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配字母、数字、下划线</td>
<td><code>\\w</code></td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配非单词字符</td>
<td><code>\\W</code></td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配空格、制表符等</td>
<td><code>\\s</code></td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配单词边界</td>
<td><code>\\b</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查字符串是否为 3 位数字</span></span><br><span class="line">System.out.println(<span class="string">&quot;123&quot;</span>.matches(<span class="string">&quot;\\d&#123;3&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 判断是否包含非数字字符</span></span><br><span class="line">System.out.println(<span class="string">&quot;a1&quot;</span>.matches(<span class="string">&quot;.*\\D.*&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配以 &quot;cat&quot; 结尾的单词（需用 \\b 表示边界）</span></span><br><span class="line">System.out.println(<span class="string">&quot;bobcat&quot;</span>.matches(<span class="string">&quot;.*\\bcat&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><h4 id="1-模糊限定符"><a href="#1-模糊限定符" class="headerlink" title="1. 模糊限定符"></a>1. 模糊限定符</h4><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>匹配 0 次或多次</td>
<td><code>a*</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配 1 次或多次</td>
<td><code>\\d+</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配 0 次或 1 次</td>
<td><code>xyz?</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配以 a 开头，后跟 0 或多个 b 的字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;abbb&quot;</span>.matches(<span class="string">&quot;ab\*&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配至少 1 位数字</span></span><br><span class="line">System.out.println(<span class="string">&quot;7&quot;</span>.matches(<span class="string">&quot;\\d+&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配 &quot;http&quot; 或 &quot;https&quot;</span></span><br><span class="line">System.out.println(<span class="string">&quot;https&quot;</span>.matches(<span class="string">&quot;https?&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-精确限定符"><a href="#2-精确限定符" class="headerlink" title="2. 精确限定符"></a>2. 精确限定符</h4><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;n&#125;</code></td>
<td>匹配恰好 n 次</td>
<td><code>a&#123;3&#125;</code></td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td>匹配至少 n 次</td>
<td><code>\\d&#123;2,&#125;</code></td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td>匹配至少 n 次，至多 m 次</td>
<td><code>a&#123;2,4&#125;</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配 3 位区号 + 8 位数字的电话号码</span></span><br><span class="line">System.out.println(<span class="string">&quot;010-12345678&quot;</span>.matches(<span class="string">&quot;\\d&#123;3&#125;-\\d&#123;8&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配 2~4 个连续字母 a</span></span><br><span class="line">System.out.println(<span class="string">&quot;aaa&quot;</span>.matches(<span class="string">&quot;a&#123;2,4&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配至少 5 位数字</span></span><br><span class="line">System.out.println(<span class="string">&quot;12345&quot;</span>.matches(<span class="string">&quot;\\d&#123;5,&#125;&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><ol>
<li>邮箱格式验证</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[a-zA-Z0-9]+@[a-z]+\\.[a-z]&#123;2,3&#125;&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;test@mail.com&quot;</span>.matches(regex)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>日期格式验证（YYYY-MM-DD）</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;\\d&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;2023-10-05&quot;</span>.matches(regex)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>计算机通识</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习</title>
    <url>/2025/01/05/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h3 id="操作系统的定义与特征"><a href="#操作系统的定义与特征" class="headerlink" title="操作系统的定义与特征"></a>操作系统的定义与特征</h3><ul>
<li><strong>定义</strong>：操作系统是<strong>计算机系统资源</strong>的管理者，处于裸机之上的第一层软件.</li>
<li><strong>特征</strong>：<ul>
<li><strong>并发性</strong></li>
<li><strong>共享性</strong></li>
<li><strong>虚拟性</strong></li>
<li><strong>不确定性</strong></li>
</ul>
</li>
</ul>
<h3 id="操作系统的基本类型"><a href="#操作系统的基本类型" class="headerlink" title="操作系统的基本类型"></a>操作系统的基本类型</h3><ul>
<li><strong>实时系统</strong>：对响应时间有严格要求，分为硬实时和软实时两种.</li>
<li><strong>分时系统</strong>：在一台主机上同时<strong>连接多台终端</strong>，允许多个用户同时使用计算机，但每个用户的响应时间会随着<strong>用户数的增加而变长</strong>.</li>
<li><strong>批处理系统</strong>：把多个作业同时提交给计算机，作业之间无须进行交互，系统按照一定的顺序依次执行作业.</li>
<li><strong>分布式系统</strong>：由<strong>多台</strong>计算机组成的系统.</li>
</ul>
<h3 id="单道与多道程序"><a href="#单道与多道程序" class="headerlink" title="单道与多道程序"></a>单道与多道程序</h3><ul>
<li><strong>单道程序</strong>：内存中只有一个程序，CPU 与 I&#x2F;O 设备串行工作，即在一个程序的输入、计算和输出阶段完成后，才能开始下一个程序的执行.</li>
<li><strong>多道程序</strong>：<ul>
<li><strong>宏观上并行</strong> <strong>微观上串行</strong></li>
<li><strong>实现前提</strong>：系统具有<strong>中断功能</strong></li>
<li><strong>资源分配单位</strong>：操作系统是以<strong>进程</strong>为单位分配资源的.</li>
</ul>
</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>假设程序 P1、P2 和 P3 的执行时间如下：</p>
<ul>
<li><strong>P1</strong>: 输入 5ms，计算 3ms，输出 4ms.</li>
<li><strong>P2</strong>: 输入 4ms，计算 1ms，输出 3ms.</li>
<li><strong>P3</strong>: 输入 5ms，计算 3ms，输出 4ms.</li>
</ul>
<ol>
<li>在单道批处理环境下，计算完成 3 道程序运行需要的最少时间。</li>
<li>在多道批处理环境下，计算完成 3 道程序运行需要的最少时间。</li>
</ol>
<h4 id="单道批处理环境"><a href="#单道批处理环境" class="headerlink" title="单道批处理环境"></a>单道批处理环境</h4><ul>
<li>输入时间：5 + 4 + 5 &#x3D; 14 ms</li>
<li>计算时间：3 + 1 + 3 &#x3D; 7 ms</li>
<li>输出时间：4 + 3 + 4 &#x3D; 11 ms</li>
</ul>
<p>总时间 &#x3D; 14 + 7 + 11 &#x3D; 32 ms</p>
<h4 id="多道批处理环境"><a href="#多道批处理环境" class="headerlink" title="多道批处理环境"></a>多道批处理环境</h4><ul>
<li>输入时间：5 + 4 + 5 &#x3D; 14 ms</li>
<li>计算时间：最长的计算时间是 3ms</li>
<li>输出时间：4 + 3 + 4 &#x3D; 11 ms</li>
</ul>
<p>总时间 &#x3D; 14 + 3 + 11 &#x3D; 28 ms</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h3 id="程序并发执行的特征"><a href="#程序并发执行的特征" class="headerlink" title="程序并发执行的特征"></a>程序并发执行的特征</h3><ul>
<li><strong>间断性</strong></li>
<li><strong>失去了封闭性</strong></li>
<li><strong>不可再现性</strong></li>
</ul>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul>
<li>定义：是指<strong>宏观上可同时执行的进程</strong>，即多个进程在时间上交替执行，从宏观上看它们是同时进行的，但实际上是交替占用 CPU 资源的.</li>
<li><strong>并发执行的程序具有不可再现性</strong>，因为它们的执行结果可能受到其他并发程序的影响，且执行顺序和时间不确定.</li>
<li><strong>并发进程之间可能需要同步或互斥</strong>，以协调它们之间的执行顺序或防止对共享资源的冲突访问.</li>
</ul>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul>
<li>多道程序环境中操作系统分配资源是以<strong>进程</strong>为单位的，进程是程序在执行过程中的动态实体，拥有独立的地址空间和系统资源.</li>
<li>操作系统用 <strong>PCB（进程控制块）</strong> 来管理与控制进程，PCB 记录了进程的运行状态、优先级、资源使用情况等信息.</li>
<li>管理和控制是通过<strong>原语</strong>来实现的，原语是操作系统提供的一组低级系统调用，用于创建、撤销、挂起、唤醒等进程操作.</li>
<li><strong>线程</strong>：是进程中的一个执行流，是 CPU 调度和执行的最小单位，线程之间共享进程的资源，但每个线程有自己的栈和寄存器等局部状态.</li>
<li>线程与进程的区别主要在于<strong>是否拥有独立的资源</strong>，进程拥有独立的地址空间和资源，而线程共享进程的资源，但有自己的局部状态.</li>
</ul>
<h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><ul>
<li><strong>同步</strong>：是指进程之间逻辑上的制约关系，即某些进程的执行必须等待其他进程完成某些操作后才能继续执行，以保证程序的逻辑正确性.</li>
<li><strong>互斥</strong>：是指同一时间内只能允许一个进程访问临界资源，临界区是访问临界资源的一段程序，通过互斥机制可以防止多个进程同时访问临界资源导致的数据不一致等问题.</li>
<li><strong>资源的有序分配策略</strong>：可以破坏循环等待资源条件，从而预防死锁的发生，例如按照资源编号顺序申请资源等.</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><strong>预防死锁</strong>：可以通过破坏死锁产生的四个必要条件之一来实现，这四个条件是互斥条件、请求和保持条件、不剥夺条件、循环等待条件.</li>
<li><strong>避免死锁</strong>：是避免系统进入不安全状态，即在资源分配过程中，始终确保系统处于安全状态，不会发生死锁，银行家算法是一种常用的避免死锁的算法，通过模拟资源分配过程来判断系统是否安全.</li>
</ul>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题 1"></a>例题 1</h2><p>系统有 4 个进程 P1、P2、P3、P4，它们的到达时间和服务时间（或处理时间）如下表所示：</p>
<table>
<thead>
<tr>
<th>进程名</th>
<th>到达时间</th>
<th>处理时间</th>
<th>开始时间</th>
<th>完成时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>P2</td>
<td>2</td>
<td>6</td>
<td>2</td>
<td>8</td>
</tr>
<tr>
<td>P3</td>
<td>4</td>
<td>4</td>
<td>10</td>
<td>14</td>
</tr>
<tr>
<td>P4</td>
<td>6</td>
<td>2</td>
<td>8</td>
<td>10</td>
</tr>
</tbody></table>
<ol>
<li>各个进程的周转时间？</li>
<li>所有进程的平均周转时间是多少？</li>
</ol>
<h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p>周转时间 &#x3D; 完成时间 - 到达时间</p>
<ul>
<li><strong>P1</strong>：周转时间 &#x3D; 2 - 0 &#x3D; 2</li>
<li><strong>P2</strong>：周转时间 &#x3D; 8 - 2 &#x3D; 6</li>
<li><strong>P3</strong>：周转时间 &#x3D; 14 - 4 &#x3D; 10</li>
<li><strong>P4</strong>：周转时间 &#x3D; 10 - 6 &#x3D; 4</li>
</ul>
<h4 id="平均周转时间"><a href="#平均周转时间" class="headerlink" title="平均周转时间"></a>平均周转时间</h4><p>平均周转时间 &#x3D; (所有进程的周转时间之和) &#x2F; (进程数)</p>
<ul>
<li>所有进程的周转时间之和 &#x3D; 2 + 6 + 10 + 4 &#x3D; 22</li>
<li>进程数 &#x3D; 4</li>
</ul>
<p>平均周转时间 &#x3D; 22 &#x2F; 4 &#x3D; 5.5</p>
<h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题 2"></a>例题 2</h2><p>假设系统中有 5 个进程 P1、P2、P3、P4 和 P5，有 3 种类型的资源 A、B 和 C。初始资源分配情况如下：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>已分配资源数量</th>
<th>最大资源需求量</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0 0 3</td>
<td>0 0 4</td>
</tr>
<tr>
<td>P2</td>
<td>0 7 5</td>
<td>0 6 0</td>
</tr>
<tr>
<td>P3</td>
<td>5 3 5</td>
<td>2 3 5</td>
</tr>
<tr>
<td>P4</td>
<td>0 2 0</td>
<td>0 6 6</td>
</tr>
<tr>
<td>P5</td>
<td>0 0 6</td>
<td>5 5 2</td>
</tr>
</tbody></table>
<p>初始可用资源数为 (x, y, z)。<br>请问当 x，y，z 取值分别为 0，5，8 和 1，5，2 时，系统是否处于安全状态？为什么？</p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><ol>
<li><p><strong>计算 Need 矩阵</strong>：<br>{Need} &#x3D; {最大资源需求量} - {已分配资源数量}</p>
<ul>
<li><strong>P1</strong>: Need &#x3D; (0 0 4) - (0 0 3) &#x3D; (0 0 1)</li>
<li><strong>P2</strong>: Need &#x3D; (0 6 0) - (0 7 5) &#x3D; (0 -1 -5)</li>
<li><strong>P3</strong>: Need &#x3D; (2 3 5) - (5 3 5) &#x3D; (-3 0 0)</li>
<li><strong>P4</strong>: Need &#x3D; (0 6 6) - (0 2 0) &#x3D; (0 4 6)</li>
<li><strong>P5</strong>: Need &#x3D; (5 5 2) - (0 0 6) &#x3D; (5 5 -4)</li>
</ul>
</li>
<li><p><strong>判断系统是否处于安全状态</strong>：</p>
<ul>
<li>从可用资源数开始，检查是否存在一个进程，其 Need 小于或等于可用资源数.</li>
<li>如果存在这样的进程，假设该进程获得资源并执行完毕，然后释放其所有资源，更新可用资源数.</li>
<li>重复上述步骤，直到所有进程都能获得资源并执行完毕，或者没有进程可以满足条件.</li>
</ul>
</li>
</ol>
<h4 id="当-x，y，z-取值分别为-0，5，8"><a href="#当-x，y，z-取值分别为-0，5，8" class="headerlink" title="当 x，y，z 取值分别为 0，5，8"></a>当 x，y，z 取值分别为 0，5，8</h4><ul>
<li>可用资源数 &#x3D; (0 5 8)</li>
<li>检查 Need 矩阵：<ul>
<li><strong>P1</strong>: Need(0 0 1) &lt;&#x3D; Available(0 5 8)？是的，因为 0 &lt;&#x3D; 0, 0 &lt;&#x3D; 5, 1 &lt;&#x3D; 8.</li>
<li>P1 可以执行，执行后释放资源，可用资源数变为 (0+0, 5+0, 8+3) &#x3D; (0 5 11).</li>
<li>此时，没有其他进程的 Need 可以被满足（P2、P3、P4、P5 的 Need 都包含负数或超过可用资源），因此系统处于不安全状态.</li>
</ul>
</li>
</ul>
<h4 id="当-x，y，z-取值分别为-1，5，2"><a href="#当-x，y，z-取值分别为-1，5，2" class="headerlink" title="当 x，y，z 取值分别为 1，5，2"></a>当 x，y，z 取值分别为 1，5，2</h4><ul>
<li>可用资源数 &#x3D; (1 5 2)</li>
<li>检查 Need 矩阵：<ul>
<li><strong>P1</strong>: Need(0 0 1) &lt;&#x3D; Available(1 5 2)？是的，因为 0 &lt;&#x3D; 1, 0 &lt;&#x3D; 5, 1 &lt;&#x3D; 2.</li>
<li>P1 可以执行，执行后释放资源，可用资源数变为 (1+0, 5+0, 2+3) &#x3D; (1 5 5).</li>
<li><strong>P3</strong>: Need(-3 0 0) &lt;&#x3D; Available(1 5 5)？是的，因为-3 &lt;&#x3D; 1, 0 &lt;&#x3D; 5, 0 &lt;&#x3D; 5.</li>
<li>P3 可以执行，执行后释放资源，可用资源数变为 (1+5, 5+3, 5+5) &#x3D; (6 8 10).</li>
<li>此时，所有进程的 Need 都可以被满足，因此系统处于安全状态.</li>
</ul>
</li>
</ul>
<h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题 3"></a>例题 3</h2><p>桌上有一个盘子，最多可存放两个水果。<br>妈妈向盘子中放苹果或桔子。<br>儿子专吃盘子中的桔子，女儿专吃盘子里的苹果。<br>取、放水果不能同时 进行。试用 PV 操作实现三个人的同步，并写出程序描述。</p>
<p>在这个问题中，我们需要使用信号量（semaphores）来实现妈妈、儿子和女儿之间的同步。信号量用于控制对共享资源的访问，确保在任何时刻只有一个操作可以进行。</p>
<h3 id="信号量说明"><a href="#信号量说明" class="headerlink" title="信号量说明"></a>信号量说明</h3><ul>
<li><strong>mutex</strong>：用于互斥访问盘子，初始值为 1.</li>
<li><strong>Sd</strong>：表示盘子中水果的总数，初始值为 2（因为盘子最多可放两个水果）.</li>
<li><strong>So</strong>：表示盘子中桔子的数量，初始值为 0.</li>
<li><strong>Sa</strong>：表示盘子中苹果的数量，初始值为 0.</li>
</ul>
<h3 id="操作说明"><a href="#操作说明" class="headerlink" title="操作说明"></a>操作说明</h3><ul>
<li><strong>P 操作</strong>（wait）：用于等待信号量的值大于 0，然后将其减 1，表示正在使用资源.</li>
<li><strong>V 操作</strong>（signal）：用于将信号量的值加 1，表示释放资源.</li>
<li><strong>mutex</strong>信号量用于互斥访问盘子，确保在任何时刻只有一个操作（放入或取出水果）可以进行.</li>
<li><strong>Sd</strong>信号量用于控制盘子的容量，确保盘子不会超过两个水果.</li>
<li><strong>So</strong>和<strong>Sa</strong>信号量分别用于同步桔子和苹果的数量，确保儿子和女儿能够正确地取出他们想要的水果.</li>
</ul>
<h3 id="程序描述"><a href="#程序描述" class="headerlink" title="程序描述"></a>程序描述</h3><h4 id="妈妈（Mother）"><a href="#妈妈（Mother）" class="headerlink" title="妈妈（Mother）"></a>妈妈（Mother）</h4><p>妈妈的任务是向盘子中放入水果（苹果或桔子），并确保盘子不会超过容量限制.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Mother</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 选择放入水果的类型</span></span><br><span class="line">        <span class="keyword">if</span> (放入桔子) &#123;</span><br><span class="line">            P(Sd);  <span class="comment">// 等待盘子有空位</span></span><br><span class="line">            P(mutex);  <span class="comment">// 获取对盘子的互斥访问</span></span><br><span class="line">            <span class="comment">// 放入桔子</span></span><br><span class="line">            V(mutex);  <span class="comment">// 释放对盘子的互斥访问</span></span><br><span class="line">            V(So);  <span class="comment">// 增加盘子中桔子的数量</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P(Sd);  <span class="comment">// 等待盘子有空位</span></span><br><span class="line">            P(mutex);  <span class="comment">// 获取对盘子的互斥访问</span></span><br><span class="line">            <span class="comment">// 放入苹果</span></span><br><span class="line">            V(mutex);  <span class="comment">// 释放对盘子的互斥访问</span></span><br><span class="line">            V(Sa);  <span class="comment">// 增加盘子中苹果的数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="儿子（Son）"><a href="#儿子（Son）" class="headerlink" title="儿子（Son）"></a>儿子（Son）</h4><p>儿子的任务是取出盘子中的桔子.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(So);  <span class="comment">// 等待盘子中有桔子</span></span><br><span class="line">        P(mutex);  <span class="comment">// 获取对盘子的互斥访问</span></span><br><span class="line">        <span class="comment">// 取出桔子</span></span><br><span class="line">        V(mutex);  <span class="comment">// 释放对盘子的互斥访问</span></span><br><span class="line">        V(Sd);  <span class="comment">// 增加盘子的空位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="女儿（Daughter）"><a href="#女儿（Daughter）" class="headerlink" title="女儿（Daughter）"></a>女儿（Daughter）</h4><p>女儿的任务是取出盘子中的苹果.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Daughter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(Sa);  <span class="comment">// 等待盘子中有苹果</span></span><br><span class="line">        P(mutex);  <span class="comment">// 获取对盘子的互斥访问</span></span><br><span class="line">        <span class="comment">// 取出苹果</span></span><br><span class="line">        V(mutex);  <span class="comment">// 释放对盘子的互斥访问</span></span><br><span class="line">        V(Sd);  <span class="comment">// 增加盘子的空位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="存储器原理"><a href="#存储器原理" class="headerlink" title="存储器原理"></a>存储器原理</h1><h2 id="例题-1-1"><a href="#例题-1-1" class="headerlink" title="例题 1"></a>例题 1</h2><p>如果页面访问序列 0、3、6、5、6、2、4、3、2、5，且进程开始执行时，内 存中没有页面（初始为空），若给该进程分配驻留集为 3 个物理块，如下所示： 使用先进先出（FIFO）置换算法和用 LRU 置换算法。</p>
<ol>
<li>缺页中断次数、页面置换次数、缺页率分别是多少？</li>
<li>如果进程开始执行前，将最开始的 3 页先装入内存，会产生多少次缺页中断？</li>
</ol>
<h3 id="页面置换算法的基本概念"><a href="#页面置换算法的基本概念" class="headerlink" title="页面置换算法的基本概念"></a>页面置换算法的基本概念</h3><p>在虚拟存储器中，当一个进程访问的页面不在内存中时，会发生缺页中断。此时，操作系统需要从磁盘中将该页面调入内存。如果内存已满，就需要选择一个页面将其置换出内存，以便为新页面腾出空间。页面置换算法就是用来决定哪个页面应该被置换出内存的规则.</p>
<h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><p>题目关键信息:</p>
<ul>
<li>页面访问序列为：0、3、6、5、6、2、4、3、2、5，内存块数为 3，初始时内存为空.</li>
</ul>
<h3 id="FIFO-算法（先进先出）"><a href="#FIFO-算法（先进先出）" class="headerlink" title="FIFO 算法（先进先出）"></a>FIFO 算法（先进先出）</h3><ul>
<li><strong>基本原理</strong>：FIFO 算法按照页面进入内存的顺序来决定置换顺序，即最早进入内存的页面最先被置换出.</li>
<li><strong>工作过程</strong>：<ol>
<li>当发生缺页中断时，检查内存中是否有空闲的内存块.</li>
<li>如果有空闲内存块，直接将缺失的页面装入空闲内存块中.</li>
<li>如果没有空闲内存块，选择最早进入内存的页面将其置换出，然后将缺失的页面装入该内存块中.</li>
</ol>
</li>
</ul>
<h4 id="FIFO-算法操作过程"><a href="#FIFO-算法操作过程" class="headerlink" title="FIFO 算法操作过程"></a>FIFO 算法操作过程</h4><ul>
<li>访问 0：缺页，装入内存块 1，内存状态：[0, -, -].</li>
<li>访问 3：缺页，装入内存块 2，内存状态：[0, 3, -].</li>
<li>访问 6：缺页，装入内存块 3，内存状态：[0, 3, 6].</li>
<li>访问 5：缺页，置换内存块 1（0 -&gt; 5），内存状态：[5, 3, 6].</li>
<li>访问 6：不缺页，内存状态：[5, 3, 6].</li>
<li>访问 2：缺页，置换内存块 2（3 -&gt; 2），内存状态：[5, 2, 6].</li>
<li>访问 4：缺页，置换内存块 3（6 -&gt; 4），内存状态：[5, 2, 4].</li>
<li>访问 3：缺页，置换内存块 1（5 -&gt; 3），内存状态：[3, 2, 4].</li>
<li>访问 2：不缺页，内存状态：[3, 2, 4].</li>
<li>访问 5：缺页，置换内存块 2（2 -&gt; 5），内存状态：[3, 5, 4].</li>
</ul>
<h3 id="LRU-算法（最近最少使用）"><a href="#LRU-算法（最近最少使用）" class="headerlink" title="LRU 算法（最近最少使用）"></a>LRU 算法（最近最少使用）</h3><ul>
<li><strong>基本原理</strong>：LRU 算法根据页面最近的使用情况来决定置换顺序，即最近最少使用的页面最先被置换出.</li>
<li><strong>工作过程</strong>：<ol>
<li>当发生缺页中断时，检查内存中是否有空闲的内存块.</li>
<li>如果有空闲内存块，直接将缺失的页面装入空闲内存块中.</li>
<li>如果没有空闲内存块，选择最后面的页面，即最久未被访问的页面将其置换出，然后将缺失的页面装入该内存块中.</li>
</ol>
</li>
</ul>
<h4 id="LRU-算法操作过程"><a href="#LRU-算法操作过程" class="headerlink" title="LRU 算法操作过程"></a>LRU 算法操作过程</h4><ul>
<li>访问 0：缺页，装入内存块 1，内存状态：[0, -, -].</li>
<li>访问 3：缺页，装入内存块 2，内存状态：[0, 3, -].</li>
<li>访问 6：缺页，装入内存块 3，内存状态：[0, 3, 6].</li>
<li>访问 5：缺页，置换内存块 1（0 -&gt; 5），内存状态：[5, 3, 6].</li>
<li>访问 6：不缺页，内存状态：[5, 3, 6].</li>
<li>访问 2：缺页，置换内存块 2（3 -&gt; 2），内存状态：[5, 2, 6].</li>
<li>访问 4：缺页，置换内存块 3（6 -&gt; 4），内存状态：[5, 2, 4].</li>
<li>访问 3：缺页，置换内存块 1（5 -&gt; 3），内存状态：[3, 2, 4].</li>
<li>访问 2：不缺页，内存状态：[3, 2, 4].</li>
<li>访问 5：缺页，置换内存块 2（2 -&gt; 5），内存状态：[3, 5, 4].</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>FIFO 算法</strong>：<ul>
<li>初始为空时：缺页中断次数&#x3D;8，页面置换次数&#x3D;5，缺页率&#x3D;80%.</li>
</ul>
</li>
<li><strong>LRU 算法</strong>：<ul>
<li>初始为空时：缺页中断次数&#x3D;8，页面置换次数&#x3D;5，缺页率&#x3D;80%.</li>
</ul>
</li>
</ul>
<h2 id="例题-2-1"><a href="#例题-2-1" class="headerlink" title="例题 2"></a>例题 2</h2><p>某虚拟存储器（采用请求页式存储管理）的用户空间共有 64 个页面，每页 1KB，内存 32KB。假定某用户作业的长度为 6 页，进程驻留集为 3 个内存块。<br>某时刻系统为用户的第 0、1、2 页分配的内存块号分别为 4、5、6。<br>假设逻辑地址(或虚拟地址)的访问序列 0A2DH、106FH、1A33H（H 表示十六进制），将 3 个逻辑地址转换成物理地址，若能够转换，则说明转换过程，并给出具体的物理地址;若不能转换，则说明原因。</p>
<p>题目关键信息:</p>
<ul>
<li>用户空间共有 64 个页面，每页 1KB.</li>
<li>内存为 32KB.</li>
<li>进程驻留集为 3 个内存块，系统为用户的第 0、1、2 页分配的内存块号分别为 4、5、6.</li>
<li>逻辑地址的访问序列：0A2DH、106FH、1A33H.</li>
</ul>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><ol>
<li><p><strong>确定页号和偏移量</strong>：</p>
<ul>
<li>由于每页 1KB，即(2^{10})字节，因此偏移量占 10 位.</li>
<li>用户空间有 64 个页面，即(2^6)页，因此页号占 6 位.</li>
</ul>
</li>
<li><p><strong>转换逻辑地址到物理地址</strong>：</p>
<ul>
<li>将逻辑地址转换为二进制形式.</li>
<li>分离出页号和偏移量，页号位于二进制表示的高位，偏移量位于低位.</li>
<li>检查页号是否合法（是否小于 64）.</li>
<li>检查该页是否已装入内存.<ul>
<li>如果该页已装入内存，将页号替换为对应的物理块号，拼接偏移量得到物理地址.</li>
<li>如果该页未装入内存，产生缺页中断.</li>
<li>如果页号不合法，访问越界.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="示例计算"><a href="#示例计算" class="headerlink" title="示例计算"></a>示例计算</h3><h4 id="逻辑地址-0A2DH"><a href="#逻辑地址-0A2DH" class="headerlink" title="逻辑地址 0A2DH"></a>逻辑地址 0A2DH</h4><ul>
<li><strong>转换为二进制</strong>：0A2DH &#x3D; 000010 1000101101B</li>
<li><strong>分离页号和偏移量</strong>：<ul>
<li>页号(高位) &#x3D; 000010B（或 2 号页）</li>
<li>偏移量(低位) &#x3D; 1000101101B</li>
</ul>
</li>
<li><strong>检查页号合法性</strong>：2 号页 &lt; 64，页号合法.</li>
<li><strong>检查内存块</strong>：2 号页已装入内存，对应物理块号为 6（0110B）.</li>
<li><strong>计算物理地址</strong>：将页号替换为对应的物理块号，物理地址 &#x3D; 011010 00101101B，即 1A2DH.</li>
</ul>
<h4 id="逻辑地址-106FH"><a href="#逻辑地址-106FH" class="headerlink" title="逻辑地址 106FH"></a>逻辑地址 106FH</h4><ul>
<li><strong>转换为二进制</strong>：106FH &#x3D; 000100 0001101111B</li>
<li><strong>分离页号和偏移量</strong>：<ul>
<li>页号(高位) &#x3D; 000100B（或 4 号页）</li>
<li>偏移量(低位) &#x3D; 00001101111B</li>
</ul>
</li>
<li><strong>检查页号合法性</strong>：4 号页 &lt; 64，页号合法.</li>
<li><strong>检查内存块</strong>：4 号页未装入内存，故产生缺页中断.</li>
</ul>
<h4 id="逻辑地址-1A33H"><a href="#逻辑地址-1A33H" class="headerlink" title="逻辑地址 1A33H"></a>逻辑地址 1A33H</h4><ul>
<li><strong>转换为二进制</strong>：1A33H &#x3D; 0001101000110011B</li>
<li><strong>分离页号和偏移量</strong>：<ul>
<li>页号 &#x3D; 000110B（或 6 号页）</li>
<li>偏移量 &#x3D; 001000110011B</li>
</ul>
</li>
<li><strong>检查页号合法性</strong>：6 号页 &lt; 64，页号合法.</li>
<li><strong>检查内存块</strong>：6 号页未装入内存，故产生缺页中断.</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li><strong>逻辑地址 0A2DH</strong>：可以转换为物理地址 1A2DH.</li>
<li><strong>逻辑地址 106FH</strong>：不能转换，因为该页未装入内存，产生缺页中断.</li>
<li><strong>逻辑地址 1A33H</strong>：不能转换，因为该页未装入内存，产生缺页中断.</li>
</ul>
<h2 id="例题-3-1"><a href="#例题-3-1" class="headerlink" title="例题 3"></a>例题 3</h2><p>假设一次内存的访问时间是 80ns,一次快表的访问时间是 10ns，采用最 近最久未使用（LRU）页面置换算法，处理一次缺页中断的平均时间是 200ns (包括更新快表和页表的时间）。<br>访问逻辑地址(或虚拟地址) 106FH 的物理地址和时间分别是多少？</p>
<p>题目关键信息:</p>
<ul>
<li>一次内存的访问时间是 80ns.</li>
<li>一次快表的访问时间是 10ns.</li>
<li>处理一次缺页中断的平均时间是 200ns (包括更新快表和页表的时间).</li>
<li>采用最近最久未使用（LRU）页面置换算法.</li>
</ul>
<h3 id="页表信息"><a href="#页表信息" class="headerlink" title="页表信息"></a>页表信息</h3><table>
<thead>
<tr>
<th>页号</th>
<th>内存块号</th>
<th>状态位</th>
<th>访问字段</th>
<th>装入内存时间</th>
<th>上次访问时间</th>
<th>修改位</th>
<th>外存地址</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>4</td>
<td>1</td>
<td>0:20:16</td>
<td>10:20:16</td>
<td>10:20:20</td>
<td>1</td>
<td>123</td>
</tr>
<tr>
<td>1</td>
<td>5</td>
<td>1</td>
<td>0:20:14</td>
<td>10:20:14</td>
<td>10:20:18</td>
<td>0</td>
<td>47</td>
</tr>
<tr>
<td>2</td>
<td>6</td>
<td>1</td>
<td>0:20:11</td>
<td>10:20:11</td>
<td>10:20:21</td>
<td>1</td>
<td>23</td>
</tr>
</tbody></table>
<h3 id="地址转换步骤"><a href="#地址转换步骤" class="headerlink" title="地址转换步骤"></a>地址转换步骤</h3><ol>
<li><p><strong>确定页号和偏移量</strong>：</p>
<ul>
<li>逻辑地址 106FH &#x3D; 000100 0001101111B.</li>
<li>页号 &#x3D; 000100B（或 4 号页）.</li>
<li>偏移量 &#x3D; 00001101111B.</li>
</ul>
</li>
<li><p><strong>检查页号合法性</strong>：</p>
<ul>
<li>4 号页 &lt; 6，不越界.</li>
</ul>
</li>
<li><p><strong>检查内存块</strong>：</p>
<ul>
<li>4 号页未装入内存，故产生缺页中断.</li>
</ul>
</li>
<li><p><strong>处理缺页中断</strong>：</p>
<ul>
<li>根据 LRU 置换算法，查表得应淘汰 1 号页.</li>
<li>4 号页存放在 5 号块的位置，块号是 0101.</li>
<li>偏移量：00001101111B.</li>
<li>物理地址：010100 0001101111B，即 146FH.</li>
</ul>
</li>
<li><p><strong>计算访问时间</strong>：</p>
<ul>
<li>一次快表的访问时间是 10ns.</li>
<li>一次内存的访问时间是 80ns.</li>
<li>处理一次缺页中断的平均时间是 200ns.</li>
<li>总时间 &#x3D; 快表访问时间 + 内存访问时间 + 缺页中断处理时间.</li>
<li>总时间 &#x3D; 10ns + 80ns + 200ns &#x3D; 290ns.</li>
</ul>
</li>
</ol>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ul>
<li><strong>物理地址</strong>：146FH.</li>
<li><strong>访问时间</strong>：290ns.</li>
</ul>
<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h3 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h3><ol>
<li><strong>虚拟存储器</strong>：通过将主存和辅存结合起来，为用户提供一个比实际主存空间大得多的存储空间。</li>
<li><strong>请求页式管理</strong>：一种虚拟存储管理方式，当进程运行时，只有部分页面被调入内存，其余页面存放在辅存中，当需要访问不在内存中的页面时，发生缺页中断，操作系统会将该页面调入内存。</li>
<li><strong>页表</strong>：用于记录虚拟页号到物理块号的映射关系，是实现虚拟地址到物理地址转换的关键数据结构。</li>
<li><strong>缺页中断</strong>：当访问的页面不在内存中时，系统会触发缺页中断，将该页面从辅存调入内存，可能需要替换内存中的某些页面。</li>
<li><strong>页面置换算法</strong>：当内存空间不足时，选择一个页面将其移出内存，以便为新页面腾出空间。常见的算法有 FIFO、LRU 等.</li>
<li><strong>局部性原理</strong>：程序在运行过程中，其访问的地址空间具有时间局部性和空间局部性，即在一段时间内，程序倾向于访问相近的地址和重复访问某些地址，这为虚拟存储管理提供了理论基础.</li>
</ol>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ol>
<li><strong>文件的存取方式</strong>：顺序存取 随机存取 .</li>
<li><strong>文件的逻辑结构</strong>：从用户的角度看到的文件组织方式，常见的有无结构文件和有结构文件（如<strong>顺序文件</strong>、<strong>索引文件</strong>、<strong>索引顺序文件</strong>等）.</li>
<li><strong>文件的物理结构</strong>：指文件在外存上的存储形式，常见的有连续分配、链接分配和索引分配等.</li>
<li><strong>文件控制块（FCB）</strong>：用于存储文件的基本信息、存取控制信息和文件的使用信息等，是文件系统管理文件的重要数据结构.</li>
<li><strong>文件目录</strong>：是文件控制块的集合，用于实现文件的符号名与物理地址的转换，方便用户管理和访问文件.</li>
<li><strong>多级目录结构</strong>：采用多级目录结构可以解决命名冲突问题，允许多个用户使用相同的文件名，同时提高了文件系统的灵活性和安全性.</li>
<li><strong>目录的功能</strong>：实现“按名存取”，提高文件检索速度，允许文件同名等.</li>
<li><strong>文件系统的安全性</strong>：通过设置文件的访问权限、密码保护等措施，确保文件系统的安全性，防止未授权访问和数据泄露等.</li>
<li><strong>文件系统的可靠性</strong>：采用文件备份、日志记录等技术手段，提高文件系统的可靠性，防止因系统故障等原因导致数据丢失或损坏.</li>
</ol>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>计算机理论</category>
      </categories>
  </entry>
  <entry>
    <title>一盏灯与计算机文明：从开关到智能的进化之旅</title>
    <url>/2024/12/17/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E4%B8%80%E7%9B%8F%E7%81%AF%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E6%98%8E%EF%BC%9A%E4%BB%8E%E5%BC%80%E5%85%B3%E5%88%B0%E6%99%BA%E8%83%BD%E7%9A%84%E8%BF%9B%E5%8C%96%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p>提问！一盏正常工作的灯有几种状态？</p>
<p>答案似乎不言而喻——<strong>通电亮起</strong> 与 <strong>断电熄灭</strong> 两种状态。</p>
<p>但若将视野投向计算机内部，这个简单的物理现象正在以每秒数十亿次的频率上演。正是这些微观开关的精密舞蹈，支撑起人类文明史上最庞大的电子巨兽。</p>
<h1 id="第零章：二进制的创世纪"><a href="#第零章：二进制的创世纪" class="headerlink" title="第零章：二进制的创世纪"></a>第零章：二进制的创世纪</h1><p>人类用 26 个字母构建文明，计算机用 0 与 1 书写史诗。前者诞生于感性的诗意，后者扎根于绝对的理性：</p>
<ul>
<li>高电平&#x3D;逻辑 1 ➔ 电子世界的”是”</li>
<li>低电平&#x3D;逻辑 0 ➔ 电子世界的”否”</li>
</ul>
<p>这些电子脉冲如同数字时代的甲骨文，通过最基本的逻辑运算编织出机器认知世界的法则：</p>
<ul>
<li><strong>与门（AND）</strong>：两个 1 相遇才诞生光明</li>
<li><strong>或门（OR）</strong>：存在即合理，任一 1 存在即点亮世界</li>
</ul>
<p>当 1947 年贝尔实验室的肖克利团队将这类逻辑刻入晶体管时，他们或许未曾想到，这些砂砾中的开关将成为驯服电子巨兽的缰绳。</p>
<h1 id="第一章：机械巴别塔的建造者"><a href="#第一章：机械巴别塔的建造者" class="headerlink" title="第一章：机械巴别塔的建造者"></a>第一章：机械巴别塔的建造者</h1><p>当 1946 年 ENIAC 在费城实验室点亮第一个真空管时，程序员们不得不用最原始的灯语与机器对话——他们拨动数千个开关的位置，如同黑暗中织网的蜘蛛，用二进制丝线直接操控硬件，只为让这头电子巨兽理解最简单的算术。</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">00101010 01110101 11001011</span><br></pre></td></tr></table></figure></div>

<p>这类机器语言虽然高效，但每个字符都需要精准的电子脉冲对应，如同在针尖上雕刻天书，是反人性的。</p>
<p>计算机先驱们很快发现，为什么不用直接用几个简单的字符来代表一长串晦涩的电子咒语？<br>于是汇编语言应运而生:</p>
<div class="code-container" data-rel="Armasm"><figure class="iseeu highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 机器码                    → 汇编指令</span></span><br><span class="line"><span class="comment">; 10110000 01100101        → MOV AL, 65h</span></span><br><span class="line"><span class="comment">; 00000100 00000001        → ADD AL, 1</span></span><br></pre></td></tr></table></figure></div>

<p>用 几个简单的字母 <code>MOV AX, BX</code> 就能替代 一长串的机器编码。这不仅仅是符号替换，更是人类首次声明自己不是开关的奴隶，而是逻辑的祭司。<br>从此，巨兽开始理解人类的密码。</p>
<h1 id="第二章：抽象即力量"><a href="#第二章：抽象即力量" class="headerlink" title="第二章：抽象即力量"></a>第二章：抽象即力量</h1><p>真正的技术革命始于对重复的厌倦。<br>当 FORTRAN 之父约翰·巴克斯写下<code>X=(A+B)*C</code>时，他不仅发明了第一个高级语言，更点燃了数字文明的<strong>抽象引擎</strong>。这行看似简单的公式，实则是跨越人机鸿沟的巴别塔：</p>
<div class="code-container" data-rel="Fortran"><figure class="iseeu highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 1957年的革命性代码示例</span></span><br><span class="line">X = (A + B) * C  <span class="comment">! 直接对应数学表达式</span></span><br></pre></td></tr></table></figure></div>

<p>对比当时繁琐的汇编操作：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 实现相同功能的汇编代码</span><br><span class="line">LOAD A</span><br><span class="line">ADD B</span><br><span class="line">MULT C</span><br><span class="line">STOR X</span><br></pre></td></tr></table></figure></div>

<p>这场革命如同人类从象形文字进化到字母文字——<strong>表达能力不变，认知成本骤降</strong>。</p>
<p>认知成本骤降, 带来了使用机会的增加, 随之而来的是问题和矛盾：</p>
<blockquote>
<p><strong>高效率与灵活性无法共存</strong></p>
</blockquote>
<p>由此, 高级语言分化出两大智慧形态，恰似东方水墨与西方油彩的并立：</p>
<ul>
<li>科学家需要数值计算快如闪电 → 发展出提前编译的极致优化</li>
<li>教育者希望即时看到代码结果 → 开创即时解释的灵活应变</li>
</ul>
<p>正是这种分工，让计算机既能驾驭航天器的精准控制（编译型），也能实现网页交互的瞬息万变（解释型）。</p>
<h1 id="第三章：工具即进化"><a href="#第三章：工具即进化" class="headerlink" title="第三章：工具即进化"></a>第三章：工具即进化</h1><p>所有伟大的发明都始于同一个念头：”能不能更省事？” 程序员们的偷懒史，演化成一场让机器理解人性的史诗远征。<br>当我们追溯工具演进史，会发现每个划时代工具的诞生，都在回答同一个终极问题：<strong>如何让机器更懂人性？</strong></p>
<p>1983 年的硅谷实验室里，一群头发蓬乱的工程师正在用最原始的方式驯服代码：他们左手翻阅着砖头般的《Unix 系统手册》，右手在三个终端间疯狂切换——一个编辑代码，一个编译程序，最后一个监控内存地址。<br>直到某个清晨，一个叛逆者将这三个窗口缝合在同一个界面，编程史上的普罗米修斯之火就此点燃。<br>第一个集成开发环境问世时，程序员终于摆脱了<strong>碎片化工具链</strong>的黑暗时代。</p>
<p>早期编写代码需要切换多个工具（编辑器、编译器、调试器），而集成开发环境将代码编写、调试、测试整合到单一界面。</p>
<p>当 Eclipse IDE 首次展示<strong>代码自动补全</strong>功能时，全场开发者起立鼓掌——他们知道，那个需要背诵整本 API 手册的时代结束了，现代 IDE 早已进化为智能工作台。<br>这就像中世纪的炼金术士突然获得了现代化学实验室，让<strong>专注力</strong>真正回归逻辑创造本身。</p>
<p>2005 年的 Linux 社区正经历至暗时刻。由于缺乏版本控制，来自全球的代码如洪水般涌入，版本冲突让系统摇摇欲坠，成百上千的代码贡献让系统濒临崩溃。托瓦兹用两周时间写出了 Git，从此代码世界有了自己的时光机：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看代码进化史</span></span><br><span class="line">git <span class="built_in">log</span> --graph --pretty=format:<span class="string">&#x27;%C(yellow)%h%Creset -%C(red)%d%Creset %s %C(green)(%cr)%Creset&#x27;</span> --abbrev-commit</span><br></pre></td></tr></table></figure></div>

<p>这条命令会展示出代码的进化树，每个分支都是平行宇宙的入口。<br>如今，GitHub 上每秒产生 7 个新代码库，这些数字巴别塔的基石，正是当年那个芬兰青年为自救写出的工具。</p>
<p>2013 年，所罗门·海克斯在旧金山演示 Docker 时，用了一个精妙比喻：”我们要把代码装进集装箱”。就像麦哲伦不需要为每片海域重造航船，Docker 让程序带着自己的运行环境环球航行。他的 Docker 将代码与运行环境封装成标准集装箱，终结了”在我机器上能跑”的千年魔咒。</p>
<p>真正的范式革命在 2021 年悄然而至，GitHub Copilot 横空出世。当程序员输入注释：”&#x2F;&#x2F; 计算斐波那契数列”，AI 自动补全了代码。<br>此刻，编程语言正在经历它的巴别塔崩塌，人与机器的对话终于跨越了语法的鸿沟。</p>
<h1 id="终章：未完成的史诗"><a href="#终章：未完成的史诗" class="headerlink" title="终章：未完成的史诗"></a>终章：未完成的史诗</h1><p>回望来时路，从 ENIAC 的 18000 个真空管到如今指甲盖大小的百亿晶体管芯片，这段进化史本质上是对”开关艺术”的极致演绎。当我们用人工智能生成代码、自动补全时，那个需要直接操控开关的原始野兽，已蜕变为理解人类意图的智能体。</p>
<p>或许某天，当量子比特打破 0&#x2F;1 的二元禁锢，我们又将见证新的语言革命。但无论如何进化，那些在硅基世界里翩翩起舞的电子，永远是人类理性之光的延续。</p>
<p>此刻在你指尖流转的每寸微光，都栖息着整部数字文明史。下次锁屏时，请留意那转瞬即逝的暗影：那是光的呼吸，是八十年前费城实验室的余烬，也是量子计算机苏醒前的晨露。所有奇迹的源代码，始终是开与关的古老韵脚。</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>计算机通识</tag>
        <tag>编程入门</tag>
        <tag>技术发展</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2024/04/04/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h1><p>是一些 <strong>互相连接</strong> , <strong>自治</strong> 的计算机的集合.</p>
<blockquote>
<p>互连: 计算机之间可以通过有线或无线的方式进行数据通信<br>自治: 独立的计算机, 有自己的硬件和软件, 可以单独运行使用</p>
</blockquote>
<h4 id="计算机网络的主要功能"><a href="#计算机网络的主要功能" class="headerlink" title="计算机网络的主要功能:"></a>计算机网络的主要功能:</h4><ul>
<li>资源共享</li>
<li>数据通信</li>
</ul>
<h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成:"></a>计算机网络的组成:</h4><ul>
<li>网络硬件系统</li>
<li>网络软件系统</li>
</ul>
<p>逻辑上又分为：</p>
<ul>
<li>资源子网: 包含大量网络资源的网络部分 (如服务器等)</li>
<li>通信子网: 负责数据传输的网络部分 (如路由器等)</li>
</ul>
<h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><h4 id="按覆盖范围分类"><a href="#按覆盖范围分类" class="headerlink" title="按覆盖范围分类"></a>按覆盖范围分类</h4><ul>
<li><p>广域网(WAN)</p>
</li>
<li><p>城域网(MAN)</p>
</li>
<li><p>局域网(LAN)</p>
</li>
<li><p>个域网(PAN)</p>
</li>
</ul>
<h4 id="按拓扑结构"><a href="#按拓扑结构" class="headerlink" title="按拓扑结构"></a>按拓扑结构</h4><ul>
<li>总线型网络<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%841.png"
                      alt="alt text"
                ></li>
<li>星型网络<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%842.png"
                      alt="alt text"
                ></li>
<li>环形网络<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%843.png"
                      alt="alt text"
                ></li>
<li>网状型网络<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%844.png"
                      alt="alt text"
                ></li>
</ul>
<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p>计算机网络的体系结构是计算机网络的 各 <strong>层</strong> 及其 <strong>协议</strong> 和 <strong>层间接口</strong> 的集合.  </p>
<p>计算机网络通过分成不同的层次来组织和管理，每一层都有自己的规则（协议）和与其他层交流的方式（层间接口）.<br>这样做的好处是可以把一个复杂的问题分解成几个简单的小问题来处理.</p>
<p>如今用的最多的是  TCP&#x2F;IP体系结构, 现今规模最大, 覆盖全球的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"
                      alt="alt text"
                ></p>
<h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><p>分为7个层次, 自顶向下依次为: </p>
<ol>
<li><p>物理层：负责实际的物理连接和电气信号, 例如电话线或光纤.</p>
</li>
<li><p>数据链路层：在同一网络内（如一个办公室的局域网）确保数据的可靠传输, 包括错误检测和纠正.</p>
</li>
<li><p>网络层：负责在不同网络之间, 找到数据从发送方到接收方的最佳路径，就像导航系统，告诉数据怎么走.</p>
</li>
<li><p>传输层：确保数据从一个网络端点到另一个端点(不同网络之间)的传输.</p>
</li>
<li><p>会话层：管理不同设备间的通信会话.</p>
</li>
<li><p>表示层：确保数据能够被接收设备理解, 让接收方能够理解.</p>
</li>
<li><p>应用层：是用户与网络交互的接口, 比如网页浏览器, 让用户能够使用网络服务.</p>
</li>
</ol>
<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h3><p>分为4个层次, 自顶向下依次为: </p>
<ol>
<li><p>网络接口层: 对应于OSI模型的物理层和数据链路层, 负责在物理媒介上传输原始比特流, 以及确保局域网内数据的可靠传输.</p>
</li>
<li><p>网络层: 负责跨网络的数据传输, 使用 <strong>IP协议</strong> 来实现数据包从源头到目的地的路由.</p>
</li>
</ol>
<blockquote>
<p>IP协议（Internet Protocol）的两个基本功能可以概括为：</p>
<p>寻址：IP协议为网络中的每个设备分配一个唯一的<strong>IP地址</strong>(互联网协议地址)，这样数据就可以被发送到正确的目的地。</p>
<p>路由：IP协议负责将数据包从源头,找到到达目的地的方式. 通过一系列的网络设备和网络，直到到达目标。</p>
</blockquote>
<ol start="3">
<li>传输层: 负责在网络端点之间提供可靠的通信服务. 主要协议有 <strong>TCP</strong>和 <strong>UDP</strong>.</li>
</ol>
<blockquote>
<p>TCP（Transmission Control Protocol）提供可靠的, 面向连接的服务. 对于那些需要确保数据完整性和可靠性的应用, TCP是更好的选择.</p>
<p>UDP（User Datagram Protocol）提供不可靠的, 无连接的服务. 适用于那些对传输速度和实时性有较高要求，但可以容忍一定数据丢失的应用场景.</p>
</blockquote>
<ol start="4">
<li>应用层: 对应于OSI模型的 会话层, 表示层和应用层. 为用户和应用程序提供网络服务.</li>
</ol>
<h3 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h3><p>网络可以识别的地址有 <strong>逻辑(IP)地址</strong> 和 <strong>物理(MAC)地址</strong> 两大类.</p>
<ul>
<li><p>物理地址（MAC地址）：是网络设备硬件的唯一标识符，通常指的是网络接口卡（NIC）上的媒体访问控制（MAC）地址, 设备生产时就固化在其中.</p>
</li>
<li><p>逻辑地址（IP地址）：逻辑地址是<strong>IP协议分配</strong>给网络设备的, 用于网络层和传输层通信的地址, IP地址的分配可根据需求灵活调整.</p>
</li>
</ul>
<p>MAC地址用于局域网内的通信, 而IP地址用于更广泛的网络环境.</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p><strong>子网掩码</strong> 与IP地址一起使用, 用于定义网络中哪些部分是<strong>网络地址</strong>, 哪些是<strong>主机地址</strong>.  子网掩码中的1表示该位属于网络号, 0表示属于主机号.</p>
<p>IP地址是由 <strong>网络地址</strong> 和 <strong>主机地址</strong> 组成</p>
<p>将IP地址与子网掩码进行 <strong>逻辑“与”（AND）</strong> 操作, 所得结果就是<strong>网络号</strong>.<br>网络号相同的设备被认为是在同一子网内。</p>
<blockquote>
<p>例如:<br>假设有一个IP地址192.168.1.10和一个子网掩码255.255.255.0 </p>
<p>将IP地址和子网掩码转换为二进制，然后进行逻辑“与”操作：<br>(逻辑“与”: 只有当两个相应的位都是1时，结果位才为1，否则为0)</p>
</blockquote>
<table>
<thead>
<tr>
<th>元素</th>
<th>二进制表示</th>
</tr>
</thead>
<tbody><tr>
<td>IP地址</td>
<td>11000000 . 10101000 . 00000001 . 00001010</td>
</tr>
<tr>
<td>子网掩码</td>
<td>11111111 . 11111111 . 11111111 . 00000000</td>
</tr>
<tr>
<td>逻辑“与”结果</td>
<td>11000000 . 10101000 . 00000001 . 00000000</td>
</tr>
</tbody></table>
<blockquote>
<p>将结果转换回十进制，得到网络号192.168.1.0。</p>
</blockquote>
<p>IPv4和IPv6是IP协议的两个版本, 它们用于 <strong>定义互联网上设备如何标识和通信的方式</strong>.  </p>
<h4 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h4><p>是32位二进制的, 以四组十进制数表示.</p>
<blockquote>
<p>例如: 192.168.1.1</p>
</blockquote>
<p>在<strong>IPv4</strong>中, IP地址被分为五类：A、B、C、D和E。这种分类基于IP地址的第一个字节（二进制中最高位的8位）, 用于决定地址的用途和可能的地址数量.</p>
<ul>
<li><strong>A类</strong>（1-127）,用于大型网络(如跨国公司), 默认子网掩码：255.0.0.0</li>
<li><strong>B类</strong>（128-191）,用于中型网络(如地区网络), 默认子网掩码：255.255.0.0</li>
<li><strong>C类</strong>（192-223）,小型网络(如家庭), 默认子网掩码：255.255.255.0</li>
<li><strong>D类</strong>（224-239）,广播地址.</li>
<li><strong>E类</strong>（240-255）,保留用于实验和研究, 不用于公共网络.</li>
</ul>
<blockquote>
<p>给定IP地址为 192.55.12.120&#x2F;24  </p>
<p>192.55.12.120 是其IP地址 (11000000 . 00110111 . 00001100 . 01111000)<br>&#x2F;24 表示子网掩码的前24位是网络部分，剩下的8位是主机部分<br>即子网掩码为: (255.255.255.0) 11111111 . 111111111 . 11111111 . 00000000 </p>
<p>网络号由 IP地址 和 子网掩码 转换为二进制，然后进行逻辑“与”操作, 得到.<br>为: 11000000 . 00110111 . 00001100 . 00000000 (192.55.12.0)<br>主机号由 子网掩码 取反(0.0.0.255), 与IP地址“按位与”, 得到主机号：0.0.0.120.</p>
</blockquote>
<h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><p>是128位的, 以八组四个十六进制数表示.</p>
<blockquote>
<p>例如: 2001:0db8:85a3:0000:0000:8a2e:0370:7334</p>
</blockquote>
<p>IPv6地址一组中的前导0可以不写<br>在有多个0连续出现时, 可以用一对冒号取代, 且只能取代一次.</p>
<blockquote>
<p>例如:<br>21DA:0000:0000:0000:02AA:000F:FE08:9C5A</p>
<p>缩写为:<br>21DA::2AA:F:FE08:9C5A 或者<br>21DA:0:0:0:2AA:F:FE08:9C5A</p>
</blockquote>
<p>IPv6提供了比IPv4更大的地址空间, 解决了IPv4地址耗尽的问题.  </p>
<p>为了从IPv4平稳过渡到IPv6, IPv6引入一种特殊的格式, 即在IPv4地址转换为十六进制, 再前置80个”0”和一个”ffff”以匹配128位的IPv6.</p>
<blockquote>
<p>例如, 将IPv4: 192.168.0.1 转换为IPv6</p>
<ol>
<li>转换为十六进制：C0A8 0001</li>
<li>前导零 + ffff：0000:0000:0000:0000:0000:ffff:c0a8:0001</li>
</ol>
<p>也可以简化表示为:<br>::ffff:c0a8:1  </p>
</blockquote>
<h1 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h1><h3 id="交换机（Switch）"><a href="#交换机（Switch）" class="headerlink" title="交换机（Switch）"></a>交换机（Switch）</h3><p>是局域网内的交换设备, 用于连接网络节点, 每个端口独享带宽, 实现点对点通信, 提高网络效率.</p>
<p>交换机的主要功能有：</p>
<ol>
<li><strong>数据转发</strong>：根据MAC地址表将数据帧转发到正确的端口</li>
<li><strong>MAC地址学习</strong>：动态学习并<strong>更新MAC地址表</strong></li>
<li><strong>广播抑制</strong>：减少不必要的广播流量</li>
<li><strong>避免冲突</strong>：通过CSMA&#x2F;CD协议避免数据发送冲突</li>
</ol>
<p>当交换机收到数据帧后，根据目的MAC地址查找MAC地址表, 确定对应端口, 然后将数据帧转发出去.</p>
<blockquote>
<p>数据链路层 传输的协议 数据单元 就是 <strong>帧</strong></p>
</blockquote>
<p>MAC地址表初始为空, 会动态学习过程构建. 这一过程主要包含:</p>
<ol>
<li><strong>学习</strong>：记录数据帧来源的MAC地址和端口。</li>
<li><strong>转发</strong>：根据学习到的信息将数据帧转发到目的端口。</li>
<li><strong>泛洪</strong>：未知目的MAC地址时，将数据帧发送到所有端口。</li>
<li><strong>更新</strong>：定期更新MAC地址表，移除过时的条目。</li>
</ol>
<h3 id="路由器（Router）"><a href="#路由器（Router）" class="headerlink" title="路由器（Router）"></a>路由器（Router）</h3><p>连接不同网络（如局域网、广域网）的设备, 工作在网络层.</p>
<p>主要功能：</p>
<ol>
<li>路由选择和数据交换：根据路由表选择数据包的最佳传输路径, 通过转发表实现数据包的快速转发.</li>
<li>网络分段和流量控制：提高网络的可管理性和安全性, 管理网络流量，防止拥塞。</li>
<li>隔离广播和异种网络连接：限制广播域的范围。连接不同类型的网络技术。</li>
</ol>
<ul>
<li>路由表：根据路由选择算法生成，包含目的网络和下一跳地址。</li>
<li>转发表：从路由表生成，用于快速查找和转发数据包。</li>
</ul>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>物理层 就是要解决 <strong>在各种传输媒体上传输比特0,1</strong> 的问题, 进而给数据链路层提供透明传输比特流的服务.</p>
<p>物理层为了解决传输比特0和1的问题, 主要有以下四个任务</p>
<ul>
<li>机械特性: 指明所有接线器的形状和尺寸, 引脚数目和排列, 固定和锁定装置.</li>
<li>电器特性: 指明在接口电缆的各条线上出现的电压的范围.</li>
<li>功能特性: 指明某条线上出现的某一电平的电压表示何种意义.</li>
<li>过程特性: 指明对于不同功能的各种可能事件的出现顺序.</li>
</ul>
<h3 id="信号传输"><a href="#信号传输" class="headerlink" title="信号传输"></a>信号传输</h3><p>模拟信号：随时间变化而连续变化的信号.<br>数字信号: 是离散的、值的变化是瞬时发生的.</p>
<p>数据也分为模拟数据和数字数据。 </p>
<h4 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h4><ul>
<li><p>串行传输: 数据是一个 <strong>比特</strong> 一个比特依次发送的, 只需要一条数据传输线路</p>
</li>
<li><p>并行传输: 一次发送n个 <strong>比特</strong> , 需要n条传输线路</p>
</li>
<li><p>同步传输: 数据以稳定的 <strong>比特流</strong> 形式传输, 字节间没有间隔. 接收端在每个比特的中间时刻进行检测, 一边别接收到的是比特0或1.</p>
</li>
<li><p>异步传输: 以字节为独立得到传输单位, 字节之间的时间间隔不是固定的. 在每个字节的前后分别加上起始位和结束位.<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%BC%82%E6%AD%A5%E4%BC%A0%E8%BE%93.png"
                      alt="alt text"
                ></p>
</li>
<li><p>单向通信: 又称单工通信, 通信双方只有一个传输方向</p>
</li>
<li><p>双向交替通信(半双工): 通信双方可以相互传输数据, 但不能同时进行</p>
</li>
<li><p>双向同时通信(双工): 通信双方可以同时发送和接收信息</p>
</li>
<li><p>码元: 是一段调制好的基本波形, 可以表示比特信息<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%A0%81%E5%85%83.png"
                      alt="alt text"
                ></p>
</li>
<li><p>编码: 数字数据编码为数字信号</p>
</li>
<li><p>调制: 数字数据编码为模拟信号<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6.png"
                      alt="alt text"
                ></p>
</li>
</ul>
<h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p>理想低通信道的最高码元传输速率 $&#x3D; 2W Baud &#x3D; 2W$ 码元&#x2F;秒<br>理想带宽信道的最高码元传输速率 $&#x3D; W Baud &#x3D; W$ 码元&#x2F;秒</p>
<blockquote>
<p>$W$ : 信道带宽 (Hz)<br>$Baud$ : 波特, 即 码元&#x2F;秒</p>
</blockquote>
<h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><p>$c &#x3D; W × log_2^{(1 +  \frac{S}{N})}$</p>
<blockquote>
<p>$c$ : 信道的极限信息传输速率 (b&#x2F;s)<br>$W$ : 信道带宽 (Hz)<br>$S$ : 信道内所传输信号的平均功率<br>$N$ : 信道内的高斯噪声功率<br>$\frac{S}{N}$ : 信噪比(dB)</p>
</blockquote>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p><strong>链路</strong>是从一个结点到相邻结点的一段物理路线, <strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件(如网络适配器) 和软件 (如协议实现)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF.png"
                      alt="alt text"
                ></p>
<p>数据链路层传输的协议数据单元是 <strong>帧</strong></p>
<h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>在一段数据的前后分别添加首部和尾部, 首部和尾部的一个重要作用就是进行帧界定</p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>如果数据中1的某个字节的二进制代码恰好和 SOH 或 EOT 一样, 数据链路层就会错误地 “找到帧的边界”</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93.png"
                      alt="alt text"
                ></p>
<p>解决透明传输问题的方法就是发送端的数据链路层在数据中出现控制字符 SOH 或 EOT 的前面插入一个转义字符 “ESC”</p>
<h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>比特在传输过程中可能会产生差错.<br>1可能变0, 0可能变1; 这就称之为比特差错.</p>
<h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C.png"
                      alt="alt text"
                ></p>
<p>只能检查出奇数个比特出现误码的情况.</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机通识</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法(c语言)</title>
    <url>/2023/09/17/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E7%A1%80-c%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>上课老师真的好无聊,还是上b站自学吧,听说这门课还挺难学习的?<br>笔记源自于这套课程:<br><a class="link"   href="https://www.bilibili.com/video/BV1Fv411H7jH/?share_source=copy_web&vd_source=663cc380bfc10fe6df62cd0cb979820d" >C语言《数据结构和算法》<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="第零章-C语言基础"><a href="#第零章-C语言基础" class="headerlink" title="第零章 C语言基础"></a>第零章 C语言基础</h1><blockquote>
<p>补一补c语言有关指针和结构体的基础知识…<br>视频来源: <a class="link"   href="https://www.bilibili.com/video/BV1kV4y1C7z6/?spm_id_from=333.337.search-card.all.click&vd_source=b19220b8f372f3a81aa8463fde694a63" >数据结构所需要的c语言基础<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>类似于 定义int能存放整数, 定义char能存放字符;<br>指针能存放地址. </p>
<p>地址 可以类比理解成 寝室号.<br>“ * “ 可以类比为 寝室钥匙.</p>
<p>例如: “ *a “ 可以访问到a的值.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">12</span>;<span class="comment">//定义一个整型变量</span></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//定义一个int类型的指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = &amp;x;<span class="comment">//将x的地址值赋给指针变量</span></span><br></pre></td></tr></table></figure></div>

<p>知道地址后如何访问地址存的变量值?<br>有以下两种方法:</p>
<ol>
<li>“ * “ + 地址</li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span>* q = &amp;y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*q);<span class="comment">//通过地址访问y的值,然后打印y的值</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>地址 + [  ]</li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = a;<span class="comment">//将数组a第一个数的地址值给指针p</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">0</span>])<span class="comment">//通过地址值访问数组a[2]的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">2</span>]);<span class="comment">//访问数组a[2]的值</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>也可以试试第一种方法:</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(p+<span class="number">2</span>));</span><br></pre></td></tr></table></figure></div>

<ul>
<li>还有这几种方式,也能输出相同的结果:</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;%d&quot;</span>, a[<span class="number">0</span>]);<span class="comment">//知道a的地址(首地址),偏移[0]个位置的值.</span></span><br><span class="line">print(<span class="string">&quot;%d&quot;</span>, a[<span class="number">2</span>]);<span class="comment">//知道a的地址(首地址),偏移[2]个位置的值.</span></span><br><span class="line">print(<span class="string">&quot;%d&quot;</span>, *a);<span class="comment">//知道a的地址(首地址),访问a的值.</span></span><br><span class="line">print(<span class="string">&quot;%d&quot;</span>, *(a+<span class="number">2</span>));<span class="comment">//知道a的地址(首地址),访问(a+2)的值.</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>同理的<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;%d&quot;</span>,(a+<span class="number">1</span>)[<span class="number">0</span>]);<span class="comment">//知道首地址(a+1),偏移[0]个位置的值.</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>即a[1]的值</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>例如管理学生信息. </p>
<p>若需求存储十个学生的: 姓名 学号 分数.<br>如果没有使用结构体:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> score[<span class="number">10</span>];</span><br><span class="line"><span class="type">float</span> sno[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div>

<p>不能以学生为单位查看,较为凌乱.</p>
<p>试一试结构体定义:</p>
<ul>
<li>定义方式一</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> son[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> score[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若要访问第一个学生的学号:</span></span><br><span class="line">s[<span class="number">0</span>].son;</span><br><span class="line"><span class="comment">//同理,要访问第四个学生的成绩:</span></span><br><span class="line">s[<span class="number">4</span>].score;</span><br></pre></td></tr></table></figure></div>


<ul>
<li>定义方式二(更常用)</li>
</ul>
<blockquote>
<p>typedef 约等于重命名<br>例如: typedef int a, 就是把int重新改名为a.<br>即: int x; 等价于 a x;  </p>
</blockquote>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> son[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> score[<span class="number">3</span>];</span><br><span class="line">&#125; stu;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>同理,此处是将 定义一中的 “struct student{…}” 重命名成 “stu”.</p>
</blockquote>
<p>尝试理解以下结构体定义:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; LNode,* Linklist;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>逗号相当于分隔符,类似于: int a,b; 是int a; int b;两条语句.</p>
<p>因此可以这样拆分出两条语句:</p>
<blockquote>
<p>typedef struct LNode{…} LNode:<br>将”struct LNode{…}”重命名为 LNode.</p>
</blockquote>
<blockquote>
<p>typedef struct LNode* linklist:<br>将”struct LNode”重命名为 * linklist.</p>
</blockquote>
<p>不过用逗号像这样链接容易造成误解, 大家一般不这样写去为难自己.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Lnode s;<span class="comment">//创造一个LNode类型的空间叫做s.</span></span><br><span class="line"></span><br><span class="line">Linklist p = &amp;s;<span class="comment">//取这个s空间的地址给p空间存放.</span></span><br></pre></td></tr></table></figure></div>


<pre class="mermaid">graph LR;

A1[data1]
B1[next1]
A2[data2]
B2[next2]

subgraph LNode1: s
A1---B1
end

subgraph LNode2
B1--指针-->A2---B2
end</pre>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>的异同</p>

    </div>
    <div class="notel-content">
      <ul>
<li>#define 是一个预处理器指令，它在编译之前就对代码进行了文本替换;</li>
</ul>
<p>typedef 是一个关键字，它在编译时创建了一个新的类型别名。</p>
<ul>
<li>#define 可以用于定义常量、变量、函数或者代码片段的宏。</li>
</ul>
<p>typedef 可以用于定义结构体、枚举、联合或者指针等复杂的类型的别名。</p>
<ul>
<li>#define 的作用域是从定义处到文件末尾，除非用 #undef 取消。</li>
</ul>
<p>typedef 的作用域是从定义处到所在的代码块末尾。</p>

    </div>
  </div>



<h3 id="结构体指针运算符"><a href="#结构体指针运算符" class="headerlink" title="结构体指针运算符"></a>结构体指针运算符</h3><p><code>-&gt;</code> 是一个结构体指针运算符，它用于通过结构体指针访问结构体的成员。<br>它的一般形式是：</p>
<blockquote>
<p><strong>结构体指针-&gt;成员名</strong></p>
</blockquote>
<p>例如，如果 L 是一个指向 SqList 类型的结构体的指针，那么 L-&gt;length 就表示访问该结构体的 length 成员，也就是线性表的当前长度。<br>可以把 -&gt; 理解为先解引用指针，再用 . 访问成员，即：</p>
<p>L-&gt;length 等价于 (*L).length</p>
<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><blockquote>
<p>不得不说我们老师讲的是真不行,说的话总是有很多完全没必要的句子,得不到她要说的重点…<br>还有就是数据结构真的好难好抽象!!</p>
</blockquote>
<h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><ol>
<li><p>数据: 所有能输入到计算机中去能用来描述客观事物的符号</p>
</li>
<li><p>数据元素: <strong>数据的基本单位</strong>, 也称为 结点 或 记录</p>
</li>
<li><p>数据项: <strong>数据最小单位</strong>, 也称为 域</p>
</li>
<li><p>数据对象: 是性质相同的数据<strong>元素的集合</strong>, 是数据的一个子级</p>
</li>
<li><p>数据结构: 是相互之间存在一种或多种特定关系的数据元素的集合</p>
</li>
</ol>
<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><blockquote>
<p><strong>程序设计 &#x3D; 数据结构 + 算法</strong>  </p>
</blockquote>
<p>就是数据与元素的<strong>关系集合</strong></p>
<hr>
<p>传统上,数据结构分为<strong>逻辑结构</strong>和<strong>存储(物理)结构</strong>。   </p>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>是数据元素间抽象化的相互关系, 与数据的存储无关, 独立于计算机.    </p>
<p>逻辑结构又分为:  </p>
<ul>
<li>集合</li>
<li>线性结构 (一对一)</li>
<li>树形结构 (一对多)</li>
<li>图形结构 (多对多)</li>
</ul>
<h3 id="存储-物理-结构"><a href="#存储-物理-结构" class="headerlink" title="存储(物理)结构"></a>存储(物理)结构</h3><ul>
<li>顺序存储</li>
<li>链式存储</li>
<li>索引存储</li>
<li>散列存储</li>
</ul>
<h2 id="算法的基本特征"><a href="#算法的基本特征" class="headerlink" title="算法的基本特征"></a>算法的基本特征</h2><h3 id="五个重要特性"><a href="#五个重要特性" class="headerlink" title="五个重要特性"></a>五个重要特性</h3><ul>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>0个或多个输入</li>
<li>一个或多个输出</li>
</ul>
<h3 id="评价优劣的标准"><a href="#评价优劣的标准" class="headerlink" title="评价优劣的标准"></a>评价优劣的标准</h3><ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效性</li>
<li>存储量低</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>语句频度: 一条语句的重复执行次数.</p>
<p>算法的执行时间 &#x3D;&#x3D; 该算法中所有语句的频度之和.</p>
<blockquote>
<p>$T(n) &#x3D; O(f(n))$ </p>
</blockquote>
<p>例如:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>( j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        c[i][j]=a[i][j]+b[i][j]</span><br></pre></td></tr></table></figure></div>

<p>是for循环的嵌套, 每个for循环的语句频度为n.<br>因此, 整体为n*n</p>
<p>即:   $T(n) &#x3D; O(n^2)$ </p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>算法所需存储空间的度量, 记作</p>
<blockquote>
<p>$S(n) &#x3D; O(f(n))$</p>
</blockquote>
<p>通常,求”复杂度”是指时间复杂度</p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><ul>
<li>逻辑结构: 一对一</li>
<li>存储结构: 顺序存储(顺序表) 链式存储(链表)</li>
</ul>
<h3 id="线性表的顺序存储-顺序表"><a href="#线性表的顺序存储-顺序表" class="headerlink" title="线性表的顺序存储 (顺序表)"></a>线性表的顺序存储 (顺序表)</h3><p>会预先分配存储空间, 可能会导致空间闲置或溢出现象.<br>不用为表示结点的逻辑关系而增加额外的存储开销, 存储密度等于1.  </p>
<p>随机存取元素, 时间复杂度为 O(1)<br>插入删除时平均移动约表中一半元素, 时间复杂度为 0(n)</p>
<p>适用于: </p>
<ul>
<li>表长变化不大, 且能事先确定变化的范围.</li>
<li>很少进行插入或删除操作, 经常按元素序号访问数据元素.</li>
</ul>
<h5 id="定义线性表的存储结构"><a href="#定义线性表的存储结构" class="headerlink" title="定义线性表的存储结构"></a>定义线性表的存储结构</h5><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100 <span class="comment">//线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; <span class="comment">//假设线性表的元素类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MAXSIZE]; <span class="comment">//用数组存储元素</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">//线性表的当前长度</span></span><br><span class="line">&#125; SqList; <span class="comment">//顺序表类型</span></span><br></pre></td></tr></table></figure></div>

<h3 id="线性表的链式存储-链表"><a href="#线性表的链式存储-链表" class="headerlink" title="线性表的链式存储 (链表)"></a>线性表的链式存储 (链表)</h3><p>存储空间动态分配, 不会出现闲置或溢出的现象.<br>需要借助指针来体现元素间的逻辑关系, 存储密度小于1.</p>
<p>顺序存取元素, 时间复杂度为 O(n)<br>插入删除时不需要移动元素, 确定插入删除位置后, 时间复杂度为 O(1)  </p>
<p>适用于:</p>
<ul>
<li>长度变化较大</li>
<li>频繁进行插入删除操作的</li>
</ul>
<h4 id="单向链表的表示"><a href="#单向链表的表示" class="headerlink" title="单向链表的表示"></a>单向链表的表示</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义单链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125; LNode, *LinkList; <span class="comment">//LNode为结点类型，LinkList为指向结点的指针类型</span></span><br></pre></td></tr></table></figure></div>

<p>头指针: </p>
<ul>
<li>是链表指向的<strong>第一个节点</strong>的指针 (若链表存在<strong>头节点</strong>,则指向头节点).</li>
<li>头指针具有<strong>标识作用</strong>,因此常用头指针冠以链表的名字.</li>
<li>无论链表是否为空,头指针<strong>均不为空</strong>.</li>
<li>头指针是链表<strong>必要</strong>元素</li>
</ul>
<p>头节点:</p>
<ul>
<li>是为了操作的统一和方便而设立. (统一了在第一元素节点前插入删除操作与其他节点)</li>
<li>头节点 <strong>不一定</strong> 是链表的必要元素.</li>
</ul>
<h4 id="双向链表的表示"><a href="#双向链表的表示" class="headerlink" title="双向链表的表示"></a>双向链表的表示</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>;</span> <span class="comment">// 指向前驱结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向后继结点</span></span><br><span class="line">&#125; DLinkList;</span><br></pre></td></tr></table></figure></div>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>逻辑结构: 一对一<br>存储结构: 顺序存储(顺序栈) 链式存储(链栈)</p>
<p><strong>后进先出</strong> 是受限制的线性表.</p>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></div>

<p>栈空标志: base &#x3D;&#x3D; top<br>栈满标志: top-base &#x3D;&#x3D; stacksize </p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>进栈</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base == S.stacksize)<span class="comment">// 判断是否栈满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    *S.top ++ = e; <span class="comment">//先获取栈顶元素 e ,然后栈顶指针减一</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>出栈 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Pop</span><span class="params">(SaStack &amp;S, SElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base) <span class="comment">//判断栈空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode, *LinkStack;</span><br><span class="line">LinkStack S;</span><br></pre></td></tr></table></figure></div>

<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><p>进栈 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span>&#123;</span><br><span class="line">    p = new StackNode; <span class="comment">//生成新结点p</span></span><br><span class="line">    <span class="keyword">if</span> (!p) </span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW); <span class="comment">// 如果结点申请失败, 就退出</span></span><br><span class="line"></span><br><span class="line">    p -&gt; data = e;</span><br><span class="line">    p -&gt; next = S;</span><br><span class="line">    S = P;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>出栈</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack &amp;S, SElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="comment">// 判断是否为空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = S -&gt; data;</span><br><span class="line">    p = S;</span><br><span class="line">    S = S -&gt; next;</span><br><span class="line">    delete p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>逻辑结构: 一对一<br>存储结构: 顺序存储 (循环队列) 链式存储 (链队)</p>
<h3 id="顺序存储-循环队列"><a href="#顺序存储-循环队列" class="headerlink" title="顺序存储 (循环队列)"></a>顺序存储 (循环队列)</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Qnode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueuePtr front; <span class="comment">// 队头指针</span></span><br><span class="line">    QueuePtr rear; <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure></div>

<h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><p>入队</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span>&#123;</span><br><span class="line">    p = new QNode;</span><br><span class="line">    <span class="keyword">if</span>(!p) </span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">    p -&gt; data = e; p -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear -&gt; next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>出队</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    p = Q.front -&gt; next;</span><br><span class="line">    e = p -&gt; data;</span><br><span class="line">    Q.front -&gt; next = p -&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) <span class="comment">// 出队为最后一个元素, 还原为初始队列状态</span></span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line"></span><br><span class="line">    delete p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链式存储-链栈"><a href="#链式存储-链栈" class="headerlink" title="链式存储(链栈)"></a>链式存储(链栈)</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line">Typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    QElemType *base;</span><br><span class="line">    <span class="type">int</span> front; <span class="comment">// 队头下标</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">// 队尾下标</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure></div>

<h4 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h4><p>循环队列入队</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,QElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXQSIZE == Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.base[Q.rear = e];</span><br><span class="line">    Q.rear = (Q.rear+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>循环队列出队</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>逻辑结构: 一对一<br>存储结构: 顺序存储(顺序串) 链式存储(链串)  </p>
<p>是受限制的线性表, 数据元素是字符.</p>
<h3 id="顺序串"><a href="#顺序串" class="headerlink" title="顺序串"></a>顺序串</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; HString;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 255 <span class="comment">// 用户可以在255以内定义最长串长</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> SString[MAXSTRLEN+<span class="number">1</span>]; <span class="comment">// 0号单元存放串的长度</span></span><br></pre></td></tr></table></figure></div>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>逻辑结构: 一对一<br>存储结构: 顺序存储 顺序+链式存储</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>逻辑结构: 一对多<br>存储结构: 顺序存储 链式存储</p>
<p>树是n个结点的有限集</p>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><p><strong>结点的度:</strong> 树中一个结点的孩子个数, 树中结点的最大度数称为树的度数.<br><strong>分支结点:</strong> 度数大于0的结点<br><strong>叶子结点(终端结点):</strong> 度为零 (没有子孙结点) 的结点 </p>
<p><strong>结点的层次:</strong> 从树根开始定义, 根节点为第一层, 它的子结点为第二层, 以此类推.<br><strong>结点的深度:</strong> 从根节点开始自顶向下逐层累加的<br><strong>结点的高度:</strong> 从叶结点开始自底向上逐层累加的</p>
<p><strong>树的高度(或深度):</strong> 树中结点的最大层数</p>
<p><strong>有序树和无序树:</strong> 树中结点的各子树从左到右是有次序的, 不能互换, 称之为有序树, 否则称为无序树.<br><strong>路径:</strong> 两个节点之间的路径是由这两个结点之间所经过的 <strong>结点序列</strong> 构成<br><strong>路径长度:</strong> 两个节点之间的路径长度是路径上所经过的 <strong>边的个数</strong> 构成</p>
<p><strong>森林:</strong> 森林是n棵互不相交的树的集合</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li><p>树中的结点数等于所有结点的度数加1  </p>
</li>
<li><p>度为 $m$ 的树中, 第i层至多有 $m^{i-1}$ 个结点</p>
</li>
<li><p>高度为$h$的$m$叉树至少有 $h$ 个结点, 至多有 $m^h-1 \over m-1$ 个结点.</p>
</li>
<li><p>具有 $sum$ 个结点的 $m$ 叉树的最小高度为 $\log _m{n(m-1)+1}$</p>
<blockquote>
<p>$sum &#x3D; {m^h-1 \over m-1}$</p>
</blockquote>
</li>
<li><p>高度为 $h$ 的 $m$ 叉数至少有 $h+m-1$ 个结点</p>
</li>
</ul>
<h4 id="区分-度为m的树-m叉树"><a href="#区分-度为m的树-m叉树" class="headerlink" title="区分 度为m的树\m叉树"></a>区分 度为m的树\m叉树</h4><ol>
<li>m 叉树–每个结点最多只能有m个孩子的树</li>
</ol>
<ul>
<li>任意结点的度数 ≦ m</li>
<li>可以是空树</li>
</ul>
<ol start="2">
<li>度为m的树–至少有一个结点度 &#x3D;&#x3D; m</li>
</ol>
<ul>
<li>任意结点的度数 ≦ m</li>
<li>一定为非空树</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树有左右之分(有序树), 给结点编号时每一层从左往右依次编号.</p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>高度为h的满二叉树, 含有 $2^h-1$ 个结点.</p>
<p>对于编号为 $i$ 的结点: </p>
<ul>
<li>双亲为 <code>i/2</code></li>
<li>若有左孩子, 则其为2i</li>
<li>若有右孩子, 则其为2i</li>
</ul>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>不同于满二叉树, 完全二叉树最后一层的结点都靠右排列,且除最后一层, 其他层都是满的.</p>
<p>高度为 $h$ 的完全二叉树, 最多有 $2^h-1$ 个结点.</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>树上任意结点的左子树和右子树的深度差不超过1.</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ol>
<li>先序遍历: 根节点 -&gt; 左子树 -&gt; 右子树</li>
<li>中序遍历: 左子树 -&gt; 根节点 -&gt; 右子树</li>
<li>后续遍历: 左子树 -&gt; 右子树 -&gt; 根节点</li>
</ol>
<p>以上三种其时间复杂度为O(n)</p>
<ol start="4">
<li>层次遍历: 从上到下, 从左往右</li>
</ol>
<h3 id="哈夫曼树-最优树"><a href="#哈夫曼树-最优树" class="headerlink" title="哈夫曼树(最优树)"></a>哈夫曼树(最优树)</h3><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，为哈夫曼树.<br>哈夫曼树是带权路径长度最短的树, 权值较大的结点离根较近.</p>
<h4 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h4><p>结点的带权路径长度为: 从根结点到该结点之间的路径长度与该结点的权的乘积.</p>
<p>树的带权路径长度规定为所有叶子结点的带权路径长度之和, 记为WPL.</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>线性表可以是空表, 图不可以是空图.</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>适合于稠密图</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>适合于稀疏图</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="深度优先-前序遍历"><a href="#深度优先-前序遍历" class="headerlink" title="深度优先 (前序遍历)"></a>深度优先 (前序遍历)</h4><h4 id="广度优先-层次遍历"><a href="#广度优先-层次遍历" class="headerlink" title="广度优先 (层次遍历)"></a>广度优先 (层次遍历)</h4><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>用于查找的数据集合称为查找表, 他是由同一类型的数据元素 (或记录) 组成, 可以是一个数组或链表等数据类型.</p>
<p><strong>关键字:</strong> 数据元素中唯一标识干元素的某个数据项的值, 使用基于关键字的查找, 结果应该是唯一的.</p>
<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>从表的一端开始, 按顺序从后往前查找, 没什么好说的.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>算法简单, 对表结构无任何要求</li>
<li>平均查找长度较大, 当n较大时不推荐采用顺序查找</li>
</ul>
<h3 id="折半查找-二分查找"><a href="#折半查找-二分查找" class="headerlink" title="折半查找(二分查找)"></a>折半查找(二分查找)</h3><p>通过三个指针(low, high, mid), low &#x3D; 1, high &#x3D; 表长, mid取low 和 high 的中间值.  </p>
<ol>
<li>mid 与给定的 key 比较, 若相等则查找成功, 若不相等则将表分成前后两个子表.</li>
<li>如果 key 比 mid 大, 则将 low 取为 <code>mid + 1</code>; 反之比 mid 小, 则将 high 取为 <code>mid - 1</code></li>
</ol>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ul>
<li>显然效率比顺序查找快</li>
<li>必须采用顺序存储结构</li>
</ul>
<h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>建立一个索引表,然后在块中顺序查找.</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><ul>
<li>效率在顺序查找和折半查找之间</li>
<li>适用于经常动态变化的线性表</li>
</ul>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>KCN: 关键字比较次数<br>RMN: 记录移动次数</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>最简单的一种排序方式.</p>
<ol>
<li>一个一个取待排表中的关键字</li>
<li>在新的表中顺序查找, 逐个后移元素, 直到找到插入位置</li>
</ol>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>时间复杂度</p>
<p>最坏情况下:<br>KCN ≈ ${n^2}\over {2}$<br>RMN ≈ ${n^2}\over {2}$</p>
<p>空间复杂度</p>
<p>只需要一个用于记录的空间, 因此为: <code>O(1)</code></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>简单, 稳定</li>
<li>适用于链式</li>
<li>不推荐用于n较大的情况</li>
</ul>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>使用折半查找的排序方法.</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>稳定</li>
<li>不适用于链式结构</li>
<li>适合初始记录无序, n较大的情况</li>
</ul>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>先分组, 使数据 “基本有序” 后, 再进行 直接插入排序.</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>跳跃式移动, 不稳定</li>
<li>不适用于链式</li>
<li>适合初始记录无序, n较大的情况</li>
</ul>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ol>
<li><p>简单选择排序</p>
</li>
<li><p>树形选择排序</p>
</li>
<li><p>堆排序</p>
</li>
</ol>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机通识</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux入门</title>
    <url>/2024/03/04/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>笔记视频来源: <a class="link"   href="https://www.bilibili.com/video/BV1n84y1i7td/?p=2&spm_id_from=pageDriver&vd_source=b19220b8f372f3a81aa8463fde694a63" >黑马程序员Linux零基础快速入门到精通<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h1><h3 id="Linux-操作系统"><a href="#Linux-操作系统" class="headerlink" title="Linux 操作系统"></a>Linux 操作系统</h3><p>操作系统是软件的一类.</p>
<p><strong>操作系统是用户和计算机硬件之间的桥梁.</strong></p>
<p>Linux 由 <strong>林纳斯 托瓦兹</strong> 在大学期间创作, 后来经过全世界网友支持, 能够兼容多种硬件, 成为最为流行的服务器操作系统之一.</p>
<p>Linux系统由 <code>Linux系统内核</code> <code>系统级应用程序</code> 两部分组成. 由于Linux内核是免费开源的, 因此任何人都可以获得并修改内核, 封装发行Linux. </p>
<p>提供了 <strong>内核+系统级程序</strong> 的完整封装的, 称之为 Linux发行版.</p>
<p>常用的 Linux发行版 有 <code>ubuntu</code> <code>CentOS</code> <code>debain</code> <code>redhat</code> 等 <a class="link"   href="https://www.cnblogs.com/linuxAndMcu/p/11112518.html#:~:text=%E4%B8%89%E3%80%81Linux%20%E7%9A%84%E5%8F%91%E8%A1%8C%E7%89%88%E4%BB%8B%E7%BB%8D%201%20Debian%3A%EF%BC%88%E4%BB%A5%E7%A4%BE%E5%8C%BA%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E4%BD%9C%EF%BC%89%20Ubuntu%3A%20%E5%9F%BA%E4%BA%8E%E7%9F%A5%E5%90%8D%E7%9A%84Debian%20Linux%E5%8F%91%E5%B1%95%E8%80%8C%E6%9D%A5%EF%BC%8C%E7%95%8C%E9%9D%A2%E5%8F%8B%E5%A5%BD%EF%BC%8C%E5%AE%B9%E6%98%93%E4%B8%8A%E6%89%8B%EF%BC%8C%E5%AF%B9%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%94%AF%E6%8C%81%E9%9D%9E%E5%B8%B8%E5%85%A8%E9%9D%A2%EF%BC%8C%E6%98%AF%E7%9B%AE%E5%89%8D%E6%9C%80%E9%80%82%E5%90%88%E5%81%9A%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E7%9A%84Linux%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%EF%BC%8C%20%E8%80%8C%E4%B8%94Ubuntu%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%E9%83%BD%E5%85%8D%E8%B4%B9%E6%8F%90%E4%BE%9B%E3%80%82,suse%3A%20%E5%9F%BA%E4%BA%8ESlackware%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E6%AC%BELinux%2C%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E5%95%86%E4%B8%9A%E6%A1%8C%E9%9D%A2%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82%20...%204%20%E5%85%B6%E4%BB%96%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%20Gentoo%3A%20%E5%9F%BA%E4%BA%8Elinux%E7%9A%84%E8%87%AA%E7%94%B1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%AE%83%E8%83%BD%E4%B8%BA%E5%87%A0%E4%B9%8E%E4%BB%BB%E4%BD%95%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%88%96%E9%9C%80%E6%B1%82%E8%87%AA%E5%8A%A8%E5%9C%B0%E4%BD%9C%E5%87%BA%E4%BC%98%E5%8C%96%E5%92%8C%E5%AE%9A%E5%88%B6%E3%80%82%20" >了解更多发行版<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<p>本教程以 CentOS 讲解为主, ubuntu为辅, 使用虚拟机运行Linux系统.</p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/126601630#:~:text=%E5%9C%A8VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85centOS,7%E7%B3%BB%E7%BB%9F%E5%90%8E%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%90%AF%E5%8A%A8centOS%207%E7%B3%BB%E7%BB%9F%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%BF%9B%E5%85%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A1%8C%E9%9D%A2%E6%A8%A1%E5%BC%8F%EF%BC%8C%E9%82%A3%E4%B9%88%E5%BA%94%E8%AF%A5%E6%98%AF%E6%B2%A1%E6%9C%89%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85GUI%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8C%85%E6%89%80%E8%87%B4%EF%BC%8C%E5%90%AF%E5%8A%A8%E7%B3%BB%E7%BB%9F%E4%BC%9A%E9%BB%98%E8%AE%A4%E8%BF%9B%E5%85%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%95%8C%E9%9D%A2%E3%80%82" >CentOS 7系统启动后怎么从命令行模式切换到图形界面模式<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="Linux-命令行"><a href="#Linux-命令行" class="headerlink" title="Linux 命令行"></a>Linux 命令行</h1><p>Linux在图形化界面并未重点发力, 因此在开发过程中, 一般选用效率更高, 资源占用低并且稳定的 命令行.</p>
<p><a class="link"   href="https://www.hostbuf.com/t/988.html" >FinalShell SSH工具<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>入门基础</tag>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数字世界的构建手册</title>
    <url>/2024/12/28/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E6%95%B0%E5%AD%97%E4%B8%96%E7%95%8C%E7%9A%84%E6%9E%84%E5%BB%BA%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="数字存储"><a href="#数字存储" class="headerlink" title="数字存储"></a>数字存储</h2><p>计算机内存是由无数个电容器组成，可以通过电路控制给电容充电或放电，充满电代表 1，未充电代表 0，所以计算机存储任何数据只能用 0 和 1 来表示。<br>每个电容就是一个最小存储单元，称为 bit（位）。</p>
<p>由于每个 bit 只能是 0 和 1，为了能表示更多的数, 计算机采用二进制存储数字，逢 2 进 1.<br>这就是 二进制.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="comment">// 这是十进制</span></span><br><span class="line"></span><br><span class="line"><span class="number">0b1010</span> <span class="comment">//10 使用0b开头来表示二进制</span></span><br></pre></td></tr></table></figure></div>

<p>当一个二进制过长时, 阅读就不太方便了…<br>分组可以方便阅读, 例如可以四个 bit 为一组, 那么每一位的十进制取值就是 0<del>15.<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241226135228593.jpg"
                     
                ><br>这就是 十六进制, 逢 16 进 1. 为了表示方便, 用字母来代替两位数的值.<br>也就是 大于 9 的用 A</del>F 代替.<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241226135917227.jpg"
                     
                ></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0xA</span> <span class="comment">//10 十六进制以0x开头</span></span><br></pre></td></tr></table></figure></div>

<p>也可以 三个 bit 为一组, 那么每一组的十进制取值就是 0~7<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241226135433677.jpg"
                     
                ><br>这就是 八进制, 逢 8 进 1.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">012</span> <span class="comment">//还是10 八进制以0开头</span></span><br></pre></td></tr></table></figure></div>

<h1 id="字符存储原理"><a href="#字符存储原理" class="headerlink" title="字符存储原理"></a>字符存储原理</h1><p>使用一串固定的二进制数能表示一个十进制数.</p>
<p>那么同理的,<br>使用一串固定的二进制数, 再指定这个二进制数表示的字符,</p>
<p>也就是制定一套字符与二进制的映射关系, 就能实现存储字符了.<br>这就是编码表的原理.</p>
<h3 id="ASCII-编码表"><a href="#ASCII-编码表" class="headerlink" title="ASCII 编码表"></a>ASCII 编码表</h3><p>最早的编码表就是 ASCII 编码表, 它规定了数字字符, 英语字母 和其他常见符号等共计 128 个字符.<br>每个字符对应的数值称为 <strong>码点(Code Point)</strong>.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241228142911512.jpg"
                     
                ></p>
<p>如表所示, 由于常见字符对的码点用 8 个二进制位就可以表示, 因此在计算机设计时就默认以每 8 个 bit 为一组来读写数据.<br>为了表达方便, 像这样成组的 8 个 bit, 我们简称为 一个 <strong>Byte(字节)</strong>, 简写为 B.</p>
<blockquote>
<p>1 KB &#x3D; 1024 B<br>1 MB &#x3D; 1024 KB<br>1 GB &#x3D; 1024 MB<br>1 TB &#x3D; 1024 GB</p>
</blockquote>
<h3 id="GBK-汉字内码拓展规范"><a href="#GBK-汉字内码拓展规范" class="headerlink" title="GBK 汉字内码拓展规范"></a>GBK 汉字内码拓展规范</h3><p>由于只有 128 个字符, ASCII 码表覆盖有限, 因此各个国家都需要给自己单独规定编码表.</p>
<p>我国的 汉字内码拓展规范 简称 GBK, 在兼容 ASCII 码表的同时, 拓展了 2 万多个汉字.<br>相比于 ASCII 码用一个字节, GBK 码用<strong>两个</strong>字节来表示字符.</p>
<h3 id="Unicode-码"><a href="#Unicode-码" class="headerlink" title="Unicode 码"></a>Unicode 码</h3><p>如果有一万个国家, 那就得有一万种不同的编码.</p>
<p>因此, ISO (国际标准化组织) 就制定了统一的标准, Unicode 码, 也叫 统一&#x2F;万国(union)码.<br>Unicode 码包含了世界上大部分国家的大多数文字和字符, 大约有 14 万多个.<br>其中包含 65536 个常用基础字符, 剩下的是补充字符.<br>其中, 汉字的码点通常占两个字节.</p>
<p>Unicode 编码表有多种不同的实现方式, 常见的有:</p>
<ul>
<li>UTF- 8 : 是一种变长的编码方式. 它可以使用 1~4 个字节表示一个符号, 根据不同的符号而变化字节长度. (常用, 更节省资源)</li>
<li>UTF-16: 也是变长编码方式, 基础字符用 2 个字节, 补充字符用 4 字节.</li>
<li>UTF-32: 固定长度编码, 不管字符的 Unicode 码多大, 统一使用 4 个字节.</li>
</ul>
<p>很多情况下, 我们都使用 变长编码方式 UTF-8, 下面简单介绍以下它的编码规则:</p>
<p>UTF-8 首先将码点的范围进行约束.<br>通过码点的范围来分配位数:</p>
<table>
<thead>
<tr>
<th>UCS-2 编码(16 进制)</th>
<th>UTF-8 编码(二进制)</th>
</tr>
</thead>
<tbody><tr>
<td>0000 ~ 007F</td>
<td>0xxx xxxx</td>
</tr>
<tr>
<td>0080 ~ 07FF</td>
<td>110x xxxx 10xx xxxx</td>
</tr>
<tr>
<td>0800 ~ FFFF</td>
<td>1110 xxxx 10xx xxxx 10xx xxxx</td>
</tr>
<tr>
<td>01 0000 ~ 10 FFFF</td>
<td>1111 0xxx 10xx xxxx 10xx xxxx</td>
</tr>
</tbody></table>
<p>确定好范围, 再将 UCS-2 编码的二进制由低到高填入 UTF-8 中的 x 位中.</p>
<h1 id="图像的存储"><a href="#图像的存储" class="headerlink" title="图像的存储"></a>图像的存储</h1><p>计算机中的图片都是由无数个 像素点组成的, 每个像素点有各自的颜色.<br>当像素点足够小, 足够多时, 就组成了人眼能识别的图像了.</p>
<p>显示器的每一个像素点都包含 红绿蓝(R&#x2F;G&#x2F;B) 三个子像素, 我们称为三基色.<br>通过调整每种颜色的亮度, 就能组合出世界上所有的颜色.<br>每种颜色的亮度都用 0 ~ 255 的数值来表示, 数值越大就越亮.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241228163813786.jpg"
                     
                ></p>
<p>用两位十六进制 00 ~ FF 刚好能表示 0 ~ 255 , 因此三个颜色的亮度可以这样表示:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#RRGGBB</span><br></pre></td></tr></table></figure></div>

<p>例如, 白色是所有颜色亮度最大值 255, 对应的十六进制是 FF</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#FFFFFF</span><br></pre></td></tr></table></figure></div>

<h1 id="音频的存储"><a href="#音频的存储" class="headerlink" title="音频的存储"></a>音频的存储</h1><p>声音是靠物体震动传播, 震动的频率和振幅不同, 得到的声音的音高和大小也不同,<br>所以保存声音信息主要记录的就是: 声波的<strong>频率</strong>和<strong>振幅</strong>.</p>
<p>计算机存储声音通常会经过三个步骤：采样、量化、编码</p>
<p>对音频最重要的两个元素 <strong>频率</strong>和<strong>振幅</strong> 采样, 然后取其近似值做量化, 最后转换位二进制编码存储.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241228165147613.jpg"
                     
                ><br>量化单位越密集, 音频越接近原始音频, 但代价是信息量大, 所需要的存储空间越大.</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>计算机通识</category>
      </categories>
      <tags>
        <tag>数字信息架构</tag>
      </tags>
  </entry>
  <entry>
    <title>windows命令行与批处理</title>
    <url>/2024/11/30/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8E%E6%89%B9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><h2 id="cmd-与-PowerShell"><a href="#cmd-与-PowerShell" class="headerlink" title="cmd 与 PowerShell"></a>cmd 与 PowerShell</h2><p>Windows 有两个命令行 shell：<strong>Command shell(CMD)</strong> 和  <strong>PowerShell</strong>.<br>而 shell 都是一个软件程序, 可实现一些自动化 IT 操作的环境.</p>
<p>CMD 是 Windows 中内置的第一个 shell.<br>PowerShell 旨在扩展 CMD 的功能.</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>命令行不区分大小写</li>
<li>命令行按上下键可以查看历史命令</li>
<li>Tab 键可以自动补全命令</li>
<li>使用 <code>/?</code> 或 <code>/help</code> 可以查看命令用法，用法中的<code>[]</code>代表可选</li>
</ul>
<p>以下, 将列出常用的功能以便我自己翻阅.</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>命令基本格式为:</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">命令 参数列表</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>echo</code></td>
<td>显示</td>
<td></td>
</tr>
<tr>
<td><code>pause</code></td>
<td>暂停</td>
<td><code>pause &gt; nul</code></td>
</tr>
<tr>
<td><code>cls</code></td>
<td>清屏</td>
<td></td>
</tr>
<tr>
<td><code>exit</code></td>
<td>退出</td>
<td></td>
</tr>
</tbody></table>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>type</code></td>
<td>显示文件内容</td>
<td><code>type 1.txt</code></td>
</tr>
<tr>
<td><code>find</code></td>
<td>查找字符串</td>
<td><code>find &quot;abc&quot; 2.txt</code></td>
</tr>
<tr>
<td><code>fc</code></td>
<td>比较文件内容</td>
<td><code>fc 1.txt 2.txt</code></td>
</tr>
<tr>
<td><code>date</code></td>
<td>显示&#x2F;修改日期</td>
<td><code>date /T</code></td>
</tr>
<tr>
<td><code>time</code></td>
<td>显示&#x2F;修改时间</td>
<td><code>time /T</code></td>
</tr>
<tr>
<td><code>ping</code></td>
<td>网络连接测试</td>
<td><code>ping www.baidu.com</code></td>
</tr>
<tr>
<td><code>ipconfig</code></td>
<td>TCP&#x2F;IP 信息</td>
<td></td>
</tr>
<tr>
<td><code>set /a</code></td>
<td>计算表达式</td>
<td><code>set /a 6%4</code></td>
</tr>
<tr>
<td><code>shutdown</code></td>
<td>关机</td>
<td><code>shutdown /s /t 60</code></td>
</tr>
</tbody></table>
<h3 id="多命令"><a href="#多命令" class="headerlink" title="多命令"></a>多命令</h3><ul>
<li><code>&amp;</code> 顺序执行多条命令，不管命令是否执行成功</li>
<li><code>&amp;&amp;</code> 顺序执行多条命令，前面的命令错误则不执行后面的命令</li>
<li><code>||</code> 顺序执行多条命令，碰到执行正确的命令后将不执行后面的命令</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">abc &amp; <span class="built_in">dir</span> &amp; bcd</span><br><span class="line">abc &amp;&amp; <span class="built_in">dir</span> &amp;&amp; bcd</span><br><span class="line">abc || <span class="built_in">dir</span> || bcd</span><br></pre></td></tr></table></figure></div>

<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul>
<li><code>&gt;</code> 输出重定向</li>
<li><code>&gt;&gt;</code> 追加重定向</li>
<li><code>&lt;</code> 输入重定向</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> /t &gt; 1.txt</span><br><span class="line">time /t &gt;&gt; 1.txt</span><br><span class="line">find <span class="string">&quot;/&quot;</span> &lt; 1.txt</span><br></pre></td></tr></table></figure></div>

<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li><code>|</code> 前一个命令的输出作为后一个命令的输入</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> | find <span class="string">&quot;txt&quot;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h2><p><strong>路径分隔符</strong>：<code>\</code></p>
<p><strong>当前目录</strong>：<code>.</code></p>
<p><strong>上一级目录</strong>：<code>..</code></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>dir</code></td>
<td>显示文件夹内容</td>
<td><code>dir /A</code></td>
</tr>
<tr>
<td><code>tree</code></td>
<td>显示文件夹树形结构</td>
<td><code>tree /F</code></td>
</tr>
<tr>
<td><code>盘符:</code></td>
<td>进入指定磁盘</td>
<td><code>c:</code> <code>d:</code></td>
</tr>
<tr>
<td><code>cd</code></td>
<td>切换目录</td>
<td><code>cd test</code> <code>cd ..</code></td>
</tr>
<tr>
<td><code>mkdir</code>或<code>md</code></td>
<td>创建目录</td>
<td><code>mkdir test</code></td>
</tr>
<tr>
<td><code>rmdir</code>或<code>rd</code></td>
<td>删除目录</td>
<td><code>rmdir test</code></td>
</tr>
<tr>
<td><code>del</code></td>
<td>删除文件</td>
<td><code>del 1.txt</code> <code>del /q/a/f *.txt</code></td>
</tr>
<tr>
<td><code>rename</code>或<code>ren</code></td>
<td>重命名</td>
<td><code>rename a.txt b.txt</code></td>
</tr>
<tr>
<td><code>copy</code></td>
<td>复制文件</td>
<td><code>copy a\1.txt b\1.txt</code></td>
</tr>
<tr>
<td><code>move</code></td>
<td>移动文件&#x2F;重命名</td>
<td><code>move a\1.txt 2.txt</code></td>
</tr>
</tbody></table>
<h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off		<span class="comment"># 关闭回显</span></span><br><span class="line">......</span><br><span class="line">pause			<span class="comment"># 暂停。或 pause &gt; nul</span></span><br></pre></td></tr></table></figure></div>

<h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><ul>
<li>双击运行</li>
<li>在 cmd 中运行（可以传参）</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置变量</span></span><br><span class="line"><span class="built_in">set</span> 变量名=变量值</span><br><span class="line"><span class="built_in">set</span> /a 变量名=表达式</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消变量</span></span><br><span class="line"><span class="built_in">set</span> 变量名=</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印变量</span></span><br><span class="line"><span class="built_in">set</span> 变量名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出变量</span></span><br><span class="line"><span class="built_in">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用变量</span></span><br><span class="line">%变量名%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入变量值</span></span><br><span class="line"><span class="built_in">set</span> /p 变量名=提示文字</span><br></pre></td></tr></table></figure></div>

<h3 id="预定义的变量"><a href="#预定义的变量" class="headerlink" title="预定义的变量"></a>预定义的变量</h3><table>
<thead>
<tr>
<th>变量名</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td><code>%cd%</code></td>
<td>当前目录</td>
</tr>
<tr>
<td><code>%date%</code></td>
<td>当前日期</td>
</tr>
<tr>
<td><code>%time%</code></td>
<td>当前时间</td>
</tr>
<tr>
<td><code>%random%</code></td>
<td>0~32767 之间的随机数</td>
</tr>
<tr>
<td><code>%path%</code></td>
<td>环境变量</td>
</tr>
<tr>
<td><code>%errorlevel%</code></td>
<td>上一个命令的返回值，0 表示执行成功</td>
</tr>
<tr>
<td><code>%0</code>、<code>%1</code>、<code>%2</code>……</td>
<td>参数。<code>%0</code>表示命令名</td>
</tr>
</tbody></table>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">call 可执行文件 [参数列表]</span><br></pre></td></tr></table></figure></div>

<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [not] 条件 (</span><br><span class="line">	语句块</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">	语句块</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件：</span></span><br><span class="line">errorlevel number	<span class="comment"># 上一个程序的返回值大于等于number则为true</span></span><br><span class="line">string1==string2	<span class="comment"># 两个字符串匹配则为true</span></span><br><span class="line">exist filename		<span class="comment"># 文件名存在则为true</span></span><br><span class="line">[/I] string1 compare-op string2		<span class="comment"># 比较数值或字符串</span></span><br><span class="line">	<span class="comment"># /I	忽略大小写</span></span><br><span class="line">	<span class="comment"># compare-op包括：</span></span><br><span class="line">	<span class="comment">#	equ	等于</span></span><br><span class="line">	<span class="comment"># 	neq	不等于</span></span><br><span class="line">	<span class="comment">#	lss	小于</span></span><br><span class="line">	<span class="comment">#	leq	小于等于</span></span><br><span class="line">	<span class="comment">#	gtr	大于</span></span><br><span class="line">	<span class="comment">#	geq	大于等于</span></span><br><span class="line">defined variable	<span class="comment"># 如果定义了该变量则为true</span></span><br></pre></td></tr></table></figure></div>

<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">goto label		<span class="comment"># 跳转到标签所在行</span></span><br><span class="line">:label			<span class="comment"># 标签以冒号开头</span></span><br></pre></td></tr></table></figure></div>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><strong>基本语法</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (<span class="built_in">set</span>) <span class="keyword">do</span> (</span><br><span class="line">	语句块</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环变量用 %% 指定，只能是单字母</span></span><br><span class="line"><span class="comment"># set表示文件集合（也可以是空文件），元素之间以逗号或空格分隔，支持通配符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (a,b,c) <span class="keyword">do</span> (<span class="built_in">echo</span> %%i)</span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (*.*) <span class="keyword">do</span> (<span class="built_in">echo</span> %%i)</span><br></pre></td></tr></table></figure></div>

<p><strong>扩展语法</strong></p>
<ul>
<li><p>只遍历文件夹</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /d %%i <span class="keyword">in</span> (<span class="built_in">set</span>) <span class="keyword">do</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>遍历指定文件夹下的所有文件，不指定则表示当前目录。如果 set 为<code>.</code>表示枚举目录树</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /r [[drive:]path] %%i <span class="keyword">in</span> (<span class="built_in">set</span>) <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> /r %%i <span class="keyword">in</span> (*) <span class="keyword">do</span> (<span class="built_in">echo</span> %%i)</span><br><span class="line"><span class="keyword">for</span> /r d:\up %%i <span class="keyword">in</span> (.) <span class="keyword">do</span> (<span class="built_in">echo</span> %%i)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>遍历数字序列</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /l %%i <span class="keyword">in</span> (start,step,end) <span class="keyword">do</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>遍历文件内容</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /f [<span class="string">&quot;options&quot;</span>] %%i <span class="keyword">in</span> (<span class="built_in">set</span>) <span class="keyword">do</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">?		<span class="comment"># 单个字符</span></span><br><span class="line">*		<span class="comment"># 任意字符</span></span><br></pre></td></tr></table></figure></div>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>按顺序为文件夹中的文件命名。</p>
<p><a class="link"   href="https://blog.csdn.net/Dandelion_gong/article/details/78067501" >批处理中 for 循环的自增自减问题_Dandelion_gong 的博客-CSDN 博客_bat for 自增<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line"><span class="built_in">set</span> cnt=0</span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (%1) <span class="keyword">do</span> (</span><br><span class="line">    rename %%i !cnt!.txt</span><br><span class="line">    <span class="built_in">set</span> /a cnt=!cnt! + 1</span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>环境变量</title>
    <url>/2024/12/21/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p><strong>如何通过“运行”对话框打开程序？</strong></p>
<ol>
<li>按下  <code>Win + R</code>  打开“运行”对话框。</li>
<li>输入  <code>cmd</code>  并回车，即可打开命令提示符（cmd 也算是一个 exe 程序）。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221161809785.jpg"
                     
                ></p>
<p>但如果你尝试输入一个别的 exe，例如 <code>QQ.exe</code>，可能会发现无法运行——这正是环境变量在起作用！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221161951459.jpg"
                     
                ></p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p><strong>环境变量是什么？</strong><br>环境变量就像系统的“快捷地址簿”。当你输入一个程序名（如  <code>cmd</code>），系统会快速从地址簿（Path 变量）中查找程序的位置。</p>
<blockquote>
<p>⚠️ <strong>注意</strong><br>修改环境变量需谨慎！错误操作可能导致系统无法找到关键程序（如系统忘记如何“呼吸”）。</p>
</blockquote>
<h3 id="如何查看环境变量？"><a href="#如何查看环境变量？" class="headerlink" title="如何查看环境变量？**"></a>如何查看环境变量？**</h3><p>打开设置, 在 关于 系统 -&gt; 系统高级设置 中即可找到<code>环境变量</code>.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221152757090.jpg"
                     
                ></p>
<p>也可以按下  <code>Win + S</code>  搜索“环境变量”:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221152349580.jpg"
                     
                ></p>
<p>打开面板, 我们不难发现, cmd 的路径 <code>(C:\Windows\System32)</code> 就在其中:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221164423296.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221163834724.jpg"
                     
                ></p>
<p>因此, “运行”对话框实际上是在环境变量配置的路径中寻找程序.<br>如果能够找到指定程序的路径就运行,<br>反之则报错.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221163746469.jpg"
                     
                ></p>
<p>你可能注意到了 CMD 的实际目录是 <code>C:\Windows\System32</code><br>而在环境变量 PATH 中指定的目录是 <code>%SystemRoot%\system32</code></p>
<p>这是由于虽然系统默认安装在 C 盘, 但是也可由用户指定位置.<br>为了灵活应对, Windows 就规定了 <code>%SystemRoot%</code> 的变量来存放系统安装的位置.<br>Windows 安装程序会将<code>%SystemRoot%</code>环境变量设置为安装目录的路径，通常是<code>C:\Windows</code>.</p>
<h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>一般而言, 我们并不需要通过 “运行” 对话框, 或是使用命令行来运行 QQ 这种程序.<br>环境变量更多地用于配置那些在命令行中运行的程序，比如 Java 和 Python 这样的开发工具.</p>
<p>使用命令行 运行程序时, 命令行会:</p>
<ul>
<li>默认会在 <strong>当前的目录</strong> 下寻找指定的程序.</li>
<li>未找到, 则会尝试去 <strong>Path 环境变量</strong> 中指定的路径寻找.</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>再次提醒!</p>

    </div>
    <div class="notel-content">
      <p>错误地编辑注册表可能会损坏系统!<br>编辑更改注册表前请确保你知道你在做什么.</p>

    </div>
  </div>

<p>那就拿熟悉点的 QQ 来举例吧!</p>
<h3 id="方式一-默认路径"><a href="#方式一-默认路径" class="headerlink" title="方式一 默认路径"></a>方式一 默认路径</h3><p>我的 QQ 安装在了这个文件夹下:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221171313140.jpg"
                     
                ></p>
<p>我们可以尝试通过 CMD 命令行 打开, 在桌面时 <code>win</code>+<code>r</code> <code>回车</code>, 快捷打开命令行.<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221171655673.jpg"
                     
                ><br>可以观察到当前命令行所在的路径为 <code>C:\Users\Wreckloud</code><br>显而易见地, QQ 并不在这个目录中, 尝试运行一下, 直接输入应用程序的名称即可运行:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">QQ.exe</span><br></pre></td></tr></table></figure></div>

<p>也是在预料之内的:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221171956227.jpg"
                     
                ></p>
<p>接下来我们将命令行的路径切换到 <code>QQ.exe</code> 所在的目录中:<br>常用以下两种方式打开指定的路径.</p>
<h4 id="在命令行中使用指令切换路径"><a href="#在命令行中使用指令切换路径" class="headerlink" title="在命令行中使用指令切换路径"></a>在命令行中使用指令切换路径</h4><p>使用指令: <code>cd 路径</code> 即可将命令行切换到指定的路径.</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:\Program Files\Tencent\QQNT</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>关于命令行的更多指令, 请 <a href="/2024/11/30/猎识印记-领域/操作系统/windows命令行与批处理/">看这里!</a></p>
</blockquote>
<h4 id="在文件浏览器中用命令行打开指定路径"><a href="#在文件浏览器中用命令行打开指定路径" class="headerlink" title="在文件浏览器中用命令行打开指定路径"></a>在文件浏览器中用命令行打开指定路径</h4><p>我更推荐:<br>直接在文件夹中找到需要的文件, 然后在地址栏输入 <code>cmd</code> 并回车.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221172536631.jpg"
                     
                ></p>
<p>两种方式都能让命令行转到指定的路径中:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221172632464.jpg"
                     
                ></p>
<p>再尝试在这个路径下输入 <code>QQ.exe</code> .</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221172727445.jpg"
                     
                ></p>
<p>成功地打开了, 但这种方式并不是重头戏.<br>这样也成功验证了 在安装目录以外的地方没办法使用命令行打开 QQ.</p>
<h3 id="方式二-Path-中的路径"><a href="#方式二-Path-中的路径" class="headerlink" title="方式二 Path 中的路径"></a>方式二 Path 中的路径</h3><p>只要类似 cmd 的, 将自己的安装路径配置在 Path 中, 命令行就可以在任意位置找到并打开 QQ.exe 了.</p>
<p>打开 环境变量 ,在 系统变量中 双击 Path.<br>接着将 <code>D:\Program Files\Tencent\QQNT</code> 配置到 Path 环境变量中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221174016322.jpg"
                     
                ></p>
<p>打开一个 <strong>新的</strong> 命令行, 尝试在任意位置执行 QQ.exe:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221174130557.jpg"
                     
                ></p>
<blockquote>
<p>带后缀(.exe)地, 不带后缀地都可以执行此程序.</p>
</blockquote>
<h1 id="环境变量的用途"><a href="#环境变量的用途" class="headerlink" title="环境变量的用途"></a>环境变量的用途</h1><p>环境变量实际可用于 版本控制.<br>例如 Java, 我们可以在一台计算机中安装多个版本的环境变量.</p>
<p>在 环境变量 Path 中指定所需要的 Java 路径(注意指定的是 <code>java.exe</code> 与 <code>javac.exe</code> 所在的路径):</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241222131553091.jpg"
                     
                ></p>
<p>将此路径新建到 环境变量的 Path 中.<br>打开一个新的终端查看 Java 版本.</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></div>

<p>我们提到过, Path 中有许多重要的路径, 不建议直接修改 Path 的内容.<br>我们可以模仿系统的 <code>%SystemRoot%</code> 做法, 也为 Java 设置一个 <code>%JAVA_HOME%</code> 的变量.<br><code>% %</code>代表引用环境变量.</p>
<p>这样, 控制版本时, 只需要在外修改变量的值, 从而避免频繁修改 Path 的内容.</p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>在环境变量中新建系统环境变量:</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">JAVA_HOME</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241222132654859.jpg"
                     
                ></p>
<p>再在 Path 中新建, 引用词变量 (注意指定的是 <code>java.exe</code> 与 <code>javac.exe</code> 所在的路径):</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241222133843666.jpg"
                     
                ></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之, 在绝大部分的情况下, 我们配置环境变量只是为了在任何一处都能用命令行或是别的什么, 来便利地运行所需程序.</p>
<p>这是一个很常用的功能.<br>既然如此, 现代的软件在设计时就考虑到了这一点.</p>
<p>在它们安装时, 通常会自带有将安装目录写入 Path 的选项:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221174828554.jpg"
                     
                ></p>
<p>如果在命令行中遇到了:<br><code>xxx&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件.</code><br>那么就检查一下 Path 路径是否配置正确吧.</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>计算机通识</category>
      </categories>
      <tags>
        <tag>环境变量</tag>
        <tag>命令行</tag>
        <tag>系统管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Web-互联网与星辰大海</title>
    <url>/2024/11/21/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/Web-%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8E%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7/</url>
    <content><![CDATA[<p>Web 就是全球广域网, 也称为万维网(www World Wide Web).<br>Web 指的就是能够通过浏览器访问的网站.</p>
<p>而我们要想开发一个 web 网站, 那首先就得知道 web 网站的基本结构.</p>
<h1 id="Web-网站结构"><a href="#Web-网站结构" class="headerlink" title="Web 网站结构"></a>Web 网站结构</h1><p>一个 web 网站的核心, 是由以下三个部分组成:</p>
<ul>
<li>前端程序：负责将数据以好看的样式<strong>呈现</strong>出来。</li>
<li>后端程序：负责具体的业务逻辑的<strong>处理</strong>。</li>
<li>数据库：负责数据的<strong>存储和管理</strong>。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/web-%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8E%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7/file-20241201160801897.jpg"
                     
                ></li>
</ul>
<p>当我们在浏览器地址栏, 输入 url 地址, 一敲回车.<br>此时首先访问到的是服务器中部署的 <strong>前端程序</strong>, 而前端程序仅仅负责将数据以好看的样式呈现出来.</p>
<p>前端展示的数据从哪里来呢? 前端程序会发送请求来请求<strong>服务端&#x2F;后端程序</strong>，由服务端&#x2F;后端程序来查询<strong>数据库</strong>, 然后将数据库查询的数据返回给前端.</p>
<p>最终, 前端程序再将数据渲染, 再由浏览器来解析前端程序.<br>这样, 一个精美的网页就展示在浏览器中了.</p>
<h1 id="Web-前端"><a href="#Web-前端" class="headerlink" title="Web 前端"></a>Web 前端</h1><p>前端开发，主要的职责就是将数据以好看的样式呈现出来。</p>
<p>不同的浏览器，内核不同，对于相同的前端代码解析的效果也会存在差异。为了避免这个差异，就需要定义一个统一的标准，然后让各大浏览器厂商都参照这个标准来实现即可。</p>
<p>这就是接下来要介绍的 <strong>web 标准</strong>。</p>
<p><strong>Web 标准</strong> 也称为 网页标准, 由三个组成部分：</p>
<ul>
<li>[[前端&#x2F;网页之骨架-HTML]]：负责网页的结构（页面元素和内容）。</li>
<li><a href="%E5%89%8D%E7%AB%AF/%E7%BD%91%E9%A1%B5%E4%B9%8B%E8%A1%A3%E8%A3%B3-CSS.md">网页之衣裳-CSS</a>：负责网页的表现（页面元素的外观、位置等页面样式，如：颜色、大小等）。</li>
<li><a href="%E5%89%8D%E7%AB%AF/%E7%BD%91%E9%A1%B5%E4%B9%8B%E5%A4%A7%E8%84%91-Javascript.md">网页之大脑-Javascript</a>：负责网页的行为（交互效果）。</li>
</ul>
<p>通过这三项技术, 就足够制作前端页面了.</p>
<p>除了这前端三件套以外，基础部分还有：</p>
<ul>
<li>[[前端&#x2F;Ajax-异步交互]]</li>
</ul>
<p>除了这些基础内容，目前的前端大多都会使用更高级的框架，例如</p>
<ul>
<li>[[前端&#x2F;渐进式框架-VUE]]</li>
<li>Element Plus</li>
<li>Tlias</li>
</ul>
<h1 id="Web-后端"><a href="#Web-后端" class="headerlink" title="Web 后端"></a>Web 后端</h1><p>Web 后端开发, 主要负责处理前端发送的请求、执行业务逻辑、与数据库交互以及管理服务器.<br>后端是网站和应用程序的“大脑”, 它处理着数据的存储、检索和业务逻辑.</p>
<p>像前面提到的 HTML、CSS、JS 以及图片、音频、视频等这些资源，我们都称为 <strong>静态资源</strong> .<br>与静态资源对应的, 就是 <strong>动态资源</strong> .</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>资源分类</p>

    </div>
    <div class="notel-content">
      <p>静态资源: 指在服务器上存储的, 不会改变的数据, 通常不会根据用户的请求而变化.<br>动态资源: 指在服务器端上存储的，会根据用户请求和其他数据动态生成的，内容可能会在每次请求时都发生变化.</p>

    </div>
  </div>

<p>比如：Servlet、JSP 等(负责逻辑处理)。而 Servlet、JSP 这些技术现在早都被企业淘汰了，现在在企业项目开发中，都是直接 <strong>基于 Spring 框架</strong> 来构建动态资源.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/web-%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8E%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7/file-20241201161835843.jpg"
                     
                ></p>
<p>而对于我们 java 程序开发的动态资源来说，我们通常会将这些动态资源部署在 <strong>Tomcat</strong>，这样的 Web 服务器中运行。 而浏览器与服务器在通信的时候，基本都是 <strong>基于 HTTP 协议的</strong> .</p>
<p>上述所描述的这种 <strong>浏览器&#x2F;服务器</strong> 的架构模式呢，我们称之为：<strong>BS 架构</strong>。</p>
<ul>
<li>BS 架构：Browser&#x2F;Server, 浏览器&#x2F;服务器架构模式. 客户端只需要浏览器, 应用程序的逻辑和数据都存储在服务端.</li>
</ul>
<p>还有一种 <strong>客户端&#x2F;服务器</strong> 的架构, 需要单独下载客户端的方式, 称之为 <strong>CS 架构</strong>.</p>
<ul>
<li>CS 架构：Client&#x2F;Server, 客户端&#x2F;服务器架构模式. 需要单独开发维护客户端.</li>
</ul>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS-进阶</title>
    <url>/2025/04/18/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%89%8D%E7%AB%AF/CSS-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="CSS-网页实战入门"><a href="#CSS-网页实战入门" class="headerlink" title="CSS 网页实战入门"></a>CSS 网页实战入门</h1><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">study（网站根目录）</span><br><span class="line">├── images</span><br><span class="line">│   ├── logo.png        # 固定素材（logo等）</span><br><span class="line">│   └── ...</span><br><span class="line">├── uploads             # 非固定素材（商品图片等）</span><br><span class="line">├── css</span><br><span class="line">│   ├── base.css       # 基础公共样式</span><br><span class="line">│   └── index.css      # 首页样式</span><br><span class="line">└── index.html         # 首页文件</span><br></pre></td></tr></table></figure></div>

<p><strong>网页制作三大步骤</strong></p>
<p>布局思路</p>
<ul>
<li>先整体后局部 → 从外到内 → 从上到下 → 从左到右</li>
</ul>
<p>CSS 实现步骤</p>
<ol>
<li><strong>画盒子</strong>：设置宽高、背景色定位元素范围</li>
<li><strong>定位盒子</strong>：使用 flex 布局&#x2F;边距调整位置</li>
<li><strong>填充内容</strong>：控制文字&#x2F;图片样式</li>
</ol>
<h3 id="对齐属性"><a href="#对齐属性" class="headerlink" title="对齐属性"></a>对齐属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>适用场景</th>
<th>示例值</th>
</tr>
</thead>
<tbody><tr>
<td><code>justify-content</code></td>
<td>主轴对齐（flex 容器）</td>
<td>space-between &#x2F; center</td>
</tr>
<tr>
<td><code>align-items</code></td>
<td>交叉轴对齐（flex 容器）</td>
<td>center &#x2F; stretch</td>
</tr>
<tr>
<td><code>align-self</code></td>
<td>单个元素交叉轴对齐（flex 子项）</td>
<td>center &#x2F; flex-start</td>
</tr>
<tr>
<td><code>vertical-align</code></td>
<td>行内&#x2F;表格元素垂直对齐</td>
<td>middle &#x2F; top</td>
</tr>
</tbody></table>
<h3 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h3><ol>
<li><strong>清除默认样式</strong>（base.css 示例）：</li>
</ol>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &#123; <span class="attribute">list-style</span>: none; &#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">text-decoration</span>: none; <span class="attribute">color</span>: <span class="number">#333</span>; &#125;</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>flex 布局速记</strong>：</li>
</ol>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between; <span class="comment">/* 主轴两端对齐 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center;   <span class="comment">/* 交叉轴居中 */</span></span><br><span class="line">  <span class="attribute">flex-wrap</span>: wrap;       <span class="comment">/* 允许换行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>图片处理原则</strong>：</li>
</ol>
<ul>
<li>固定尺寸使用<code>&lt;img&gt;</code>标签</li>
<li>背景图使用 CSS 背景属性</li>
<li>重要图片必须添加 alt 属性</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网页SEO核心标签详解 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 网页标题 → 搜索结果显示的第一行 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>品牌名-核心服务/产品 | 副标题（≤30字）<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 网页描述 → 搜索结果展示的摘要 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;网站主要服务说明，包含2-3个关键词，建议≤150字&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 网页关键词 → 搜索引擎分类依据 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;主关键词,次级关键词,长尾词（8个以内，逗号分隔）&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h1 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h1><p>搜索引擎优化（SEO）通过技术手段提升网站在自然搜索结果中的排名。<br>其中<strong>标签语义化</strong>是基础策略，要求开发者根据内容含义选择 HTML 标签（例如用<code>&lt;h1&gt;</code>表示主标题而非仅用<code>&lt;div&gt;</code>），这能帮助爬虫快速理解网页结构。</p>
<h3 id="三大核心元标签"><a href="#三大核心元标签" class="headerlink" title="三大核心元标签"></a>三大核心元标签</h3><ul>
<li><strong>标题标签</strong><code>&lt;title&gt;</code></li>
</ul>
<p>作为网页身份标识，应简明突出核心信息。<br>避免堆砌关键词，保持品牌与主题的平衡。例如电商网站可采用<code>&lt;title&gt;小米商城-小米手机|红米电视官网直营&lt;/title&gt;</code>的结构。</p>
<ul>
<li><strong>描述标签</strong><code>description</code><br>如同网页简历，需用自然语言概括内容价值。优质描述能提升点击率，例如：</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;小米商城直营小米手机、红米电视、智能家居等全系产品，正品保障，7天无理由退货&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>关键词标签</strong><code>keywords</code><br>建议选择用户搜索概率高的词汇，注意避免：</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 错误示例 → 关键词堆砌 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;手机,智能手机,小米手机,便宜手机&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正确示例 → 逻辑关联词 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;小米12S,旗舰手机,骁龙处理器,徕卡影像&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="关联优化技巧"><a href="#关联优化技巧" class="headerlink" title="关联优化技巧"></a>关联优化技巧</h3><ul>
<li><strong>文件扩展名优化</strong>：采用<code>.html</code>后缀而非<code>.php</code>等动态页面标识</li>
<li><strong>内容与标签一致性</strong>：确保页面实际内容包含元标签声明的关键词</li>
<li><strong>移动端适配</strong>：添加<code>viewport</code>元标签提升移动搜索排名</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>SEO 标签需与页面内容高度契合，避免为优化而牺牲用户体验。</p>
<h1 id="CSS-动画"><a href="#CSS-动画" class="headerlink" title="CSS 动画"></a>CSS 动画</h1><h3 id="平面转换效果"><a href="#平面转换效果" class="headerlink" title="平面转换效果"></a>平面转换效果</h3><p><code>transform</code> 一般配合过渡效果使用. 能改变盒子在平面内的形态.</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>translate (X 轴距离,Y 轴距离)</td>
<td>位移效果 (百分比取值参照自身取值)</td>
</tr>
<tr>
<td>rotate (旋转角度 $deg$)</td>
<td>旋转效果</td>
</tr>
<tr>
<td>scale(缩放倍数)<br>scale(X 缩放倍数,Y 缩放倍数)</td>
<td>缩放效果, 取值大于 1 为放大, 反之缩小</td>
</tr>
<tr>
<td>skew (倾斜角度 $deg$)</td>
<td>倾斜效果</td>
</tr>
</tbody></table>
<h4 id="改变转换原点"><a href="#改变转换原点" class="headerlink" title="改变转换原点"></a>改变转换原点</h4><p>默认情况下, 转换原点是盒子中心点.</p>
<p><code>transform-Origin : 水平原点位置  垂直原点位置;</code></p>
<p>取值:</p>
<ul>
<li>方位名词(left, top, right, bottom, center)</li>
<li>像素单位数值</li>
<li>百分比</li>
</ul>
<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>渐变是多个颜色逐渐变化的效果, 一般用于设置盒子背景.</p>
<ul>
<li>线性渐变</li>
</ul>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(</span><br><span class="line">    渐变方向(to 方位名词/角度度数 deg),</span><br><span class="line">    颜色<span class="number">1</span> 终点位置(百分比),</span><br><span class="line">    颜色<span class="number">2</span> 终点位置,</span><br><span class="line">    ......</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>径向渐变</li>
</ul>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(</span><br><span class="line">    半径 at 圆心位置(像素单位数值/百分比/方位名词),</span><br><span class="line">    (半径两条为椭圆),</span><br><span class="line">    颜色<span class="number">1</span> 终点位置,</span><br><span class="line">    颜色<span class="number">2</span> 终点位置,</span><br><span class="line">    ......</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p>从坐标轴角度定义了 X, Y 和 Z 三条坐标轴构成了一个立体空间,<br>Z 轴方向与视线方向相反.x 轴方向向右,y 轴向下.</p>
<p>形式上讲, 动画效果就是加强版的 <code>transation</code> 过度属性.</p>
<h3 id="视距属性"><a href="#视距属性" class="headerlink" title="视距属性"></a>视距属性</h3><p><code>perspective</code></p>
<p>指定了观察者与 z&#x3D;0 平面的距离, 为元素添加透视效果.<br>属性添加给父级, 取值范围 800-1200.</p>
<h3 id="空间转换"><a href="#空间转换" class="headerlink" title="空间转换"></a>空间转换</h3><p><code>transform</code><br>能改变盒子在空间内的形态.</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>translate3d (X 轴距离,Y 轴距离,Z 轴距离)<br>translate[X&#x2F;Y&#x2F;Z]</td>
<td>位移效果 (百分比取值参照自身取值)<br>小括号三个数据必须一个不差, 否则不生效.</td>
</tr>
<tr>
<td>rotate (旋转角度 $deg$)<br>rotate[X&#x2F;Y&#x2F;Z]</td>
<td>旋转效果</td>
</tr>
<tr>
<td>scale(缩放倍数)<br>scale(X 缩放倍数,Y 缩放倍数,Z 轴距离)<br>scale[X&#x2F;Y&#x2F;Z]</td>
<td>缩放效果, 取值大于 1 为放大, 反之缩小</td>
</tr>
<tr>
<td>skew (倾斜角度 $deg$)</td>
<td>倾斜效果</td>
</tr>
</tbody></table>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><code>animation</code></p>
<p>动画能实现多个状态间的变化过程, 动画过程可控(重复, 最终画面, 是否暂停)</p>
<h3 id="keyframes-创建动画"><a href="#keyframes-创建动画" class="headerlink" title="@keyframes 创建动画"></a><code>@keyframes</code> 创建动画</h3><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 动画的名称 &#123;</span><br><span class="line"> <span class="selector-tag">from</span>|<span class="number">0%</span>&#123;</span><br><span class="line"> css样式</span><br><span class="line">    &#125;</span><br><span class="line"> 多个百分比值&#123;</span><br><span class="line"> css样式</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="selector-tag">to</span>|<span class="number">100%</span>&#123;</span><br><span class="line"> css样式</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="animation-执行动画"><a href="#animation-执行动画" class="headerlink" title="animation 执行动画"></a>animation 执行动画</h3><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation</span>: 动画名称 持续时间 动画速率 开始延迟 循环次数(infinite-无限循环) 播放方向 播放状态( running-播放 | paused-暂停 );</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>动画速率可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ease</td>
<td>逐渐变慢(默认)</td>
</tr>
<tr>
<td>linear</td>
<td>匀速</td>
</tr>
<tr>
<td>ease-in</td>
<td>加速</td>
</tr>
<tr>
<td>ease-out</td>
<td>减速</td>
</tr>
<tr>
<td>ease-in-out</td>
<td>先加速后减速</td>
</tr>
</tbody></table>
<p>播放方向可选值 | 描述<br>normal|向前播放(默认)<br>alternate|动画播放在第偶数次向前播放, 第奇数次向反方向播放</p>
<h3 id="立体呈现"><a href="#立体呈现" class="headerlink" title="立体呈现"></a>立体呈现</h3><p><code>transform-style</code><br>设置元素的子元素是位于 3D 空间还是平面.</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>flat</td>
<td>子级处于平面中</td>
</tr>
<tr>
<td>preserve-3d</td>
<td>子级处于 3D 空间</td>
</tr>
</tbody></table>
<ol>
<li>父元素添加 <code>transform-style: preserve-3d</code></li>
<li>子级定位</li>
<li>调整盒子的位置(位移或选择)</li>
</ol>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网页SEO核心标签详解 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 网页标题 → 搜索结果显示的第一行 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>品牌名-核心服务/产品 | 副标题（≤30字）<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 网页描述 → 搜索结果展示的摘要 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;网站主要服务说明，包含2-3个关键词，建议≤150字&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 网页关键词 → 搜索引擎分类依据 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">content</span>=<span class="string">&quot;主关键词,次级关键词,长尾词（8个以内，逗号分隔）&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="SEO-优化基本原理"><a href="#SEO-优化基本原理" class="headerlink" title="SEO 优化基本原理"></a>SEO 优化基本原理</h3><p>搜索引擎优化（SEO）通过技术手段提升网站在自然搜索结果中的排名。其中<strong>标签语义化</strong>是基础策略，要求开发者根据内容含义选择 HTML 标签（例如用<code>&lt;h1&gt;</code>表示主标题而非仅用<code>&lt;div&gt;</code>），这能帮助爬虫快速理解网页结构。</p>
<h3 id="三大核心元标签-1"><a href="#三大核心元标签-1" class="headerlink" title="三大核心元标签"></a>三大核心元标签</h3><p><strong>标题标签</strong><code>&lt;title&gt;</code>作为网页身份标识，应简明突出核心信息。避免堆砌关键词，保持品牌与主题的平衡。例如电商网站可采用<code>&lt;title&gt;小米商城-小米手机|红米电视官网直营&lt;/title&gt;</code>的结构。</p>
<p><strong>描述标签</strong><code>description</code>如同网页简历，需用自然语言概括内容价值。优质描述能提升点击率，例如：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;小米商城直营小米手机、红米电视、智能家居等全系产品，正品保障，7天无理由退货&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>关键词标签</strong><code>keywords</code>建议选择用户搜索概率高的词汇，注意避免：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 错误示例 → 关键词堆砌 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;手机,智能手机,小米手机,便宜手机&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 正确示例 → 逻辑关联词 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;小米12S,旗舰手机,骁龙处理器,徕卡影像&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="关联优化技巧-1"><a href="#关联优化技巧-1" class="headerlink" title="关联优化技巧"></a>关联优化技巧</h3><ul>
<li><strong>文件扩展名优化</strong>：采用<code>.html</code>后缀而非<code>.php</code>等动态页面标识</li>
<li><strong>内容与标签一致性</strong>：确保页面实际内容包含元标签声明的关键词</li>
<li><strong>移动端适配</strong>：添加<code>viewport</code>元标签提升移动搜索排名</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<hr>
<p><strong>核心实践原则</strong>：SEO 标签需与页面内容高度契合，避免为优化而牺牲用户体验。定期通过<a class="link"   href="https://ziyuan.baidu.com/" >百度搜索资源平台<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>检测标签有效性。</p>
<h1 id="不同设备自适应"><a href="#不同设备自适应" class="headerlink" title="不同设备自适应"></a>不同设备自适应</h1><p>适配方案<br>宽度适配：宽度自适应<br>□百分比布局<br>□Flex布局<br>等比适配：宽高等比缩放<br>□rem<br>□vw</p>
<p>视口<br>视口：显示 HTML 网页的区域，用来约束 HTML 尺寸</p>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible"content="IE=edge">
<!-视口标签
<meta name="viewport"content="width=device-width,initial-scale=1.0">
<title>Document</title>
</head>
<body>
</body>
</html>
width=device-width：视口宽度=设备宽度
initial-scale=1.0:缩放1倍（不缩放）

<p>设置 meta 标签</p>
<p>使用设备的宽度作为视图宽度并禁止初始的缩放.<br>在 <code>&lt;head&gt;</code> 标签里加入这个 meta 标签:</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1,maximum-scale=1, user-scalable=no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>width = device-width</code> 宽度等于当前设备的宽度</li>
<li><code>initial-scale</code> 初始的缩放比例（默认设置为 1.0）</li>
<li><code>maximum-scale</code> 允许用户缩放到的最大比例（默认设置为 1.0）</li>
<li><code>user-scalable</code> 用户是否可以手动缩放（默认设置为 no）</li>
</ul>
<p>例如, 要设置不同尺寸设备下网页样式:</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line"> <span class="comment">/* 设备小于768px加载样式 */</span></span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">992px</span>) <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line"> <span class="comment">/* 设备小于768px但小于992px加载样式  */</span></span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: pink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">992px</span>) &#123;</span><br><span class="line"> <span class="comment">/* 设备大于992px加载样式 */</span></span><br><span class="line">    <span class="selector-tag">body</span>&#123;</span><br><span class="line">        <span class="attribute">background-color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="rem-适配方案"><a href="#rem-适配方案" class="headerlink" title="rem 适配方案"></a>rem 适配方案</h3><p>rem<br>rem单位，是相对单位<br>rem单位是相对于HTML标签的字号计算结果<br>1rem&#x3D;1HTML字号大小</p>
<p>媒体查询<br>思考<br>手机屏幕大小不同，分辨率不同，如何设置不同的HTML标签字号？<br>□媒体查询<br>媒体查询能够检测视口的宽度，然后编军差异化的CSS样式<br>当某个条件成立，执行对应的CSS样式</p>
<p>@media（媒体特性）<br>选择器<br>CSS属性</p>
<p>思考<br>设备宽度不同，HTML标签字号设置多少合适？<br>设备宽度大，元素尺寸大<br>口设备宽度小，元素尺寸小</p>
<p>目前rem布局方案中，将网页等分成10份，HTML标签的字号为视口宽度的1&#x2F;10</p>
<p>rem - flexible.js<br>flexible.js是手淘开发出的一个用来适配移动端的js库。<br>核心原理就是根据不同的视口宽度给网页中html根节点设置不同的font-size。</p>
<body>
<script src="./js/flexible.js"></script>
</body>
### less

<p>Less是一个CSS预处理器，Less文件后缀是.less。扩充了CSS语言，使CSS具备一定的逻辑性计算能力<br>注意：浏览器不识别LeSs代码，目前阶段，网页要引I入对应的CSS文件<br>VSCode插件：EasyLESS，保存less文件后自动生成对应的CSS文件</p>
<p>less-运算<br>运算：<br>●加、减、乘直接书写计算表达式<br>除法需要添加小括号或.</p>
<p>less-嵌套<br>作用：快速生成后代选择器</p>
<p>.父级选择器{<br>&#x2F;&#x2F;父级样式<br>.子级选择器{<br>&#x2F;&#x2F;子级样式</p>
<p>less-变量<br>概念：容器，存储数据<br>1&#x2F;定义变量<br>作用：存储数据，方便使用和修改@myColor: pink;<br>语法：使用变量<br>》定义变量：@变量名：数据；.box{<br>color:@myColor;</p>
<blockquote>
<p>使用变量：CSS属性：@变量名；<br>color:@mycolor;</p>
</blockquote>
<p>less-导入<br>作用：导入less公共样式文件<br>语法：导入：@import“文件路径”；<br>提示：如果是less文件可以省略后缀<br>@import ‘.&#x2F;base.less’;<br>@import’.&#x2F;common’;</p>
<p>less-导出<br>写法：在less文件的第一行添加&#x2F;&#x2F;out:存储URL<br>提示：文件夹名称后面添加&#x2F;<br>2out:.&#x2F;index.css<br>out:.&#x2F;css&#x2F;</p>
<p>less-禁止导出<br>base.lesscommon.lessindex.less<br>写法：在les<br>s文件第一行添加：&#x2F;&#x2F;out:false<br>1&#x2F;1out:false</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>Ajax</title>
    <url>/2024/11/27/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%89%8D%E7%AB%AF/Ajax-%E5%BC%82%E6%AD%A5%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p>全称 Asynchronous JavaScript And XML, <strong>异步</strong>的 JavaScript 和 XML.</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>XML</p>

    </div>
    <div class="notel-content">
      <p>XML 全称 Extenshible Markup Language 可拓展标记语言, 本质是一种数据格式, 可以用来存储复杂的数据结构.</p>

    </div>
  </div>

<p>Ajax 其作用有如下 2 点:</p>
<ul>
<li>与服务器进行数据交换: 通过 Ajax 可以给服务器发送请求, 并获取服务器响应的数据.</li>
<li>异步交互: 可以在 <strong>不重新加载整个页面</strong> 的情况下, 与服务器交换数据并 <strong>更新部分网页</strong> 的技术, 如: 搜索联想、用户名是否可用的校验等等.</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/ajax-%E5%BC%82%E6%AD%A5%E4%BA%A4%E4%BA%92/file-20241127122550616.jpg"
                     
                ></p>
<p>同步请求发送时, 在服务器处理请求的过程中, 浏览器页面只能干等着.</p>
<p>而 Ajax 这种 异步请求发送, 在服务器处理请求的过程中, 浏览器页面还可以做其他的操作.</p>
<h1 id="Axios-发送-Ajax-请求工具"><a href="#Axios-发送-Ajax-请求工具" class="headerlink" title="Axios - 发送 Ajax 请求工具"></a>Axios - 发送 Ajax 请求工具</h1><p>使用原生的 Ajax 请求的代码编写较繁琐, Axious 由此诞生.<br>Axios 是对原生的 Ajax 进行封装, 简化书写.</p>
<p>Axios 官网 <a class="link"   href="https://www.axios-http.cn/" >https://www.axios-http.cn<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><p>发起一个前端请求, 有 Axios 的简化, 只需简单两步.</p>
<p>1). 引入 Axios 文件</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>2). 使用 Axios 发送请求( 直接调用 axios 函数即可)</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Axios入门程序<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;getData&quot;</span>&gt;</span>GET<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;postData&quot;</span>&gt;</span>POST<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//GET请求</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#getData&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">axios</span>(&#123; <span class="comment">// 封装了一个对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>:<span class="string">&#x27;https://mock.apifox.cn/m1/3083103-0-default/emps/list&#x27;</span>,<span class="comment">// 指定请求路径</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">method</span>:<span class="string">&#x27;get&#x27;</span> <span class="comment">// 中指定请求方式</span></span></span><br><span class="line"><span class="language-javascript">      &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">res</span>) &#123; <span class="comment">// 成功回调函数, 服务端请求处理完毕后调用的函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>) &#123; <span class="comment">// 失败回调函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//POST请求</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#postData&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>:<span class="string">&#x27;https://mock.apifox.cn/m1/3083103-0-default/emps/update&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">method</span>:<span class="string">&#x27;post&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: <span class="string">&#x27;id=1&#x27;</span> <span class="comment">// 如果是POST, 还可以指定请求数据, 请求体</span></span></span><br><span class="line"><span class="language-javascript">      &#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">res</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>其中, Axios 还能以此更简介的方式:</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.请求方式(url[,data [, config]])</span><br></pre></td></tr></table></figure></div>

<p>这也是在项目中更常用的方式.</p>
<ul>
<li>GET</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;https://mock.apifox.cn/m1/3083103-0-default/emps/list&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>POST</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;https://mock.apifox.cn/m1/3083103-0-default/emps/update&quot;</span>,<span class="string">&quot;id=1&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h1 id="异步变为同步操作"><a href="#异步变为同步操作" class="headerlink" title="异步变为同步操作"></a>异步变为同步操作</h1><p>有时为了可读性和维护性, 代码又需要让异步变为同步操作.</p>
<p><code>async</code>就是来声明一个异步方法，<code>await</code>是用来等待异步任务执行.</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">search</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//基于axios发送异步请求，请求https://web-server.itheima.net/emps/list，根据条件查询员工列表</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">`https://web-server.itheima.net/emps/list?name=<span class="subst">$&#123;<span class="variable language_">this</span>.searchForm.name&#125;</span>&amp;gender=<span class="subst">$&#123;<span class="variable language_">this</span>.searchForm.gender&#125;</span>&amp;job=<span class="subst">$&#123;<span class="variable language_">this</span>.searchForm.job&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">empList</span> = result.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>异步编程</tag>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript-进阶</title>
    <url>/2025/04/02/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%89%8D%E7%AB%AF/Javascript-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域是变量能被访问的有效范围，本质上决定了代码中变量的可见性。理解作用域能帮助我们避免变量污染，写出更健壮的代码。<br>作用域分为两大类型：局部作用域和全局作用域，它们通过作用域链形成层级查找关系。</p>
<h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>局部作用域内的变量只能在特定范围内访问，分为两种常见形式：</p>
<ul>
<li><strong>函数作用域</strong></li>
</ul>
<p>在函数内部声明的变量（包括函数参数）形成一个封闭的独立空间。例如：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">x</span>) &#123; <span class="comment">// x 是函数作用域的局部变量</span></span><br><span class="line">  <span class="keyword">let</span> result = x * <span class="number">2</span>; <span class="comment">// result 只能在函数内部访问</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">calculate</span>(<span class="number">5</span>)); <span class="comment">// 输出 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 报错：x未定义</span></span><br></pre></td></tr></table></figure></div>

<p>函数执行完毕后，其内部变量会被销毁。不同函数之间的变量就像隔墙对话——彼此无法直接访问。</p>
<ul>
<li><strong>块作用域</strong></li>
</ul>
<p>用 <code>&#123;&#125;</code> 包裹的代码块（如 <code>if</code>&#x2F;<code>for</code> 语句）中使用 <code>let</code> 或 <code>const</code> 声明的变量会形成块作用域：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> secret = <span class="string">&quot;块内的秘密&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> oldSecret = <span class="string">&quot;老式秘密&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oldSecret); <span class="comment">// 正常输出（var 无视块作用域）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secret); <span class="comment">// 报错：secret未定义</span></span><br></pre></td></tr></table></figure></div>

<p>通过对比可以看到，<code>let</code> 将变量限制在代码块内，而 <code>var</code> 会泄漏到外层作用域。现代开发中推荐使用 <code>let/const</code> 来避免意外污染。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在 <code>&lt;script&gt;</code> 标签或 JS 文件的最外层声明的变量属于全局作用域，可以在任何位置访问：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> globalVar = <span class="string">&quot;我是全局的&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showGlobal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(globalVar); <span class="comment">// 正常访问</span></span><br><span class="line">  accidentalGlobal = <span class="string">&quot;糟糕！我成了全局变量&quot;</span>; <span class="comment">// 未使用声明关键字！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">showGlobal</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(accidentalGlobal); <span class="comment">// 意外泄漏到全局</span></span><br></pre></td></tr></table></figure></div>

<p>需要特别注意：</p>
<ol>
<li>避免直接给 <code>window</code> 对象添加属性（如 <code>window.myVar = 1</code>）</li>
<li>函数内部未使用 <code>let/const/var</code> 声明的变量会变成全局变量</li>
<li>过度使用全局变量容易引发命名冲突</li>
</ol>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>是一种查找机制，在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。<br>当前作用域 → 逐级父作用域 → 全局作用域</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable language_">global</span> = <span class="string">&quot;顶层&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> middle = <span class="string">&quot;中间层&quot;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> local = <span class="string">&quot;底层&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(local);    <span class="comment">// 当前作用域找到</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(middle);  <span class="comment">// 向上查找到 outer 作用域</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">global</span>);  <span class="comment">// 继续向上查找到全局</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure></div>

<p>这种链式查找机制解释了为什么内层函数能访问外部变量，而外层无法访问内部变量。理解这个机制对调试变量未定义错误至关重要。</p>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>内存管理是 JavaScript 运行时的核心机制，理解垃圾回收能帮助我们写出更高效、更安全的代码。<br>内存生命周期分为三个阶段：分配（声明变量）→ 使用（读写操作）→ 回收（自动清理），其中回收阶段通过垃圾回收器自动完成，开发者更需要关注的是如何避免内存泄漏。</p>
<p><strong>内存分配与回收规则</strong></p>
<p>当我们在函数内部声明局部变量时，这些变量就像临时便签纸——函数执行时被贴在内存墙上，执行完毕就会被自动撕下（回收）。而全局变量则像永久告示牌，会一直存在直到页面关闭：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createTemp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> tempData = <span class="string">&quot;临时数据&quot;</span>; <span class="comment">// 函数执行时创建</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(tempData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">createTemp</span>(); <span class="comment">// 执行完毕后 tempData 被回收</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tempData); <span class="comment">// 报错：变量不存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> globalData = <span class="string">&quot;永久数据&quot;</span>; <span class="comment">// 全局变量持续存在</span></span><br></pre></td></tr></table></figure></div>

<p>需要警惕的是意外创建的全局变量：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">leakMemory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  leakedVar = <span class="string">&quot;本应是局部变量&quot;</span>; <span class="comment">// 缺少 let/const 声明！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">leakMemory</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(leakedVar); <span class="comment">// 意外成为全局变量</span></span><br></pre></td></tr></table></figure></div>

<h4 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h4><p>浏览器通过特定算法判断内存是否需要回收，经历了两个重要阶段：</p>
<ul>
<li><strong>引用计数法（已淘汰）</strong></li>
</ul>
<p>早期 IE 浏览器通过”记账本”机制跟踪每个对象的被引用次数：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> objA = &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;; <span class="comment">// 引用次数+1</span></span><br><span class="line"><span class="keyword">let</span> objB = objA;      <span class="comment">// 引用次数+1 → 总计2次</span></span><br><span class="line">objA = <span class="literal">null</span>;          <span class="comment">// 引用次数-1 → 剩余1次</span></span><br><span class="line">objB = <span class="literal">null</span>;          <span class="comment">// 引用次数-1 → 触发回收</span></span><br></pre></td></tr></table></figure></div>

<p>但当对象相互引用时会导致永久驻留内存：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createLoop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> o1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> o2 = &#123;&#125;;</span><br><span class="line">  o1.<span class="property">link</span> = o2; <span class="comment">// 形成闭环引用</span></span><br><span class="line">  o2.<span class="property">link</span> = o1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">createLoop</span>(); <span class="comment">// 即使函数执行完毕，引用次数永远≥1</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E8%BF%9B%E9%98%B6/file-20250402131711615.jpg"
                     
                ></p>
<ul>
<li><strong>标记清除法（现代方案）</strong></li>
</ul>
<p>现代浏览器采用”大扫除”机制：从全局对象出发标记所有可达对象，未被标记的视为垃圾：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> privateData = <span class="string">&quot;敏感信息&quot;</span>;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">exposedData</span> = privateData; <span class="comment">// 建立全局可达路径</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">createData</span>();</span><br><span class="line"><span class="comment">// 函数执行后 privateData 仍被全局对象引用 → 无法回收</span></span><br></pre></td></tr></table></figure></div>

<p>当需要清理时：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="variable language_">window</span>.<span class="property">exposedData</span>; <span class="comment">// 断开引用链</span></span><br><span class="line"><span class="comment">// 下次垃圾回收时 privateData 成为不可达对象 → 被回收</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E8%BF%9B%E9%98%B6/file-20250402131608201.jpg"
                     
                ></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包就像函数的专属记忆背包——<strong>当函数诞生时，它会随身携带出生地的环境变量</strong>，这种”内外函数嵌套 + 变量持续锁定”的特性，让内部函数能长期访问外部函数的变量，即使外部函数已经执行完毕。</p>
<blockquote>
<p>闭包&#x3D;内层函数+外层函数的变量</p>
</blockquote>
<p><strong>闭包的形成条件</strong></p>
<ol>
<li><strong>嵌套结构</strong>：函数内部定义另一个函数</li>
<li><strong>变量捕获</strong>：内层函数使用外层函数的变量</li>
<li><strong>跨作用域调用</strong>：内层函数在外层函数外部被使用</li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>; <span class="comment">// 👉 被锁定的记忆胶囊</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ++count; <span class="comment">// 🎒 每次调用都从背包取出胶囊操作</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 🚀 创建携带独立背包的counter函数</span></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()); <span class="comment">// 1 👉 打开胶囊→读取0→+1→存回</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()); <span class="comment">// 2 👉 再次打开更新后的胶囊</span></span><br></pre></td></tr></table></figure></div>

<p>此时外层函数的 <code>count</code> 变量不会被回收，因为内部函数始终保持对其的引用。</p>
<h4 id="闭包的常见写法"><a href="#闭包的常见写法" class="headerlink" title="闭包的常见写法"></a>闭包的常见写法</h4><ul>
<li><strong>封装私有变量（模块模式）</strong></li>
</ul>
<p><strong>场景</strong>：需要保护数据不被外部直接修改时使用<br><strong>写法</strong>：用立即执行函数包裹，返回操作接口</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户积分模块</span></span><br><span class="line"><span class="keyword">const</span> userScore = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _score = <span class="number">0</span>; <span class="comment">// 私有变量，外部无法直接访问</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">num</span>) =&gt;</span> _score += num,</span><br><span class="line">    <span class="attr">deduct</span>: <span class="function">(<span class="params">num</span>) =&gt;</span> _score = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, _score - num),</span><br><span class="line">    <span class="attr">get</span>: <span class="function">() =&gt;</span> _score</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">userScore.<span class="title function_">add</span>(<span class="number">50</span>);</span><br><span class="line">userScore.<span class="title function_">deduct</span>(<span class="number">20</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userScore.<span class="title function_">get</span>()); <span class="comment">// 30</span></span><br><span class="line"><span class="comment">// console.log(_score) → 报错，无法直接访问</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>动态生成功能函数（工厂模式）</strong></li>
</ul>
<p><strong>场景</strong>：需要批量创建功能相似但配置不同的函数时使用<br><strong>写法</strong>：外层函数接收参数，返回携带配置的新函数</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建不同倍数的计算器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createMultiplier</span>(<span class="params">multiplier</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num * multiplier; <span class="comment">// 闭包记住当前倍数</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> double = <span class="title function_">createMultiplier</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> triple = <span class="title function_">createMultiplier</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">double</span>(<span class="number">5</span>)); <span class="comment">// 10 → 始终用2倍计算</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">triple</span>(<span class="number">5</span>)); <span class="comment">// 15 → 始终用3倍计算</span></span><br></pre></td></tr></table></figure></div>

<h4 id="闭包的应用与风险"><a href="#闭包的应用与风险" class="headerlink" title="闭包的应用与风险"></a>闭包的应用与风险</h4><p>闭包常用于实现模块化开发，例如封装私有变量：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> student = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _score = <span class="number">60</span>; <span class="comment">// 私有变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getScore</span>: <span class="function">() =&gt;</span> _score,</span><br><span class="line">    <span class="attr">addScore</span>: <span class="function">(<span class="params">num</span>) =&gt;</span> _score += num</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="title function_">getScore</span>()); <span class="comment">// 60</span></span><br><span class="line">student.<span class="title function_">addScore</span>(<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(student.<span class="title function_">getScore</span>()); <span class="comment">// 70</span></span><br></pre></td></tr></table></figure></div>

<p>但不当使用会导致内存泄漏，例如在 DOM 事件中滥用闭包：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bindEvents</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> bigData = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">fill</span>(<span class="string">&#x27;*&#x27;</span>); <span class="comment">// 大数据</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myBtn&#x27;</span>).<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bigData.<span class="property">length</span>); <span class="comment">// 闭包长期持有 bigData</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 即使移除按钮，bigData 仍驻留内存</span></span><br></pre></td></tr></table></figure></div>

<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>变量提升是 JavaScript 编译阶段的特殊处理机制，表现为 <strong><code>var</code> 声明的变量会提升到作用域顶部</strong>，但仅提升声明不提升赋值。这种机制容易引发代码理解错位，是许多隐蔽 Bug 的根源：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// 输出 undefined（而非报错）</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;张三&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p>等效于编译后的代码：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name;          <span class="comment">// 声明提升到顶部</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// 此时 name 尚未赋值</span></span><br><span class="line">name = <span class="string">&quot;张三&quot;</span>;     <span class="comment">// 赋值留在原地</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li><code>let/const</code> 强制先声明后使用，不会出现变量提升</li>
<li>同一作用域下重复的 <code>var</code> 声明会被合并，而 <code>let/const</code> 会报错</li>
</ol>
<p>现代开发中，使用 <code>let/const</code> 配合严格模式(<code>&#39;use strict&#39;</code>) 可完全规避变量提升问题：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 报错（未声明前不可访问）</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br></pre></td></tr></table></figure></div>

<p>变量提升是早期 JS 设计妥协的产物，ES6 通过块级作用域和 <code>let/const</code> 弥补了这一缺陷。</p>
<h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p><strong>函数声明整体提升</strong><br>函数声明会带着函数体提升到作用域顶端，可在声明前调用：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 正常执行</span></span><br><span class="line"><span class="title function_">getVersion</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getVersion</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;v2.0.0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>函数表达式不提升</strong><br>通过变量赋值的函数遵循变量提升规则，仅提升变量声明：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 报错：not a function</span></span><br><span class="line"><span class="title function_">getPrice</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getPrice = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">99.9</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>等效于：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getPrice;         <span class="comment">// 变量声明提升</span></span><br><span class="line"><span class="title function_">getPrice</span>();           <span class="comment">// 此时 getPrice=undefined</span></span><br><span class="line">getPrice = <span class="keyword">function</span>(<span class="params"></span>) &#123; ... &#125;; <span class="comment">// 赋值留在原地</span></span><br></pre></td></tr></table></figure></div>

<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="动态参数-arguments"><a href="#动态参数-arguments" class="headerlink" title="动态参数 arguments"></a>动态参数 <code>arguments</code></h4><p>处理不确定数量的参数时，JavaScript 提供了两种方案。传统方式通过 <strong><code>arguments</code> 伪数组</strong>获取所有实参，这种方式在箭头函数中不可用且操作受限：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统求和函数（使用 arguments）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 遍历 arguments 对象</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    total += <span class="variable language_">arguments</span>[i]; <span class="comment">// 通过索引访问每个参数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;总和：&#x27;</span>, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSum</span>(<span class="number">2</span>, <span class="number">3</span>);        <span class="comment">// 输出：总和：5</span></span><br><span class="line"><span class="title function_">getSum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 输出：总和：10</span></span><br></pre></td></tr></table></figure></div>

<h4 id="剩余参数-arg"><a href="#剩余参数-arg" class="headerlink" title="剩余参数 ...arg"></a>剩余参数 <code>...arg</code></h4><p>现代开发更推荐使用 <strong>剩余参数</strong> 语法，直接将多余参数捕获为<strong>真数组</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 现代求和函数（使用剩余参数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">...numbers</span>) &#123; <span class="comment">// 所有参数存入 numbers 数组</span></span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  numbers.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">num</span>) &#123; <span class="comment">// 直接使用数组方法</span></span><br><span class="line">    total += num;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;总和：&#x27;</span>, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSum</span>(<span class="number">5</span>, <span class="number">10</span>);       <span class="comment">// 输出：总和：15</span></span><br><span class="line"><span class="title function_">getSum</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>);  <span class="comment">// 输出：总和：20</span></span><br></pre></td></tr></table></figure></div>

<h4 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h4><p>与剩余参数语法相同但作用相反，<strong>展开运算符</strong> 可拆解数组用于特定场景。经典应用包括：</p>
<ul>
<li>展开数组</li>
<li>合并数组</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算最高温度（参数需要独立数值）</span></span><br><span class="line"><span class="keyword">const</span> temperatures = [<span class="number">22</span>, <span class="number">19</span>, <span class="number">25</span>, <span class="number">18</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 展开运算符，然后直接拆解</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;最高温度（现代）：&#x27;</span>, <span class="title class_">Math</span>.<span class="title function_">max</span>(...temperatures)); <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 合并两个数组（不修改原数组）</span></span><br><span class="line"><span class="keyword">const</span> week1 = [<span class="string">&#x27;周一&#x27;</span>, <span class="string">&#x27;周二&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> week2 = [<span class="string">&#x27;周三&#x27;</span>, <span class="string">&#x27;周四&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> fullWeek = [...week1, ...week2];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullWeek); <span class="comment">// [&#x27;周一&#x27;, &#x27;周二&#x27;, &#x27;周三&#x27;, &#x27;周四&#x27;]</span></span><br></pre></td></tr></table></figure></div>

<p>假设需要实现一个配置函数，同时接收基础 URL 和多个配置项：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统写法（使用 arguments）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setConfig</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> baseURL = <span class="variable language_">arguments</span>[<span class="number">0</span>]; <span class="comment">// 手动提取第一个参数</span></span><br><span class="line">  <span class="keyword">const</span> options = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>); <span class="comment">// 截取剩余参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;基础地址：&#x27;</span>, baseURL);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;配置选项：&#x27;</span>, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setConfig</span>(<span class="string">&#x27;http://api.com&#x27;</span>, <span class="string">&#x27;timeout=3000&#x27;</span>, <span class="string">&#x27;retry=3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代写法（剩余参数）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setConfig</span>(<span class="params">baseURL, ...options</span>) &#123; <span class="comment">// 自动分离参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;基础地址：&#x27;</span>, baseURL);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;配置选项：&#x27;</span>, options);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setConfig</span>(<span class="string">&#x27;http://api.com&#x27;</span>, <span class="string">&#x27;timeout=3000&#x27;</span>, <span class="string">&#x27;retry=3&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>箭头函数通过简化的语法结构提升代码可读性，其设计哲学在于提供更紧凑的函数表达式方案。<br>与传统函数的关键差异体现在三个方面：</p>
<p><strong>语法演进</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统函数表达式</span></span><br><span class="line"><span class="keyword">const</span> legacyFunc = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数标准形式（等效改写）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrowFunc</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>简写规则</strong></p>
<p>箭头函数通过精简语法让代码更直观，其简写规则针对常见场景做了针对性优化：</p>
<ol>
<li><strong>单参数省略括号</strong></li>
</ol>
<p>当函数<strong>只有一个参数</strong>时，可省略参数外的圆括号，让代码更紧凑：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统写法（带括号）</span></span><br><span class="line"><span class="keyword">const</span> double = <span class="keyword">function</span>(<span class="params">num</span>) &#123; <span class="keyword">return</span> num * <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数优化（省略括号）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">double</span> = num =&gt; num * <span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>这种写法常见于简单的数学运算或数据过滤：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 筛选正数</span></span><br><span class="line"><span class="keyword">const</span> positiveNumbers = [-<span class="number">2</span>, <span class="number">5</span>, -<span class="number">3</span>].<span class="title function_">filter</span>(<span class="function"><span class="params">num</span> =&gt;</span> num &gt; <span class="number">0</span>); <span class="comment">// [5]</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>单行返回值隐式返回：</strong></li>
</ol>
<p>当函数体<strong>只有一行代码</strong>时，可省略花括号和<code>return</code>关键字，结果自动返回：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统写法（需写return）</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数优化（自动返回）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br></pre></td></tr></table></figure></div>

<p>适用于简单的计算或转换：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 温度转换（华氏度→摄氏度）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fToC</span> = fahrenheit =&gt; (fahrenheit - <span class="number">32</span>) * <span class="number">5</span>/<span class="number">9</span>;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>返回对象字面量特殊处理：</strong></li>
</ol>
<p>直接返回对象时<strong>必须包裹圆括号</strong>，避免引擎误认为代码块：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误写法（缺少括号）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createUser</span> = name =&gt; &#123; <span class="attr">name</span>: name &#125;; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确写法（包裹对象）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">createUser</span> = name =&gt; (&#123; <span class="attr">name</span>: name &#125;);</span><br></pre></td></tr></table></figure></div>

<p>这种写法常见于快速构建数据对象：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成颜色配置</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getColor</span> = code =&gt; (&#123;</span><br><span class="line">  <span class="attr">hex</span>: <span class="string">`#<span class="subst">$&#123;code&#125;</span>`</span>,</span><br><span class="line">  <span class="attr">rgb</span>: <span class="string">&#x27;255,255,255&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><strong>运行时特性</strong><br>箭头函数作为表达式函数，不存在函数提升现象。这意味着：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">printHello</span>(); <span class="comment">// 正常执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printHello</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printHi</span>(); <span class="comment">// 报错：初始化前访问</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">printHi</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hi&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="箭头函数参数"><a href="#箭头函数参数" class="headerlink" title="箭头函数参数"></a>箭头函数参数</h4><p>参数处理机制体现了对传统函数缺陷的改进，<strong>剩余参数（</strong> 方案解决了 <code>arguments</code> 的伪数组问题：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统 arguments 方案（了解即可）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">legacySum</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    total += <span class="variable language_">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代剩余参数方案（推荐实践）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">modernSum</span> = (<span class="params">...nums</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, num</span>) =&gt;</span> acc + num, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h4 id="箭头函数-this"><a href="#箭头函数-this" class="headerlink" title="箭头函数 this"></a>箭头函数 this</h4><p>this 绑定机制是箭头函数最核心的特性变革，其设计目标为解决传统函数上下文绑定的混乱问题。<br>执行规则为：<strong>继承定义时的词法作用域的 this 值</strong>。</p>
<p><strong>经典场景对比</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统函数 - this 由调用方式决定</span></span><br><span class="line"><span class="keyword">const</span> timer = &#123;</span><br><span class="line">  <span class="attr">seconds</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">start</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">seconds</span>--); <span class="comment">// 错误：this 指向 window</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数 - this 静态继承</span></span><br><span class="line"><span class="keyword">const</span> timer = &#123;</span><br><span class="line">  <span class="attr">seconds</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">start</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">seconds</span>--); <span class="comment">// 正确：继承 start 的 this</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>DOM 事件处理警示</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#actionBtn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险方案（this 指向 window）</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 不符合预期的上下文</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>); <span class="comment">// 运行时错误</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐方案（保留 this 绑定）</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 指向 DOM 元素</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><strong>对象方法陷阱</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="comment">// 错误用法（箭头函数直接作为方法）</span></span><br><span class="line">  <span class="attr">printName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// this 指向外层作用域</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 正确用法（传统方法语法）</span></span><br><span class="line">  <span class="title function_">printNameValid</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// 正常访问对象属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>嵌套作用域穿透</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">child</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 箭头函数继承 parent.child 作用域的 this</span></span><br><span class="line">    <span class="attr">print</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>) <span class="comment">// 输出 undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>通过理解箭头函数的静态 this 绑定特性，我们可以更安全地处理异步回调和嵌套函数场景，但需特别注意在需要动态上下文的场景（如对象方法、DOM 事件）中的使用限制。</p>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>对象解构是一种快速提取对象属性并批量赋值的现代语法，其核心价值在于<strong>简化数据访问逻辑</strong>。<br>与传统逐个赋值的写法相比，这种语法糖（Syntactic Sugar）显著提升了代码的可读性和维护效率。</p>
<blockquote>
<p><strong>语法糖</strong>：编程语言提供的简洁写法，用更易读的形式实现原有功能。例如  <code>const &#123;name&#125; = user</code>  本质仍是属性访问，但代码更清晰直观。</p>
</blockquote>
<h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><p>我们可以通过等号左侧的花括号声明需要提取的属性名，实现属性到变量的直接映射：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户数据对象</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统逐个赋值</span></span><br><span class="line"><span class="keyword">const</span> name = user.<span class="property">name</span>;</span><br><span class="line"><span class="keyword">const</span> age = user.<span class="property">age</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象解构方案</span></span><br><span class="line"><span class="keyword">const</span> &#123; name, age &#125; = user;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &quot;小明&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></div>

<p><strong>关键规则</strong>：</p>
<ol>
<li><strong>属性名匹配</strong>：变量名必须与对象属性名一致</li>
<li><strong>作用域隔离</strong>：解构变量与外部作用域同名变量冲突时会报错</li>
<li><strong>安全防护</strong>：未匹配属性返回 <code>undefined</code></li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 危险操作（变量名冲突）</span></span><br><span class="line"><span class="keyword">let</span> title = <span class="string">&#x27;全局标题&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> post = &#123; <span class="attr">title</span>: <span class="string">&#x27;文章标题&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">// const &#123; title &#125; = post; // 报错：重复声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全方案（隔离作用域）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPostInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; title &#125; = post;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(title); <span class="comment">// &quot;文章标题&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="变量重命名"><a href="#变量重命名" class="headerlink" title="变量重命名"></a>变量重命名</h4><p>当需要避免命名冲突或提升语义时，可通过冒号语法指定新变量名：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> product = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;P1001&#x27;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="number">99.9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名解构</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">id</span>: productId, <span class="attr">price</span>: productPrice &#125; = product;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(productId);    <span class="comment">// &quot;P1001&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(productPrice); <span class="comment">// 99.9</span></span><br></pre></td></tr></table></figure></div>

<p>这种写法常见于处理多个数据源的场景，如同时解析用户配置和系统配置：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多配置合并场景</span></span><br><span class="line"><span class="keyword">const</span> userConfig = &#123; <span class="attr">theme</span>: <span class="string">&#x27;dark&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> defaultConfig = &#123; <span class="attr">theme</span>: <span class="string">&#x27;light&#x27;</span>, <span class="attr">fontSize</span>: <span class="number">14</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">theme</span>: userTheme &#125; = userConfig;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">theme</span>: defaultTheme, fontSize &#125; = defaultConfig;</span><br></pre></td></tr></table></figure></div>

<h4 id="数组对象解构"><a href="#数组对象解构" class="headerlink" title="数组对象解构"></a>数组对象解构</h4><p>该语法同样支持从数组元素中解构对象，特别适合处理接口返回的规范化数据结构：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口返回的带元数据数组</span></span><br><span class="line"><span class="keyword">const</span> response = [&#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="attr">data</span>: [&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;商品A&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分级解构获取核心数据</span></span><br><span class="line"><span class="keyword">const</span> [&#123;</span><br><span class="line">  <span class="attr">data</span>: [ firstItem ]</span><br><span class="line">  &#125;] = response;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstItem); <span class="comment">// &#123; id: 1, name: &#x27;商品A&#x27; &#125;</span></span><br></pre></td></tr></table></figure></div>

<p>掌握基于构造函数创建对象，理解实例化过程 2.掌握对象数组字符数字等类型的常见属性和方法，便捷完成功能</p>
<p>新的对象</p>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>在 JavaScript 中，我们可通过三种典型方式创建对象，其演进路线体现了从简单场景到复杂系统需求的适应过程：</p>
<p><strong>对象字面量</strong><br>作为基础创建方式，适合定义单例对象。其语法直观但复用性有限：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Peppa</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><strong>new Object()</strong><br>是早期提供的工厂模式，本质是对象字面量的语法变体。其局限性在于无法实现定制化对象创建逻辑：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">George</span> = <span class="keyword">new</span> <span class="title class_">Object</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;乔治&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><strong>构造函数(重点)</strong><br>的引入解决了批量对象创建问题。通过将对象模板抽象为可复用的函数结构，我们实现了面向对象编程的核心特征——实例化能力：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Pig</span>(<span class="params">name, age, gender</span>) &#123; <span class="comment">// 构造函数要求**首字母大写**</span></span><br><span class="line">  <span class="comment">// this 绑定新创建实例</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Mum</span> = <span class="keyword">new</span> <span class="title class_">Pig</span>(<span class="string">&#x27;猪妈妈&#x27;</span>, <span class="number">30</span>, <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Mum</span>); <span class="comment">// Pig &#123;name: &#x27;猪妈妈&#x27;, age: 30, gender: &#x27;女&#x27;&#125;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>构造函数要求<strong>首字母大写</strong>的命名规范（如 Pig）</p>
</blockquote>
<h3 id="构造函数核心机制"><a href="#构造函数核心机制" class="headerlink" title="构造函数核心机制"></a>构造函数核心机制</h3><p>当使用 <code>new</code> 运算符调用函数时，会触发以下隐式操作：</p>
<ol>
<li>创建空对象并绑定到函数上下文（this 指向空对象）</li>
<li>执行构造函数逻辑进行属性赋值</li>
<li><strong>自动返回</strong>新创建的对象实例</li>
</ol>
<p>这一机制解释了为何构造函数中不需要显式 return 语句。</p>
<p>通过家庭成员对象的创建案例，我们可以清晰看到不同方案的适用边界：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字面量方案：4 次重复代码</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Peppa</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span>, <span class="attr">age</span>: <span class="number">6</span>, <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">George</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;乔治&#x27;</span>, <span class="attr">age</span>: <span class="number">3</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Mum</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;猪妈妈&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Dad</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;猪爸爸&#x27;</span>, <span class="attr">age</span>: <span class="number">32</span>, <span class="attr">gender</span>: <span class="string">&#x27;男&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数方案：模板化创建</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FamilyMember</span>(<span class="params">name, age, gender</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">gender</span> = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Peppa</span> = <span class="keyword">new</span> <span class="title class_">FamilyMember</span>(<span class="string">&#x27;佩奇&#x27;</span>, <span class="number">6</span>, <span class="string">&#x27;女&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">George</span> = <span class="keyword">new</span> <span class="title class_">FamilyMember</span>(<span class="string">&#x27;乔治&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="comment">// ...其他家庭成员实例化</span></span><br></pre></td></tr></table></figure></div>

<p>当需要创建<strong>同构对象超过 2 个</strong>时，构造函数模式能显著提升代码可维护性。这种模式转变带来的收益随着系统复杂度的提升呈指数级增长。</p>
<h3 id="实例成员-静态成员"><a href="#实例成员-静态成员" class="headerlink" title="实例成员&#x2F;静态成员"></a>实例成员&#x2F;静态成员</h3><p><strong>实例成员</strong></p>
<p>实例成员是通过构造函数创建的<strong>对象专属属性与方法</strong>，每个实例对象都拥有独立的成员副本。<br>这种机制保证了对象间的数据隔离性，是面向对象编程的基础特性：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;大家好~&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>);  <span class="comment">// &quot;小明&quot;（访问实例属性）</span></span><br><span class="line">p1.<span class="title function_">sayHi</span>();            <span class="comment">// 调用实例方法</span></span><br></pre></td></tr></table></figure></div>

<p><strong>核心特性</strong>：</p>
<p>实例成员通过构造函数内的  <code>this</code>  动态绑定到每个新对象，<strong>每个实例都独立存储自己的属性和方法</strong>。<br>例如创建两个  <code>Person</code>  对象时，它们的  <code>sayHi</code>  方法互不影响，修改一个不会改变另一个。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数化构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, grade</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;李雷&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;韩梅梅&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// s1 与 s2 拥有独立数据存储</span></span><br></pre></td></tr></table></figure></div>

<p>通过构造函数参数，我们可以像流水线一样<strong>动态设置不同初始值</strong>，快速生成结构相同但数据不同的对象。</p>
<p><strong>静态成员</strong></p>
<p>静态成员是<strong>构造函数自身的属性与方法</strong>，用于实现与实例无关的公共功能。<br>其设计目标是提供类级别的工具方法：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 实例成员定义...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态属性（所有人类共有特征）</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">eyes</span> = <span class="number">2</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property">arms</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法（通用功能）</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">walk</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;人类行走方式&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">eyes</span>); <span class="comment">// this 指向构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">eyes</span>); <span class="comment">// 2（访问静态属性）</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">walk</span>();            <span class="comment">// 调用静态方法</span></span><br></pre></td></tr></table></figure></div>

<p><strong>关键约束</strong>：</p>
<p>静态成员直接挂在构造函数上，<strong>和具体实例无关</strong>。</p>
<p>比如  <code>Person.walk()</code>  方法无法读取实例的  <code>name</code>  属性，就像数学工具  <code>Math.random()</code>  不需要知道具体数字一样。这类方法常用于定义通用工具（如日期格式化）或全局配置（如默认超时时间）。</p>
<h1 id="内置构造函数"><a href="#内置构造函数" class="headerlink" title="内置构造函数"></a>内置构造函数</h1><p>基本类型处理简单数据，引用类型承载复杂结构。<br>JavaScript 的类型系统存在一个精妙设计：<strong>基本数据类型通过包装类型临时对象化</strong>。</p>
<p>当我们操作字符串、数字等基本类型时，引擎会自动创建临时包装对象，这使得如下操作成为可能：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;andy&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>); <span class="comment">// 4（临时 String 对象提供 length 属性）</span></span><br></pre></td></tr></table></figure></div>

<p>这种机制让基本类型在需要也能调用方法（如 <code>&#39;text&#39;.toUpperCase()</code>），操作完成后立即销毁临时对象，回归基本类型状态。</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><h4 id="键值提取-keys-values"><a href="#键值提取-keys-values" class="headerlink" title="键值提取 .keys()/.values()"></a>键值提取 <code>.keys()/.values()</code></h4><p>这对方法分别提取对象的键和值，返回数组形式。在处理数据格式转换时，它们常与数组方法配合使用：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;佩奇&#x27;</span>, <span class="attr">age</span>: <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(user);   <span class="comment">// [&#x27;name&#x27;, &#x27;age&#x27;]</span></span><br><span class="line"><span class="keyword">const</span> values = <span class="title class_">Object</span>.<span class="title function_">values</span>(user); <span class="comment">// [&#x27;佩奇&#x27;, 6]</span></span><br></pre></td></tr></table></figure></div>

<p>通过将对象结构转化为数组，可无缝接   接下来提到的数组方法进行深度处理。</p>
<h4 id="对象合并-assign"><a href="#对象合并-assign" class="headerlink" title="对象合并 .assign()"></a>对象合并 <code>.assign()</code></h4><p><strong><code>Object.assign()</code></strong><br>该方法 从左到右覆盖式 合并对象。</p>
<ol>
<li><strong>第一个参数为目标对象</strong>：所有源对象的属性都会拷贝到此对象</li>
<li><strong>后续参数为源对象</strong>：按顺序覆盖同名属性</li>
<li><strong>浅拷贝特性</strong>：嵌套对象仍为引用关系（修改会影响原对象）</li>
</ol>
<p>典型场景是为已有对象追加属性或创建浅拷贝：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础用法：动态添加属性</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj, &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123; a:1, b:2 &#125;（直接修改原对象）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并逻辑：同名属性被覆盖</span></span><br><span class="line"><span class="keyword">const</span> merged = <span class="title class_">Object</span>.<span class="title function_">assign</span>(</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">&#x27;红&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">color</span>: <span class="string">&#x27;蓝&#x27;</span>, <span class="attr">size</span>: <span class="string">&#x27;M&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">size</span>: <span class="string">&#x27;XL&#x27;</span> &#125;</span><br><span class="line">);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(merged); <span class="comment">// &#123; color:&#x27;蓝&#x27;, size:&#x27;XL&#x27; &#125;（最后一个源对象覆盖 size）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝陷阱：修改拷贝对象会影响原对象</span></span><br><span class="line"><span class="keyword">const</span> origin = &#123; <span class="attr">nested</span>: &#123; <span class="attr">value</span>: <span class="number">10</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, origin);</span><br><span class="line">copy.<span class="property">nested</span>.<span class="property">value</span> = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(origin.<span class="property">nested</span>.<span class="property">value</span>); <span class="comment">// 99（共享嵌套对象）</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Array-重点方法"><a href="#Array-重点方法" class="headerlink" title="Array 重点方法"></a>Array 重点方法</h3><h4 id="基础迭代：-forEach"><a href="#基础迭代：-forEach" class="headerlink" title="基础迭代：.forEach()"></a>基础迭代：<code>.forEach()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">数组.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">当前元素, 当前索引</span>) &#123;</span><br><span class="line">  <span class="comment">// 对每个元素执行操作（无返回值）</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>forEach()</code> 是替代传统 <code>for</code> 循环的现代方案，其核心能力在于 <strong>自动化迭代控制</strong>。通过对比可见其如何简化代码逻辑：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统索引循环</span></span><br><span class="line"><span class="keyword">const</span> prices = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`价格<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>: <span class="subst">$&#123;prices[i]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 现代迭代方案</span></span><br><span class="line">prices.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">price, index</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`价格<span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>: <span class="subst">$&#123;price&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>与手动维护索引的传统循环不同，<code>forEach</code> 自动处理数组遍历过程。回调函数始终按 <strong>元素 → 索引 → 原数组</strong> 的顺序接收参数，这种标准化接口降低了认知成本。</p>
<h4 id="数据转换：-map"><a href="#数据转换：-map" class="headerlink" title="数据转换：.map()"></a>数据转换：<code>.map()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 新数组 = 数组.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">当前元素, 当前索引</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 转换后的元素 <span class="comment">// 必须显式返回新值</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>map()</code> 专注于 <strong>元素映射转换</strong>，其设计理念是保持原数组不变并<strong>生成新数组</strong>。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统转换方式</span></span><br><span class="line"><span class="keyword">const</span> prices = [<span class="number">99.8</span>, <span class="number">145.5</span>, <span class="number">32.0</span>];</span><br><span class="line"><span class="keyword">const</span> formatted = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  formatted.<span class="title function_">push</span>(<span class="string">`¥<span class="subst">$&#123;prices[i].toFixed(<span class="number">2</span>)&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明式转换方案</span></span><br><span class="line"><span class="keyword">const</span> formatted = prices.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">price</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`¥<span class="subst">$&#123;price.toFixed(<span class="number">2</span>)&#125;</span>`</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><code>map</code> 方法通过返回新数组的特性，天然支持链式调用。在处理数据流水线时，可以流畅衔接其他数组方法形成处理链路，这种特性在组合 <code>filter</code> 等操作时尤为实用。</p>
<h4 id="条件筛选：-filter"><a href="#条件筛选：-filter" class="headerlink" title="条件筛选：.filter()"></a>条件筛选：<code>.filter()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 筛选数组 = 数组.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">当前元素</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 条件表达式 <span class="comment">// 返回true保留元素，false过滤元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>filter()</code> 实现了 <strong>真值测试驱动</strong> 的数据过滤机制，其核心逻辑是将条件判断抽象为独立函数：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统筛选方式</span></span><br><span class="line"><span class="keyword">const</span> users = [<span class="comment">/* 用户数据 */</span>];</span><br><span class="line"><span class="keyword">const</span> adults = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; users.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (users[i].<span class="property">age</span> &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    adults.<span class="title function_">push</span>(users[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式筛选方案</span></span><br><span class="line"><span class="keyword">const</span> adults = users.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">user</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> user.<span class="property">age</span> &gt;= <span class="number">18</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>该方法通过返回新数组保持数据不可变性，特别适合与 <code>map</code> 组合使用。当需要处理复合条件时，可通过逻辑运算符组合多个判断条件。</p>
<h4 id="字符串拼接：-join"><a href="#字符串拼接：-join" class="headerlink" title="字符串拼接：.join()"></a>字符串拼接：<code>.join()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 拼接结果 = 数组.<span class="title function_">join</span>(<span class="string">&#x27;分隔符&#x27;</span>) <span class="comment">// 默认分隔符为逗号</span></span><br></pre></td></tr></table></figure></div>

<p><code>join()</code> 方法将数组转换为格式可控的字符串，其分隔符参数提供了灵活的格式定制能力：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路径拼接场景</span></span><br><span class="line"><span class="keyword">const</span> pathSegments = [<span class="string">&#x27;src&#x27;</span>, <span class="string">&#x27;utils&#x27;</span>, <span class="string">&#x27;helper.js&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> fullPath = pathSegments.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>); <span class="comment">// &quot;src/utils/helper.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CSV生成场景</span></span><br><span class="line"><span class="keyword">const</span> headers = [<span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> row = [<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(headers.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>)); <span class="comment">// &quot;Name,Age&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(row.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>));     <span class="comment">// &quot;Alice,25&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>该方法在处理数据导出、URL 生成等场景时，能够显著简化字符串拼接逻辑。通过不同分隔符的配置，可快速适配 JSON、CSV 等多种数据格式要求。</p>
<h4 id="累计运算：-reduce"><a href="#累计运算：-reduce" class="headerlink" title="累计运算：.reduce()"></a>累计运算：<code>.reduce()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 最终值 = 数组.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">累计值, 当前元素</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 更新后的累计值</span><br><span class="line">&#125;, 初始值)</span><br></pre></td></tr></table></figure></div>

<p><code>reduce()</code> 的核心在于 <strong>通过遍历逐步收敛为单一值</strong>，</p>
<ol>
<li><strong>初始值决定起点</strong>：若提供初始值，首轮累计值为初始值；否则直接取数组<strong>首元素</strong></li>
<li><strong>链式传递逻辑</strong>：每次迭代的返回值自动成为下一轮累计值</li>
</ol>
<p>其执行逻辑可通过两种典型场景理解：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 场景1：数组求和（无初始值）</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> sum = nums.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur);</span><br><span class="line"><span class="comment">// 执行过程：1+2=3 → 3+3=6 → 6+4=10（结果：10）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景2：带初始值的对象统计</span></span><br><span class="line"><span class="keyword">const</span> words = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> count = words.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, word</span>) =&gt;</span> &#123;</span><br><span class="line">  acc[word] = (acc[word] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> acc;</span><br><span class="line">&#125;, &#123;&#125;);</span><br><span class="line"><span class="comment">// &#123; apple:2, banana:1 &#125;（初始空对象逐步填充）</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>初始值存在时，首次循环的 <code>acc</code> 为初始值，否则直接取数组第一个元素</li>
<li>每次循环的返回值会成为下次循环的 <code>acc</code></li>
<li>最终收敛值可以是任意类型（数字、对象、数组等）</li>
</ol>
<p>与传统循环相比，<code>reduce</code> 将迭代控制权交给引擎，开发者只需关注 <strong>如何更新累计值</strong>。这种模式在数据聚合、多维数组扁平化等场景中，能显著提升代码可读性。</p>
<h4 id="元素搜索：-find"><a href="#元素搜索：-find" class="headerlink" title="元素搜索：.find()"></a>元素搜索：<code>.find()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 目标元素 = 数组.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">当前元素</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 匹配条件 <span class="comment">// 返回true时停止搜索并返回该元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>find()</code> 的核心价值在于 <strong>短路搜索机制</strong>，其执行逻辑与传统搜索方式的对比：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统搜索方式</span></span><br><span class="line"><span class="keyword">const</span> users = [&#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">admin</span>:<span class="literal">false</span>&#125;, &#123;<span class="attr">id</span>:<span class="number">2</span>, <span class="attr">admin</span>:<span class="literal">true</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> target;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; users.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (users[i].<span class="property">admin</span>) &#123;</span><br><span class="line">    target = users[i];</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 找到后立即中断循环</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式搜索方案</span></span><br><span class="line"><span class="keyword">const</span> adminUser = users.<span class="title function_">find</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">admin</span>); <span class="comment">// &#123;id:2, admin:true&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>该方法在找到首个匹配元素后立即终止遍历，这种特性在处理大型数组时能显著提升性能。与 <code>filter</code> 返回数组不同，<code>find</code> 直接返回目标元素本身，在需要获取对象引用时更为实用。</p>
<h4 id="全员检测：every"><a href="#全员检测：every" class="headerlink" title="全员检测：every()"></a>全员检测：every()</h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 全员通过 = 数组.<span class="title function_">every</span>(<span class="keyword">function</span>(<span class="params">当前元素</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> 检测条件 <span class="comment">// 所有元素都返回true则最终为true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>every()</code> 通过 <strong>全员验证机制</strong> 实现整体性判断，其短路特性体现在：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统验证方式</span></span><br><span class="line"><span class="keyword">const</span> products = [&#123;<span class="attr">stock</span>:<span class="number">5</span>&#125;, &#123;<span class="attr">stock</span>:<span class="number">0</span>&#125;, &#123;<span class="attr">stock</span>:<span class="number">3</span>&#125;];</span><br><span class="line"><span class="keyword">let</span> allInStock = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; products.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (products[i].<span class="property">stock</span> &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    allInStock = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 遇到不合格立即中断</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式验证方案</span></span><br><span class="line"><span class="keyword">const</span> isAllInStock = products.<span class="title function_">every</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="property">stock</span> &gt; <span class="number">0</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>

<p>当检测到首个不满足条件的元素时，遍历立即终止。该方法常与 <code>some()</code> 形成逻辑互补（全员满足 vs 至少一个满足），在表单验证、权限检查等场景中极为实用。</p>
<h3 id="Array-其他方法"><a href="#Array-其他方法" class="headerlink" title="Array 其他方法"></a>Array 其他方法</h3><h4 id="存在性检测：some"><a href="#存在性检测：some" class="headerlink" title="存在性检测：some()"></a>存在性检测：<code>some()</code></h4><p>与 <code>every()</code> 形成逻辑互补，当数组中<strong>至少有一个元素</strong>满足条件时即返回 <code>true</code>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hasNegative = [<span class="number">1</span>, -<span class="number">5</span>, <span class="number">3</span>].<span class="title function_">some</span>(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p>典型应用场景：权限检查（至少拥有一个权限）、表单验证（存在非法输入）</p>
<h4 id="数组合并：concat"><a href="#数组合并：concat" class="headerlink" title="数组合并：concat()"></a>数组合并：<code>concat()</code></h4><p><strong>安全合并</strong>多个数组（不修改原数组）：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> merged = arr1.<span class="title function_">concat</span>(arr2); <span class="comment">// [1,2,3]（原数组保持不变）</span></span><br></pre></td></tr></table></figure></div>

<p>特别说明：现代开发更常用扩展运算符 <code>[...arr1, ...arr2]</code></p>
<h4 id="排序控制：sort"><a href="#排序控制：sort" class="headerlink" title="排序控制：sort()"></a>排序控制：<code>sort()</code></h4><p><strong>原地排序</strong>（修改原数组），默认按字符串 Unicode 排序：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">40</span>];</span><br><span class="line">nums.<span class="title function_">sort</span>(); <span class="comment">// [10, 40, 5]（字典序排列）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确数字排序需比较函数</span></span><br><span class="line">nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b); <span class="comment">// [5, 10, 40]</span></span><br></pre></td></tr></table></figure></div>

<p>关键注意：比较函数返回负数&#x2F;0&#x2F;正数决定排序顺序</p>
<h4 id="动态修改：splice"><a href="#动态修改：splice" class="headerlink" title="动态修改：splice()"></a>动态修改：<code>splice()</code></h4><p><strong>最灵活</strong>的数组修改方法（可删除&#x2F;替换&#x2F;添加元素）：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>); <span class="comment">// 从索引1开始删除1个元素，插入&#x27;x&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [&#x27;a&#x27;, &#x27;x&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure></div>

<p>参数模式：<br><code>startIndex</code> → 起始位置<br><code>deleteCount</code> → 删除数量<br><code>...items</code> → 插入的新元素</p>
<h4 id="结构反转：reverse"><a href="#结构反转：reverse" class="headerlink" title="结构反转：reverse()"></a>结构反转：<code>reverse()</code></h4><p><strong>原地反转</strong>数组元素顺序：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> letters = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">letters.<span class="title function_">reverse</span>(); <span class="comment">// [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]（原数组被修改）</span></span><br></pre></td></tr></table></figure></div>

<p>典型用途：处理栈结构、展示倒序列表</p>
<h4 id="索引定位：findIndex"><a href="#索引定位：findIndex" class="headerlink" title="索引定位：findIndex()"></a>索引定位：<code>findIndex()</code></h4><p>与 <code>find()</code> 逻辑一致，但返回元素的<strong>索引值</strong>（未找到返回-1）：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> users = [&#123;<span class="attr">id</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">id</span>:<span class="number">2</span>&#125;];</span><br><span class="line"><span class="keyword">const</span> index = users.<span class="title function_">findIndex</span>(<span class="function"><span class="params">u</span> =&gt;</span> u.<span class="property">id</span> === <span class="number">2</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></div>

<p>特别适配场景：需要索引进行后续操作（如结合 <code>splice</code> 删除元素）</p>
<h4 id="结构转换：Array-from"><a href="#结构转换：Array-from" class="headerlink" title="结构转换：Array.from()"></a>结构转换：<code>Array.from()</code></h4><p>将类数组结构（含 length 属性）转换为标准数组：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 新数组 = <span class="title class_">Array</span>.<span class="title function_">from</span>(伪数组)</span><br></pre></td></tr></table></figure></div>

<p><strong>典型场景</strong>：处理 DOM 元素集合或 arguments 对象</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DOM 操作场景</span></span><br><span class="line"><span class="keyword">const</span> divList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>); <span class="comment">// NodeList 伪数组</span></span><br><span class="line"><span class="keyword">const</span> realArray = <span class="title class_">Array</span>.<span class="title function_">from</span>(divList); <span class="comment">// 可调用数组方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传统方案对比</span></span><br><span class="line"><span class="keyword">const</span> oldWay = [].<span class="property">slice</span>.<span class="title function_">call</span>(divList); <span class="comment">// ES5 转换方式</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Array-方法总结"><a href="#Array-方法总结" class="headerlink" title="Array 方法总结"></a>Array 方法总结</h3><h4 id="基础必备"><a href="#基础必备" class="headerlink" title="基础必备"></a>基础必备</h4><p><strong>（处理数据必用，每天写代码都离不开）</strong></p>
<p><strong>1. <code>forEach</code> (重点)</strong><br>最简单的遍历方法，<strong>替代<code>for</code>循环</strong>的最佳选择。就像自动售货机——投币（数组）后自动吐出每个商品（元素），你只需要处理每个商品：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;牛奶&#x27;</span>, <span class="string">&#x27;面包&#x27;</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">商品, 序号</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第<span class="subst">$&#123;序号+<span class="number">1</span>&#125;</span>件：<span class="subst">$&#123;商品&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出：第1件：牛奶 → 第2件：面包</span></span><br></pre></td></tr></table></figure></div>

<p>⚠️ <strong>注意</strong>：不能中途<code>break</code>停止，需要中断时用<code>for</code>循环</p>
<p><strong>2. <code>map</code> (重点)</strong><br><strong>数据变形金刚</strong>，把数组中的每个元素变成新模样，且<strong>不修改原数组</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 价格 = [<span class="number">100</span>, <span class="number">200</span>]</span><br><span class="line"><span class="keyword">const</span> 打折价 = 价格.<span class="title function_">map</span>(原价 =&gt; 原价 * <span class="number">0.8</span>) <span class="comment">// [80, 160]</span></span><br></pre></td></tr></table></figure></div>

<p>🛠️ <strong>经典场景</strong>：接口数据转换（API 返回的数据 → 前端需要的格式）</p>
<p><strong>3. <code>filter</code> (重点)</strong><br><strong>数据过滤器</strong>，只留下符合条件的元素：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 用户列表 = [&#123;年龄:<span class="number">17</span>&#125;, &#123;年龄:<span class="number">20</span>&#125;]</span><br><span class="line"><span class="keyword">const</span> 成年人 = 用户列表.<span class="title function_">filter</span>(用户 =&gt; 用户.年龄 &gt;= <span class="number">18</span>) <span class="comment">// [&#123;年龄:20&#125;]</span></span><br></pre></td></tr></table></figure></div>

<p>⚠️ <strong>陷阱</strong>：<code>filter(item =&gt; item.prop)</code> 会过滤掉<code>prop</code>为<code>0</code>或<code>false</code>的合法值</p>
<h4 id="进阶必备"><a href="#进阶必备" class="headerlink" title="进阶必备"></a>进阶必备</h4><p><strong>（提升代码效率，处理复杂场景）</strong></p>
<p><strong>4. <code>reduce</code> (重点)</strong><br><strong>数据聚合器</strong>，把数组浓缩成一个值（数字&#x2F;对象&#x2F;新数组）：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算总价</span></span><br><span class="line"><span class="keyword">const</span> 购物车 = [&#123;价格:<span class="number">100</span>&#125;, &#123;价格:<span class="number">200</span>&#125;]</span><br><span class="line"><span class="keyword">const</span> 总价 = 购物车.<span class="title function_">reduce</span>(<span class="function">(<span class="params">累计, 商品</span>) =&gt;</span> 累计 + 商品.价格, <span class="number">0</span>) <span class="comment">// 300</span></span><br></pre></td></tr></table></figure></div>

<p>🔥 <strong>高阶用法</strong>：统计词频、扁平化嵌套数组</p>
<p><strong>5. <code>find</code> (重点)</strong><br><strong>精准搜索</strong>，找到第一个符合条件的元素（比<code>filter</code>更快）：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 订单列表 = [&#123;<span class="attr">id</span>:<span class="number">1</span>, 状态:<span class="string">&#x27;未支付&#x27;</span>&#125;, &#123;<span class="attr">id</span>:<span class="number">2</span>, 状态:<span class="string">&#x27;已发货&#x27;</span>&#125;]</span><br><span class="line"><span class="keyword">const</span> 待处理订单 = 订单列表.<span class="title function_">find</span>(订单 =&gt; 订单.状态 === <span class="string">&#x27;未支付&#x27;</span>) <span class="comment">// &#123;id:1...&#125;</span></span><br></pre></td></tr></table></figure></div>

<p>⚠️ <strong>注意</strong>：找不到时返回<code>undefined</code>，要用<code>if</code>判断结果是否存在</p>
<h4 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h4><table>
<thead>
<tr>
<th>方法</th>
<th>一句话功能</th>
<th>使用示例</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td><code>some</code></td>
<td><strong>至少一个满足条件</strong></td>
<td><code>[1, -2].some(n =&gt; n&lt;0) → true</code></td>
<td>和<code>every</code>相反</td>
</tr>
<tr>
<td><code>concat</code></td>
<td><strong>合并数组</strong></td>
<td><code>[1].concat([2]) → [1,2]</code></td>
<td>用<code>[...arr1,...arr2]</code>更现代</td>
</tr>
<tr>
<td><code>sort</code></td>
<td><strong>排序</strong></td>
<td><code>[10,2].sort((a,b)=&gt;a-b) → [2,10]</code></td>
<td>必须传比较函数！</td>
</tr>
<tr>
<td><code>splice</code></td>
<td><strong>增删改元素</strong></td>
<td><code>arr.splice(1,0,&#39;新增&#39;)</code> 插入元素</td>
<td>直接修改原数组</td>
</tr>
<tr>
<td><code>findIndex</code></td>
<td><strong>找元素位置</strong></td>
<td><code>[&#39;a&#39;,&#39;b&#39;].findIndex(v=&gt;v===&#39;b&#39;) → 1</code></td>
<td>找不到返回-1</td>
</tr>
</tbody></table>
<ul>
<li>**<code>forEach</code>**：每个都做点什么</li>
<li>**<code>map</code>**：每个都变个样子</li>
<li>**<code>filter</code>**：好的留下，坏的不要</li>
<li>**<code>reduce</code>**：多个变一个</li>
<li>**<code>find</code>**：抓住第一个符合条件的</li>
</ul>
<h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>String，Number，Boolean 等</p>
<h3 id="String-重点方法"><a href="#String-重点方法" class="headerlink" title="String 重点方法"></a>String 重点方法</h3><h4 id="结构拆分：-split"><a href="#结构拆分：-split" class="headerlink" title="结构拆分：.split()"></a>结构拆分：<code>.split()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> 数组 = 字符串.<span class="title function_">split</span>(分隔符)</span><br></pre></td></tr></table></figure></div>

<p><code>split()</code>  实现字符串与数组的高效双向转换，与数组的  <code>join()</code>  方法形成互逆操作，构建字符串 ↔ 数组转换闭环。<br>其核心价值在于<strong>结构化数据处理</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统方案：手动拆分</span></span><br><span class="line"><span class="keyword">const</span> csv = <span class="string">&#x27;张三,25,男&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line"><span class="keyword">let</span> temp = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> csv) &#123;</span><br><span class="line">  <span class="keyword">if</span> (char === <span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">    data.<span class="title function_">push</span>(temp);</span><br><span class="line">    temp = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    temp += char;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">data.<span class="title function_">push</span>(temp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代拆分方案</span></span><br><span class="line"><span class="keyword">const</span> data = csv.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// [&quot;张三&quot;, &quot;25&quot;, &quot;男&quot;]</span></span><br></pre></td></tr></table></figure></div>

<p>分隔符支持正则表达式（如  <code>/\s+/</code>  匹配连续空格），连续分隔符会产生空元素，第二参数控制最大分段数量</p>
<h4 id="精准截取：-substring"><a href="#精准截取：-substring" class="headerlink" title="精准截取：.substring()"></a>精准截取：<code>.substring()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串.<span class="title function_">substring</span>(起始索引[, 结束索引]) <span class="comment">// 截取内容不包含结束索引号的内容</span></span><br></pre></td></tr></table></figure></div>

<p>与 <code>slice()</code> 方法类似，但<strong>不支持负索引</strong>，提供更安全的截取控制：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统字符操作</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;前端开发工程师&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">2</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">  result += str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代截取方案</span></span><br><span class="line"><span class="keyword">const</span> result = str.<span class="title function_">substring</span>(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">// &quot;开发&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>当起始索引大于结束索引时，<code>substring</code> 会自动调换参数，而 <code>slice</code> 返回空字符串。在表单输入截断等场景下更安全。自动处理起始&gt;结束的情况（交换参数）超范围索引自动截断到有效范围</p>
<h4 id="前缀检测：-startsWith"><a href="#前缀检测：-startsWith" class="headerlink" title="前缀检测：.startsWith()"></a>前缀检测：<code>.startsWith()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串.<span class="title function_">startsWith</span>(检测字符串[, 起始位置])</span><br></pre></td></tr></table></figure></div>

<p>实现精准的头部匹配检测，<strong>替代正则检测的轻量方案</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统方案</span></span><br><span class="line"><span class="keyword">const</span> isHttps = url.<span class="title function_">indexOf</span>(<span class="string">&#x27;https://&#x27;</span>) === <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代检测方案</span></span><br><span class="line"><span class="keyword">const</span> isHttps = url.<span class="title function_">startsWith</span>(<span class="string">&#x27;https://&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>典型应用</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由检测</span></span><br><span class="line"><span class="keyword">if</span> (path.<span class="title function_">startsWith</span>(<span class="string">&#x27;/api&#x27;</span>, <span class="number">7</span>)) &#123;</span><br><span class="line">  <span class="comment">// 从第7字符开始检测</span></span><br><span class="line">  <span class="title function_">handleAPIRequest</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="存在性判断：-includes"><a href="#存在性判断：-includes" class="headerlink" title="存在性判断：.includes()"></a>存在性判断：<code>.includes()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串.<span class="title function_">includes</span>(搜索字符串[, 起始位置])</span><br></pre></td></tr></table></figure></div>

<p>提供更直观的包含性检测，<strong>替代 <code>indexOf</code> 的现代方案</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统检测</span></span><br><span class="line"><span class="keyword">const</span> isValid = content.<span class="title function_">indexOf</span>(<span class="string">&#x27;重要通知&#x27;</span>) !== -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语义化检测</span></span><br><span class="line"><span class="keyword">const</span> isValid = content.<span class="title function_">includes</span>(<span class="string">&#x27;重要通知&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p>与数组的 <code>includes</code> 方法形成语法统一，降低记忆成本。注意对大小写敏感，必要时先统一大小写。</p>
<h3 id="String-其他方法"><a href="#String-其他方法" class="headerlink" title="String 其他方法"></a>String 其他方法</h3><h4 id="大小写转换：-toUpper-LowerCase"><a href="#大小写转换：-toUpper-LowerCase" class="headerlink" title="大小写转换：.toUpper/LowerCase()"></a>大小写转换：<code>.toUpper/LowerCase()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串.<span class="title function_">toUpperCase</span>()  <span class="comment">// 全大写转换</span></span><br><span class="line">字符串.<span class="title function_">toLowerCase</span>()  <span class="comment">// 全小写转换</span></span><br></pre></td></tr></table></figure></div>

<h4 id="位置定位：-indexOf"><a href="#位置定位：-indexOf" class="headerlink" title="位置定位：.indexOf()"></a>位置定位：<code>.indexOf()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串.<span class="title function_">indexOf</span>(搜索值[, 起始位置])</span><br></pre></td></tr></table></figure></div>

<p>返回<strong>首次出现位置的索引</strong>（未找到返回 -1），适合精确查找：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件类型检测</span></span><br><span class="line"><span class="keyword">const</span> fileName = <span class="string">&#x27;report.pdf&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (fileName.<span class="title function_">indexOf</span>(<span class="string">&#x27;.pdf&#x27;</span>) !== -<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="title function_">showPreview</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="后缀检测：-endsWith"><a href="#后缀检测：-endsWith" class="headerlink" title="后缀检测：.endsWith()"></a>后缀检测：<code>.endsWith()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串.<span class="title function_">endsWith</span>(检测字符串[, 检测长度])</span><br></pre></td></tr></table></figure></div>

<p>常用于文件格式验证，<strong>支持限定检测范围</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图片格式校验</span></span><br><span class="line"><span class="keyword">const</span> isValidImage = [<span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>].<span class="title function_">some</span>(<span class="function"><span class="params">ext</span> =&gt;</span></span><br><span class="line">  fileName.<span class="title function_">endsWith</span>(<span class="string">`.<span class="subst">$&#123;ext&#125;</span>`</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h4 id="模式替换：-replace"><a href="#模式替换：-replace" class="headerlink" title="模式替换：.replace()"></a>模式替换：<code>.replace()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串.<span class="title function_">replace</span>(匹配模式, 替换内容)</span><br></pre></td></tr></table></figure></div>

<p>支持<strong>正则表达式替换</strong>，实现灵活字符串处理：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 日期格式转换</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="string">&#x27;2023-08-15&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/-/g</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;2023/08/15&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险字符过滤</span></span><br><span class="line"><span class="keyword">const</span> safeText = input.<span class="title function_">replace</span>(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="模式匹配：-match"><a href="#模式匹配：-match" class="headerlink" title="模式匹配：.match()"></a>模式匹配：<code>.match()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">字符串.<span class="title function_">match</span>(正则表达式)</span><br></pre></td></tr></table></figure></div>

<p>返回匹配结果的数组，<strong>捕获组信息完整保留</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提取颜色代码</span></span><br><span class="line"><span class="keyword">const</span> hexCodes = <span class="string">&#x27;色值：#FF0000 #00FF00&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/#[0-9A-F]&#123;6&#125;/g</span>);</span><br><span class="line"><span class="comment">// [&quot;#FF0000&quot;, &quot;#00FF00&quot;]</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><h4 id="数值格式化：-toFixed"><a href="#数值格式化：-toFixed" class="headerlink" title="数值格式化：.toFixed()"></a>数值格式化：<code>.toFixed()</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">数值.<span class="title function_">toFixed</span>(保留小数位数)</span><br></pre></td></tr></table></figure></div>

<p><code>toFixed()</code> 实现数值的精确舍入与格式化输出，如同会计记账时的金额规范处理。通过对比可见其如何简化数值控制逻辑：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传统手工计算方案</span></span><br><span class="line"><span class="keyword">const</span> price = <span class="number">12.345</span>;</span><br><span class="line"><span class="keyword">let</span> fixedPrice = <span class="title class_">Math</span>.<span class="title function_">round</span>(price * <span class="number">100</span>) / <span class="number">100</span>; <span class="comment">// 12.35</span></span><br><span class="line"><span class="comment">// 补足小数点后两位</span></span><br><span class="line">fixedPrice = fixedPrice.<span class="title function_">toString</span>().<span class="title function_">includes</span>(<span class="string">&#x27;.&#x27;</span>) ? fixedPrice : fixedPrice + <span class="string">&#x27;.00&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代格式化方案</span></span><br><span class="line"><span class="keyword">const</span> formatted = price.<span class="title function_">toFixed</span>(<span class="number">2</span>); <span class="comment">// &quot;12.35&quot;（自动补零）</span></span><br></pre></td></tr></table></figure></div>

<p>与手动计算不同，<code>toFixed</code> 自动处理四舍五入和末尾补零，返回<strong>标准化字符串</strong>。此方法与字符串的 <code>parseFloat</code> 形成数据处理闭环：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 金额输入校验场景</span></span><br><span class="line"><span class="keyword">const</span> input = <span class="string">&quot;12.3&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> validValue = <span class="built_in">parseFloat</span>(input).<span class="title function_">toFixed</span>(<span class="number">2</span>); <span class="comment">// &quot;12.30&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>小数位不足时自动补零（如 <code>5.toFixed(2)→&quot;5.00&quot;</code>）采用国际标准四舍六入五成双规则始终返回字符串以避免精度丢失，需配合 <code>Number()</code> 转换使用</p>
<h1 id="深入对象"><a href="#深入对象" class="headerlink" title="深入对象"></a>深入对象</h1><h3 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h3><p><strong>面向过程编程</strong><br>如同制作蛋炒饭的过程：</p>
<p>先热锅、倒油、炒蛋、加饭、翻炒调味，每个步骤都需要严格按照顺序执行。</p>
<p>这种编程方式将问题分解为线性步骤，通过函数调用逐步实现：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 制作蛋炒饭的代码模拟</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">heatPan</span>(<span class="params"></span>) &#123; <span class="comment">/* 热锅逻辑 */</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addOil</span>(<span class="params"></span>) &#123; <span class="comment">/* 倒油逻辑 */</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fryEgg</span>(<span class="params"></span>) &#123; <span class="comment">/* 炒蛋逻辑 */</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cookRice</span>(<span class="params"></span>) &#123; <span class="comment">/* 加饭逻辑 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按步骤执行</span></span><br><span class="line"><span class="title function_">heatPan</span>();</span><br><span class="line"><span class="title function_">addOil</span>();</span><br><span class="line"><span class="title function_">fryEgg</span>();</span><br><span class="line"><span class="title function_">cookRice</span>();</span><br></pre></td></tr></table></figure></div>

<p>其优势在于执行效率高（适合硬件操作、单片机开发），但维护困难——若要调整加饭和炒蛋的顺序，需要重写整个流程。<br>如同修改食谱步骤，可能影响最终成品。</p>
<p><strong>面向对象编程（OOP）</strong><br>更像盖浇饭的制作：将食材处理、酱料调配、摆盘装饰等功能拆分给不同厨师（对象），通过分工合作完成菜品。每个对象承担独立职责，彼此通过接口协作：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 盖浇饭对象协作模拟</span></span><br><span class="line"><span class="keyword">const</span> riceChef = &#123;</span><br><span class="line">  <span class="attr">cook</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/* 蒸饭逻辑 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> toppingChef = &#123;</span><br><span class="line">  <span class="attr">prepare</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/* 备浇头逻辑 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> plater = &#123;</span><br><span class="line">  <span class="attr">serve</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/* 摆盘逻辑 */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象间协作</span></span><br><span class="line">riceChef.<span class="title function_">cook</span>();</span><br><span class="line">toppingChef.<span class="title function_">prepare</span>();</span><br><span class="line">plater.<span class="title function_">serve</span>();</span><br></pre></td></tr></table></figure></div>

<p>这种模式更易维护和扩展——若要新增「辣味浇头」，只需扩展 <code>toppingChef</code> 对象，无需修改其他部分。其代价是性能略低于面向过程，但为大型项目提供了更好的灵活性和协作性。</p>
<h3 id="构造函数封装"><a href="#构造函数封装" class="headerlink" title="构造函数封装"></a>构造函数封装</h3><p>JavaScript 通过构造函数实现面向对象的<strong>封装性</strong>，将数据与操作数据的方法组合成独立对象：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Wolf</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;  <span class="comment">// 属性封装</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">howl</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  <span class="comment">// 方法封装</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我会嚎叫&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">const</span> greyWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;灰太狼&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> redWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;红太狼&#x27;</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure></div>

<p>此时  <code>greyWolf.howl === redWolf.howl</code>  返回  <code>false</code>，说明每只狼的  <code>howl</code>  方法都是独立创建的。如同为每匹狼单独配备嚎叫设备，虽能正常工作，但造成了资源浪费。</p>
<p>当创建大量狼对象时，重复定义方法会导致显著的内存浪费。<br>这种设计下，若有 1000 匹狼，就会产生 1000 个功能相同的  <code>howl</code>  方法副本，严重消耗内存资源。</p>
<h3 id="构造函数封装-1"><a href="#构造函数封装-1" class="headerlink" title="构造函数封装"></a>构造函数封装</h3><p>JavaScript 通过构造函数实现面向对象的<strong>封装性</strong>，将生物特征与行为模式组合成独立对象：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Wolf</span>(<span class="params">species, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">species</span> = species;  <span class="comment">// 品种属性封装（如北极狼/墨西哥狼）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">howl</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  <span class="comment">// 实例方法封装</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.species&#125;</span>发出低频嚎叫（120-180Hz）`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化不同亚种</span></span><br><span class="line"><span class="keyword">const</span> arcticWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;北极狼&#x27;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> mexicanWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;墨西哥狼&#x27;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arcticWolf.<span class="property">howl</span> === mexicanWolf.<span class="property">howl</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>

<p>此时每个狼实例都携带独立的 <code>howl</code> 方法副本，如同为每匹狼配备专用声带系统。当建立狼群时（如 1000 匹规模的群体），会造成显著的内存冗余。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h4 id="原型对象-prototype"><a href="#原型对象-prototype" class="headerlink" title="原型对象 prototype"></a>原型对象 <code>prototype</code></h4><p>每个 ​<strong>​ 构造函数 ​</strong>​ 在创建时自动获得一个名为  <code>prototype</code>  的 ​<strong>​ 原型对象 ​</strong>​，该对象专门用于存储同类实例共享的方法。<br>通过将方法定义在原型对象上，所有通过该构造函数生成的实例均可访问这些方法，实现内存的高效利用。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Wolf</span>(<span class="params">species, age</span>) &#123;</span><br><span class="line">  <span class="comment">// 实例独有属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">species</span> = species;  <span class="comment">// 品种学名（如Canis lupus arctos）</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;          <span class="comment">// 年龄（月）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享行为定义</span></span><br><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Wolf</span>,  <span class="comment">// 关键构造关联</span></span><br><span class="line">  <span class="attr">howl</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.species&#125;</span>发出领地性嚎叫（持续6-8秒）`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">hunt</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.species&#125;</span>启动群体捕猎模式`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例验证</span></span><br><span class="line"><span class="keyword">const</span> eurasianWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;欧亚狼&#x27;</span>, <span class="number">48</span>);</span><br><span class="line"><span class="keyword">const</span> himalayanWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;喜马拉雅狼&#x27;</span>, <span class="number">36</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(eurasianWolf.<span class="property">howl</span> === himalayanWolf.<span class="property">howl</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h4 id="原型方法中的-this"><a href="#原型方法中的-this" class="headerlink" title="原型方法中的 this"></a>原型方法中的 this</h4><p>原型方法中的  <code>this</code>  始终指向调用该方法的实例对象，这是实现状态独立的核心。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">establishTerritory</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// this 指向调用实例</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.species&#125;</span>标记 <span class="subst">$&#123;<span class="variable language_">this</span>.age*<span class="number">10</span>&#125;</span> 平方公里领地`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> greyWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;灰狼&#x27;</span>, <span class="number">60</span>);</span><br><span class="line">greyWolf.<span class="title function_">establishTerritory</span>();  <span class="comment">// 输出：灰狼标记 600 平方公里领地</span></span><br></pre></td></tr></table></figure></div>

<p>若错误使用箭头函数定义原型方法，会导致  <code>this</code>  绑定失效。</p>
<h3 id="原型链维护规范"><a href="#原型链维护规范" class="headerlink" title="原型链维护规范"></a>原型链维护规范</h3><h4 id="constructor-修复机制"><a href="#constructor-修复机制" class="headerlink" title="constructor 修复机制"></a><code>constructor</code> 修复机制</h4><p>在 JavaScript 的原型继承体系中，每个构造函数的原型对象（prototype）默认包含一个 constructor 属性指向构造函数本身。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E8%BF%9B%E9%98%B6/file-20250409134414448.jpg"
                     
                ></p>
<p>开发中常遇到需批量添加原型方法的场景。若采用直接赋值方式覆盖原型对象（而非属性追加方式），会破坏原型链的完整性：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Wolf</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始状态 ✅</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Wolf</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险操作：覆盖原型导致关联断裂 ❌</span></span><br><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">trackMigration</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;追踪迁徙路线&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>覆盖原型时必须手动重建构造函数关联：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修复方案 ✅</span></span><br><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: <span class="title class_">Wolf</span>,  <span class="comment">// 重建关联</span></span><br><span class="line">  <span class="attr">trackMigration</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p>后续通过  <code>new</code>  创建的实例才能正确继承构造函数类型特征。</p>
<h4 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型 __proto__"></a>对象原型 <code>__proto__</code></h4><p>实例对象的  <code>__proto__</code>  属性（现代规范中对应 <code>[[Prototype]]</code> 内部插槽）构成原型链的核心链路。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E8%BF%9B%E9%98%B6/file-20250409134952442.jpg"
                     
                ></p>
<p>该属性指向其构造函数的原型对象（prototype），实现继承关系：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ArcticWolf</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">furType</span> = <span class="string">&#x27;双层被毛&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义群体通讯协议</span></span><br><span class="line"><span class="title class_">ArcticWolf</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">snowCommunication</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;使用低频震动传递位置信息&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alphaWolf = <span class="keyword">new</span> <span class="title class_">ArcticWolf</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链验证</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(alphaWolf.<span class="property">__proto__</span> === <span class="title class_">ArcticWolf</span>.<span class="property"><span class="keyword">prototype</span></span>);  <span class="comment">// true</span></span><br><span class="line">alphaWolf.<span class="title function_">snowCommunication</span>();  <span class="comment">// 通过原型链访问</span></span><br></pre></td></tr></table></figure></div>

<h3 id="三要素关系体系"><a href="#三要素关系体系" class="headerlink" title="三要素关系体系"></a>三要素关系体系</h3><pre class="mermaid">graph TD
    A[构造函数 Wolf] -->|"prototype 属性"| B[原型对象 Wolf.prototype]
    B -->|"constructor 属性"| A
    A -->|"new 操作符"| C[实例 alphaWolf]
    C -->|"__proto__ 属性"| B
    C -.->|"constructor 查找路径 <br>（通过原型链访问）"| A
    B -.->|"共享方法调用 <br>（如howl/hunt）"| C</pre>

<p><strong>构造函数的 <code>prototype</code></strong><br> 存储当前构造函数所有实例的<strong>共享方法</strong>，该属性是一个独立对象，通过  <code>Wolf.prototype.howl</code>  定义的方法可被所有狼实例调用：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">groupHunt</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.species&#125;</span>发起群体围猎`</span>);</span><br><span class="line">&#125;; <span class="comment">// 所有实例共享此方法</span></span><br></pre></td></tr></table></figure></div>

<p><strong>实例的 <code>__proto__</code></strong><br> 实例对象的隐式链接属性，指向其构造函数的原型对象。通过此属性实现原型链查找机制。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> juvenileWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>(<span class="string">&#x27;幼狼&#x27;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(juvenileWolf.<span class="property">__proto__</span> === <span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 查找 howl 方法流程：juvenileWolf → __proto__ → Wolf.prototype</span></span><br></pre></td></tr></table></figure></div>

<p><strong>原型的 <code>constructor</code></strong><br> 原型对象的反向指针，指向其关联的构造函数。此属性是维护类型系统的关键：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Wolf</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 确保 new 操作符的正确性</span></span><br></pre></td></tr></table></figure></div>

<h2 id="继承机制核心原理"><a href="#继承机制核心原理" class="headerlink" title="继承机制核心原理"></a>继承机制核心原理</h2><p>通过原型链（Prototype Chain）实现属性和方法的层级共享。子类构造函数通过原型对象继承父类特性，形成「实例-子类原型-父类原型」的链式结构。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生物基类（父类）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Creature</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lifeSpan</span> = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Creature</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">breathe</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进行气体交换&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哺乳动物子类</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Mammal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">bloodType</span> = <span class="string">&#x27;warm&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Mammal</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Creature</span>();  <span class="comment">// 建立继承链</span></span><br><span class="line"><span class="title class_">Mammal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Mammal</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 狼类继承哺乳动物</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Wolf</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">species</span> = <span class="string">&#x27;Canis lupus&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Mammal</span>();</span><br><span class="line"><span class="title class_">Wolf</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Wolf</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arcticWolf = <span class="keyword">new</span> <span class="title class_">Wolf</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arcticWolf.<span class="property">lifeSpan</span>); <span class="comment">// 100（通过三级原型链继承）</span></span><br></pre></td></tr></table></figure></div>

<p>当多个子类直接继承同一个原型对象时，会导致意外共享修改：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">genes</span> = <span class="string">&#x27;XY&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 危险继承方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Man</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Woman</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享父类原型</span></span><br><span class="line"><span class="title class_">Man</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="title class_">Woman</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给女性添加专属方法</span></span><br><span class="line"><span class="title class_">Woman</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pregnancy</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;妊娠周期280天&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> male = <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">male.<span class="title function_">pregnancy</span>(); <span class="comment">// 异常：男性实例错误获得女性方法</span></span><br></pre></td></tr></table></figure></div>

<p><code>Man</code> 和 <code>Woman</code> 的原型指向同一内存地址，修改会相互影响。</p>
<p>通过中间构造函数创建独立的原型副本：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">genes</span> = <span class="string">&#x27;XY&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">Child, Parent</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> F = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;  <span class="comment">// 缓冲构造函数</span></span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();  <span class="comment">// 生成独立原型</span></span><br><span class="line">  <span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Child</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全继承实现</span></span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Man</span>, <span class="title class_">Person</span>);</span><br><span class="line"><span class="title function_">extend</span>(<span class="title class_">Woman</span>, <span class="title class_">Person</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加专属方法</span></span><br><span class="line"><span class="title class_">Woman</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">pregnancy</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> male = <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">male.<span class="title function_">pregnancy</span>(); <span class="comment">// TypeError: 方法不存在</span></span><br></pre></td></tr></table></figure></div>

<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链是基于原型对象的继承查找机制，通过将不同构造函数的原型对象（prototype）按层级关联形成的链状结构。</p>
<p>当访问对象属性&#x2F;方法时，解释器按以下顺序查找：</p>
<ol>
<li><strong>对象自身属性</strong>：优先在对象实例中查找是否存在目标属性</li>
<li><strong>原型对象查找</strong>：未找到时，通过  <code>__proto__</code>  属性（注：对象的内部原型指针）查找其构造函数对应的原型对象（prototype）</li>
<li><strong>原型链追溯</strong>：若仍未找到，则继续向上一级原型对象（Object.prototype）追溯</li>
<li><strong>终止条件</strong>：最终到达 Object.prototype 的  <code>__proto__</code>（值为 null）时停止查找</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E8%BF%9B%E9%98%B6/file-20250409204433251.jpg"
                     
                ></p>
<p><code>instanceof</code>  运算符通过原型链检测对象类型：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 业务场景示例：设备权限校验</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SensorDevice</span> &#123;&#125;  <span class="comment">// 传感器基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TemperatureSensor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">SensorDevice</span> &#123;&#125;  <span class="comment">// 温度传感器子类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sensor = <span class="keyword">new</span> <span class="title class_">TemperatureSensor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链检测：sensor -&gt; TemperatureSensor.prototype -&gt; SensorDevice.prototype -&gt; Object.prototype</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sensor <span class="keyword">instanceof</span> <span class="title class_">SensorDevice</span>);  <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure></div>

<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><p>深浅拷贝仅针对数组、对象等引用类型数据（堆内存存储结构）</p>
<p>直接赋值会导致新旧对象完全关联，而拷贝操作能在堆内存中创建独立的新空间，实现不同程度的独立性。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> directCopy = obj;  <span class="comment">// 直接赋值</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>本质</strong>：复制栈内存中的指针地址</li>
<li><strong>特点</strong>：新旧变量共享同一内存空间，修改任意一方都会影响另一方</li>
</ul>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝仅复制第一层简单类型值，而嵌套的引用类型仍指向原地址。</p>
<p>实现浅拷贝的主要方式包括 - 使用  <code>Object.assign()</code>  方法和展开运算符  <code>...</code><br>对于数组类型，可通过  <code>concat()</code>、<code>slice()</code>  或展开运算符实现。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;pink&#x27;</span>, <span class="attr">info</span>: &#123; <span class="attr">age</span>: <span class="number">18</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> shallowCopy1 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="keyword">const</span> shallowCopy2 = &#123; ...obj &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组浅拷贝</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">const</span> shallowArr1 = arr.<span class="title function_">concat</span>();</span><br><span class="line"><span class="keyword">const</span> shallowArr2 = [...arr];</span><br></pre></td></tr></table></figure></div>

<p>这些方法共同特点是：创建新对象并复制原始对象的第一层属性，当属性值为引用类型时，新旧对象会共享该属性的内存地址。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">shallowCopy1.<span class="property">name</span> = <span class="string">&#x27;red&#x27;</span>;      <span class="comment">// 修改表层属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);          <span class="comment">// 输出 &#x27;pink&#x27;（未受影响）</span></span><br><span class="line"></span><br><span class="line">shallowCopy1.<span class="property">info</span>.<span class="property">age</span> = <span class="number">20</span>;     <span class="comment">// 修改深层属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">info</span>.<span class="property">age</span>);      <span class="comment">// 输出 20（同步变化）</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>✅ 隔离第一层数据</li>
<li>❌ 共享嵌套引用</li>
<li>⚠️ 适用于单层结构对象</li>
</ul>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝递归复制所有层级属性（创建完全独立的数据副本）。</p>
<p><strong>递归实现</strong><br>递归是深拷贝的核心实现原理，通过函数自调用遍历对象所有层级。基础实现需注意两点：终止条件（处理非对象类型）和特殊对象类型的处理（如数组）。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="comment">// 终止条件：非对象类型直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span> || target === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建容器（识别数组类型）</span></span><br><span class="line">    <span class="keyword">const</span> clone = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历属性递归拷贝</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">            clone[key] = <span class="title function_">deepClone</span>(target[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: [<span class="number">2</span>, <span class="number">3</span>] &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> cloned = <span class="title function_">deepClone</span>(original);</span><br></pre></td></tr></table></figure></div>

<p><strong>优势</strong>：可处理循环引用<br><strong>注意</strong>：需处理特殊对象类型（如 Date、RegExp）</p>
<p><strong>JSON 序列化</strong><br>利用  <code>JSON.stringify()</code>  和  <code>JSON.parse()</code>  的组合可实现快速深拷贝，但需要注意其局限性：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> deepCopy = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj));</span><br></pre></td></tr></table></figure></div>

<ul>
<li>会丢失 undefined &#x2F; function</li>
<li>无法处理循环引用</li>
<li>破坏特殊对象（如 Date 转为字符串）</li>
</ul>
<p><strong>使用 Lodash 库</strong><br>Lodash 库的  <code>_.cloneDeep()</code>  方法提供生产级深拷贝方案，能正确处理各种边界情况：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入 Lodash 库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 包含特殊类型的对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> complexObj = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>(),         <span class="comment">// Date 对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">fn</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;测试函数&#x27;</span>),  <span class="comment">// 函数类型</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">regex</span>: <span class="regexp">/pattern/g</span>         <span class="comment">// 正则表达式</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 执行深拷贝</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> perfectCopy = _.<span class="title function_">cloneDeep</span>(complexObj);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>专业选择</strong>：处理各种边界情况的最佳实践</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>了解 JavaScript 中程序异常处理的方法，提升代码运行的健壮性。</p>
<h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>function counter（x,y）{<br>if（!x|l!y）{<br>&#x2F;&#x2F;throw‘参数不能为空！‘；<br>thrownewError（参数不能为空！）<br>return x+y<br>counter()</p>
<p>1.throw 抛出异常信息，程序也会终止执行<br>2.throw 后面跟的是错误提示信息<br>3.Error 对象配合 throw 使用，能够设置更详细的错误信息</p>
<p>1．抛出异常我们用那个关键字？它会终止程序吗？<br>》throw 关键字<br>》会中止程序 2.抛出异常经常和谁配合使用？<br>Error 对象配合 throw 使用</p>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h3><p>function fn(){<br>try {<br>&#x2F;1 可能发送错误的代码要写到 try<br>const p &#x3D; document.querySelector(‘.p’)<br>p.style.color &#x3D;’red’<br>catch （err）{<br>11 拦截错误，提示浏览器提供的错误信息，但是不中断程序的执行<br>console.log(err.message)<br>thrownewError（‘你看看，选择器错误了吧’）<br>&#x2F;&#x2F;需要加 return 中断程序<br>&#x2F;&#x2F;return<br>7<br>finally{<br>11 不管你程序对不对，一定会执行的代码<br>alert（弹出对话框 T)<br>console.log(11)<br>fn()<br>1．捕获异常我们用那 3 个关键字？</p>
<blockquote>
<p>try catch finally<br>try 2.怎么调用错误信息？<br>》利用 catch 的参数</p>
</blockquote>
<h3 id="debugger"><a href="#debugger" class="headerlink" title="debugger"></a>debugger</h3><p>我们可以通过 try&#x2F;catch 捕获错误信息（浏览器提供的错误信息）</p>
<h1 id="异常处理-1"><a href="#异常处理-1" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常处理是构建健壮应用的基石，能有效防止程序意外崩溃。JavaScript 提供了一套完整的错误控制机制，开发者通过合理运用可显著提升代码质量。</p>
<h3 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h3><p><code>throw</code>  语句用于主动触发异常流程，通常与内置  <code>Error</code>  对象配合使用。当执行到 throw 语句时，当前函数执行上下文立即终止，控制权移交最近的异常捕获块。基础使用范式：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">calculate</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;参数必须为有效数值&#x27;</span>); <span class="comment">// 创建错误实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">&#x27;number&#x27;</span> || <span class="keyword">typeof</span> y !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;参数类型必须为数字&#x27;</span>); <span class="comment">// 特定错误类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>错误类型细分</strong>：除基础 Error 外，JavaScript 提供多种派生错误类型 - <code>SyntaxError</code>：语法解析错误 - <code>TypeError</code>：类型操作错误 - <code>RangeError</code>：数值越界错误 - <code>ReferenceError</code>：引用错误</p>
<p><strong>自定义错误扩展</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NetworkError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">url</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(<span class="string">`EC002: <span class="subst">$&#123;url&#125;</span> 请求失败`</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">code</span> = <span class="string">&#x27;NET_ERR&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">timestamp</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NetworkError</span>(<span class="string">&#x27;/api/user&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p><strong>try&#x2F;catch&#x2F;finally 结构</strong><br>完整的异常处理单元包含三个逻辑块，执行流程如下图所示：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loadUserProfile</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 可能包含错误的代码</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123; <span class="comment">// 出错时跳转至 catch</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">// 无论出错都执行</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>应用场景：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 风险操作区</span></span><br><span class="line">    <span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.dynamic-content&#x27;</span>);</span><br><span class="line">    element.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;button&gt;点击&lt;/button&gt;&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 异常处理区</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`捕获异常: <span class="subst">$&#123;error.message&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误堆栈:&#x27;</span>, error.<span class="property">stack</span>);</span><br><span class="line">    <span class="comment">// 异常转换示例</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;界面渲染失败&#x27;</span>, &#123; <span class="attr">cause</span>: error &#125;);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 资源释放区</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;清理临时缓存...&#x27;</span>);</span><br><span class="line">    element = <span class="literal">null</span>; <span class="comment">// 防止内存泄漏</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong>错误隔离性</strong>：catch 仅捕获所在 try 块的异常</li>
<li><strong>作用域限制</strong>：try 内部声明的变量在外部不可访问</li>
<li><strong>资源保障</strong>：finally 区块始终执行，适合执行清理操作</li>
</ol>
<h2 id="浏览器调试"><a href="#浏览器调试" class="headerlink" title="浏览器调试"></a>浏览器调试</h2><p><code>debugger</code>  语句：代码中插入调试断点</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">complexCalculation</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">debugger</span>; <span class="comment">// 自动触发断点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        result += <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>使用场景</strong>：</p>
<ul>
<li>动态调试复杂逻辑</li>
<li>配合浏览器开发者工具进行单步调试</li>
<li>临时插入断点替代 console.log</li>
</ul>
<h1 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h1><p>JavaScript 中的 <code>this</code> 关键字在不同执行环境中具有动态绑定特性，其指向规则是语言的重要特性之一。</p>
<h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><p>普通函数的 <code>this</code> 值由<strong>调用方式</strong>决定，遵循”谁调用指向谁”的基本原则。当函数作为独立函数调用时，非严格模式下 <code>this</code> 默认指向全局对象（浏览器环境中为 <code>window</code>），严格模式下则指向 <code>undefined</code>。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础函数定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sayHello = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用（无明确调用者）</span></span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// window（非严格模式）/ undefined（严格模式）</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">sayHi</span>(); <span class="comment">// 显式绑定调用者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象方法调用</span></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">  <span class="attr">walk</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 指向user对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user.<span class="property">sayHi</span> = sayHi;</span><br><span class="line">user.<span class="property">sayHello</span> = sayHello;</span><br><span class="line">user.<span class="title function_">sayHi</span>(); <span class="comment">// this指向user对象</span></span><br></pre></td></tr></table></figure></div>

<p>严格模式通过 <code>&quot;use strict&quot;</code> 指令激活，该模式下未指定调用者时 <code>this</code> 值为 <code>undefined</code>。开发时应特别注意模式差异对代码行为的影响。</p>
<h3 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数采用<strong>词法作用域</strong>规则，其 <code>this</code> 值继承自外层最近的非箭头函数的 <code>this</code> 绑定。箭头函数自身不创建 <code>this</code> 绑定，这种特性使其特别适合需要保持上下文一致的场景。</p>
<p>当访问箭头函数中的 <code>this</code> 时，解释器将执行以下操作：</p>
<ol>
<li>检查当前函数作用域是否存在 <code>this</code> 定义</li>
<li>沿作用域链逐层向上查找</li>
<li>使用首个找到的有效 <code>this</code> 绑定</li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型方法误用示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">walk</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 继承全局作用域的this（window）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.<span class="title function_">walk</span>(); <span class="comment">// 输出window对象</span></span><br></pre></td></tr></table></figure></div>

<h3 id="改变-this"><a href="#改变-this" class="headerlink" title="改变 this"></a>改变 this</h3><p>在 JavaScript 中，可通过<code>call()</code>、<code>apply()</code>和<code>bind()</code>三种方法动态控制普通函数内部<code>this</code>的指向。这些方法虽功能相似，但在使用场景和执行逻辑上存在明显差异。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p><strong><code>call()</code>方法通过立即执行函数实现<code>this</code>指向的修改</strong>。其语法为：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">fun.<span class="title function_">call</span>(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></div>

<p>其中<code>thisArg</code>为函数运行时指定的<code>this</code>值，后续参数以逗号分隔逐个传递。例如：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">uname</span>: <span class="string">&#x27;pink&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 输出obj对象</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y); <span class="comment">// 输出3</span></span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="title function_">call</span>(obj, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 立即执行函数，this指向obj</span></span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong>：直接调用函数，适合需要明确参数数量和立即执行的场景。</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p><strong><code>apply()</code>方法与<code>call()</code>的核心区别在于参数传递方式</strong>，它通过数组接收参数：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">fun.<span class="title function_">apply</span>(thisArg, [argsArray])</span><br></pre></td></tr></table></figure></div>

<p>典型应用场景是处理数组数据，例如结合数学计算：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 输出obj对象</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x + y); <span class="comment">// 输出3</span></span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="title function_">apply</span>(obj, [<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际应用：求数组最大值</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">5</span>, <span class="number">20</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, arr)); <span class="comment">// 输出20</span></span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong>：参数需封装为数组，适用于参数数量不确定或已有数组结构的场景。</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p><strong><code>bind()</code>方法通过生成新函数实现<code>this</code>指向的绑定</strong>，但不会立即执行原函数：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newFun = fun.<span class="title function_">bind</span>(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure></div>

<p>例如实现延时操作中的<code>this</code>控制：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 输出obj对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newFn = fn.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">newFn</span>(); <span class="comment">// 手动调用新函数才会执行</span></span><br></pre></td></tr></table></figure></div>

<p><strong>特性</strong>：返回修改了<code>this</code>指向的函数副本，适用于需要延迟执行或事件回调的场景。</p>
<h4 id="核心差异与选择"><a href="#核心差异与选择" class="headerlink" title="核心差异与选择"></a>核心差异与选择</h4><table>
<thead>
<tr>
<th>特性</th>
<th>call</th>
<th>apply</th>
<th>bind</th>
</tr>
</thead>
<tbody><tr>
<td><strong>执行方式</strong></td>
<td>立即调用</td>
<td>立即调用</td>
<td>返回新函数</td>
</tr>
<tr>
<td><strong>参数形式</strong></td>
<td>逗号分隔参数</td>
<td>单数组参数</td>
<td>逗号分隔参数</td>
</tr>
<tr>
<td><strong>使用频率</strong></td>
<td>中等</td>
<td>较低</td>
<td>高频</td>
</tr>
</tbody></table>
<p><strong>关键结论</strong>：</p>
<ul>
<li>**<code>call</code>**：明确参数数量时，替代普通函数调用</li>
<li>**<code>apply</code>**：处理数组参数或不确定参数数量</li>
<li>**<code>bind</code>**：需要保持<code>this</code>指向的场景（如定时器回调、事件处理）</li>
</ul>
<p>通过理解参数传递方式和执行时机的差异，可根据具体需求选择最合适的方法控制<code>this</code>指向。</p>
<h2 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><p>防抖：单位时间内，频繁触发事件，只执行最后一次<br>举个栗子：王者荣耀回城，只要被打断就需要重新来<br>使用场景：<br>搜索框搜索输入。只需用户最后一次输入完，再发送请求<br>手机号、邮箱验证输入检测</p>
<p>1．防抖是什么？<br>》单位时间内，频繁触发事件，只执行最后一次<br>2．有什么使用场景呢？<br>N 搜索框搜索输入。只需用户最后一次输入完，再发送请求<br>》手机号、邮箱验证输入检测</p>
<p>利用防抖来处理-鼠标滑过盒子显示文字<br>要求：鼠标在盒子上移动，鼠标停止 500ms 之后，里面的数字才会变化+1<br>const box &#x3D; document.querySelector(‘.box’)<br>let i&#x3D;1<br>function mouseMove(）{<br>box.innerHTML&#x3D;i++<br>&#x2F;&#x2F;如果存在开销较大操作，大量数据处理，大量 dom 操作，可能会卡<br>box.addEventListener(‘mousemove’,mouseMove)<br>实现方式：</p>
<h3 id="lodash-提供的防抖"><a href="#lodash-提供的防抖" class="headerlink" title="lodash 提供的防抖"></a>lodash 提供的防抖</h3><p>&#x2F;&#x2F;利用 Lodash 库实现防抖<br>&#x2F;&#x2F;语法：_.debounce（fun，时间）<br>box.addEventListener（’mousemove’,_.debounce（mouseMove,5oo))</p>
<h3 id="手写防抖函数"><a href="#手写防抖函数" class="headerlink" title="手写防抖函数"></a>手写防抖函数</h3><p>11.声明定时器变量<br>112。每次鼠标移动（事件触发）的时候都要先判断是否有定时名<br>时器<br>1&#x2F;3。如果没有定时器，则开启定时器，存入到定时器变量里面 114.定时器里面写函数调用<br>function debounce(fn,t){<br>let timer<br>&#x2F;&#x2F;return 返回一个匿名函数<br>return function (){<br>1&#x2F;2.3.4<br>if （timer) clearTimeout(timer)<br>timer&#x3D; setTimeout（function ()<br>fn（）&#x2F;&#x2F;加小括号调用 fn 函数<br>}，t)</p>
<h2 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流-throttle"></a>节流-throttle</h2><p>节流：单位时间内，频繁触发事件，只执行一次</p>
<p>要求：鼠标在盒子上移动，不管移动多少次，每隔 500ms 才+1<br>const box &#x3D; document.querySelector(‘.box’)<br>leti&#x3D;1<br>function mouseMove(){<br>box.innerHTML&#x3D;i++<br>11 如果存在开销较大操作，大量数据处理，大量 dom 操作，可能会卡<br>box.addEventListener(‘mousemove’,mouseMove)<br>6266260<br>实现方式：</p>
<h3 id="lodash-提供的节流函数来处理"><a href="#lodash-提供的节流函数来处理" class="headerlink" title="lodash 提供的节流函数来处理"></a>lodash 提供的节流函数来处理</h3><p>box.addEventListener(‘mousemove’,_.throttle(mouseMove,30o0))</p>
<h3 id="手写一个节流函数来处理"><a href="#手写一个节流函数来处理" class="headerlink" title="手写一个节流函数来处理"></a>手写一个节流函数来处理</h3><p>function throttle（fn,t){<br>let timer &#x3D; null<br>return function (){<br>if（!timer）{<br>timer&#x3D; setTimeout（function （){<br>fn()I<br>11 清空定时器<br>timer &#x3D; nul1<br>}，t)</p>
<p>性能优化说明使用场景<br>防抖单位时间内，频繁触发事件，只执行最后一次搜索框搜索输入、手机号、邮箱验证输入检测<br>节流单位时间内，频繁触发事件，只执行一次高频事件：鼠标移动 mousemove、页面尺寸缩放 resize、<br>滚动条滚动 scroll 等等</p>
<h1 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h1><h2 id="防抖（debounce）-1"><a href="#防抖（debounce）-1" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h2><p>在单位时间内，若事件被频繁触发，仅执行最后一次操作。如同电梯关门机制——当持续有人进入时，关门动作会被不断延迟，直到无人进入后才真正执行关门。</p>
<h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ul>
<li>搜索框输入联想（用户停止输入 300ms 后发起请求）</li>
<li>表单验证（如手机号&#x2F;邮箱格式校验）</li>
<li>鼠标移动停止后触发操作（如示例中鼠标停留 500ms 后更新数值）</li>
</ul>
<p><strong>实现方案</strong></p>
<h4 id="原生-JavaScript-实现"><a href="#原生-JavaScript-实现" class="headerlink" title="原生 JavaScript 实现"></a>原生 JavaScript 实现</h4><p>通过定时器延迟执行，若重复触发则重置计时：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, t</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer;                       <span class="comment">// 声明定时器变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;              <span class="comment">// 返回闭包函数</span></span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 清除前一次定时</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;     <span class="comment">// 重新计时</span></span><br><span class="line">      fn.<span class="title function_">call</span>(<span class="variable language_">this</span>);               <span class="comment">// 绑定正确this指向</span></span><br><span class="line">    &#125;, t);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mouseMove = <span class="title function_">debounce</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  box.<span class="property">innerHTML</span> = i++;             <span class="comment">// 实际业务逻辑</span></span><br><span class="line">&#125;, <span class="number">500</span>);                           <span class="comment">// 500ms防抖阈值</span></span><br><span class="line"></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, mouseMove);</span><br></pre></td></tr></table></figure></div>

<h4 id="Lodash-库实现"><a href="#Lodash-库实现" class="headerlink" title="Lodash 库实现"></a>Lodash 库实现</h4><p>通过现成方法快速应用防抖：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, _.<span class="title function_">debounce</span>(mouseMove, <span class="number">500</span>));</span><br></pre></td></tr></table></figure></div>

<h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p><strong>核心概念</strong>：在单位时间内，无论事件触发多少次，最多执行一次操作。如同水龙头限流——无论快速开关多少次，水流始终以固定频率流出。</p>
<h3 id="典型应用场景-1"><a href="#典型应用场景-1" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ul>
<li>页面滚动事件监听（如每 100ms 计算滚动位置）</li>
<li>窗口 resize 时元素重排</li>
<li>高频鼠标移动轨迹采样（如示例中每 500ms 记录一次坐标）</li>
</ul>
<p><strong>实现方案</strong></p>
<h4 id="原生-JavaScript-实现-1"><a href="#原生-JavaScript-实现-1" class="headerlink" title="原生 JavaScript 实现"></a>原生 JavaScript 实现</h4><p>通过定时器控制执行间隔：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, t</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;                <span class="comment">// 初始化定时器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;              <span class="comment">// 返回闭包函数</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;                  <span class="comment">// 判断是否处于冷却期</span></span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">call</span>(<span class="variable language_">this</span>);            <span class="comment">// 执行目标函数</span></span><br><span class="line">        timer = <span class="literal">null</span>;             <span class="comment">// 重置状态允许下次触发</span></span><br><span class="line">      &#125;, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mouseMove = <span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  box.<span class="property">innerHTML</span> = i++;             <span class="comment">// 实际业务逻辑</span></span><br><span class="line">&#125;, <span class="number">500</span>);                           <span class="comment">// 500ms节流间隔</span></span><br><span class="line"></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, mouseMove);</span><br></pre></td></tr></table></figure></div>

<h4 id="Lodash-库实现-1"><a href="#Lodash-库实现-1" class="headerlink" title="Lodash 库实现"></a>Lodash 库实现</h4><p>直接调用现成节流方法：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, _.<span class="title function_">throttle</span>(mouseMove, <span class="number">500</span>));</span><br></pre></td></tr></table></figure></div>

<p><strong>防抖适用场景</strong>：关注最终状态，高频触发中只需最后一次有效（如输入停止后的搜索请求）。<br><strong>节流适用场景</strong>：需要维持固定执行频率，避免高频操作导致性能问题（如滚动事件的位置计算）。</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序开发</title>
    <url>/2025/04/07/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="入门简介"><a href="#入门简介" class="headerlink" title="入门简介"></a>入门简介</h1><h3 id="运行环境与开发模式"><a href="#运行环境与开发模式" class="headerlink" title="运行环境与开发模式"></a>运行环境与开发模式</h3><p>小程序与网页开发的核心差异在于执行环境的不同。</p>
<blockquote>
<p>网页运行在浏览器沙箱环境，而小程序运行在微信封装的混合环境中。</p>
</blockquote>
<p>这种差异导致两个重要特征：</p>
<ul>
<li>小程序无法直接操作 DOM&#x2F;BOM API，但可以通过微信提供的原生 API 实现硬件交互能力（如地理定位、扫码支付等）</li>
<li>开发流程必须遵循微信生态规范，需经历账号申请、开发者工具安装、项目标准化配置等步骤。</li>
</ul>
<h3 id="项目结构体系"><a href="#项目结构体系" class="headerlink" title="项目结构体系"></a>项目结构体系</h3><p>微信小程序的项目结构以模块化设计为核心，通过清晰的目录划分实现功能解耦。</p>
<ol>
<li><strong><code>pages</code></strong> 存放所有页面，每个页面由四个文件组成（同名目录下）：<br>• **<code>.js</code>**：页面逻辑（数据、事件处理）<br>• **<code>.wxml</code>**：页面结构（类似 HTML）<br>• **<code>.wxss</code>**：页面样式（类似 CSS）<br>• **<code>.json</code>**：页面配置（窗口样式、导航栏等）</li>
</ol>
<blockquote>
<p>新增页面时，直接在<code>app.json</code>的<code>pages</code>列表里添加路径，开发者工具会自动帮你生成文件。<br>小程序会把排在第一位的页面当作项目首页进行渲染。</p>
</blockquote>
<ol start="2">
<li><p>**<code>utils</code>**：存放工具函数（比如时间格式化、网络请求封装），像工具箱里的螺丝刀、剪刀，方便重复使用。</p>
</li>
<li><p><strong><code>app.js</code></strong> ：小程序的“入口文件”，相当于 APP 的启动程序，用来初始化全局数据（比如用户登录状态）。</p>
</li>
<li><p><strong><code>app.json</code></strong> ：全局配置文件，控制：<br>◦ 页面路径（<code>pages</code>列表）<br>◦ 窗口样式（标题颜色、导航栏背景）<br>◦ 底部导航栏（图标和跳转页面）<br>◦ 组件样式版本（<code>style: &quot;v2&quot;</code>启用新版按钮圆角）</p>
</li>
<li><p><strong><code>app.wxss</code></strong> ：全局样式表，定义所有页面通用的样式（比如按钮颜色、字体大小）。</p>
</li>
<li><p><strong><code>project.config.json</code></strong> ：记录开发工具的个性化设置（比如是否开启代码检查、项目名称）。</p>
</li>
<li><p><strong><code>sitemap.json</code></strong> ：控制微信是否允许爬虫收录页面（默认全允许，敏感页面可手动禁止）。</p>
</li>
</ol>
<h3 id="宿主环境"><a href="#宿主环境" class="headerlink" title="宿主环境"></a>宿主环境</h3><p>在移动开发领域中，<strong>宿主环境</strong>（Host Environment）指应用程序运行所依赖的基础操作系统与容器环境。以微信小程序为例，手机微信客户端即为小程序的宿主环境，提供原生渲染能力、API 接口及安全沙箱等核心支持。</p>
<p>这一设计使得小程序无需独立安装即可运行，但也带来环境隔离特性：安卓版微信内的小程序无法直接运行于 iOS 微信客户端，充分体现了宿主环境对软件行为的决定性作用。</p>
<h4 id="通信主体架构"><a href="#通信主体架构" class="headerlink" title="通信主体架构"></a>通信主体架构</h4><p>小程序的运行时架构采用<strong>逻辑层与渲染层分离</strong>的双线程模型，这是现代前端架构中常见的性能与安全优化方案：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/file-20250408212839001.jpg"
                     
                ></p>
<ul>
<li><strong>渲染层</strong>负责视觉呈现，由 WXML 模板引擎与 WXSS 样式解析器构成。其工作方式类似于浏览器渲染进程，但针对移动端性能特点进行轻量化改造。</li>
<li><strong>逻辑层</strong>作为业务核心，运行独立的 JavaScript 引擎（iOS 使用 JavaScriptCore，安卓采用 V8 内核），处理数据运算、事件响应等非可视化逻辑。</li>
</ul>
<p>两层的物理隔离避免了单线程模型中 JS 运算阻塞渲染的问题，但也带来了特殊的通信需求。</p>
<h4 id="跨线程通信模型"><a href="#跨线程通信模型" class="headerlink" title="跨线程通信模型"></a>跨线程通信模型</h4><p>小程序通过<strong>微信客户端中转</strong>实现跨线程通信，该设计有效平衡了安全性与性能：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/file-20250408212852000.jpg"
                     
                ></p>
<ol>
<li><strong>视图-逻辑通信</strong>：用户交互事件（如点击）由渲染层捕获，经微信原生模块序列化后转发至逻辑层。反向数据更新则通过<code>setData</code>接口传递，其内部采用差分算法优化传输效率。</li>
<li><strong>服务端通信</strong>：逻辑层发起的网络请求并非直接访问第三方服务器，而是由微信客户端代理转发。这种中间人模式既实现统一权限控制（如自动添加安全头），也便于网络状态的集中监控。</li>
</ol>
<p>对比传统 Web 应用直接通信模式，小程序的中转机制虽然引入轻微延迟，但显著提升了代码安全性与跨平台一致性。</p>
<h3 id="生命周期与运行机制"><a href="#生命周期与运行机制" class="headerlink" title="生命周期与运行机制"></a>生命周期与运行机制</h3><p><strong>冷启动流程</strong>包含以下关键阶段：</p>
<ol>
<li><strong>代码包下载</strong>：微信 CDN 分发加密包体，客户端完成签名校验与解密</li>
<li><strong>配置解析</strong>：读取<code>app.json</code>全局配置，初始化导航栏、窗口样式等基础参数</li>
<li><strong>实例化应用</strong>：执行<code>app.js</code>入口文件，触发<code>App()</code>构造函数创建应用单例</li>
<li><strong>首屏渲染</strong>：根据路由配置加载首页资源，完成页面级初始化（详细流程见下文）</li>
</ol>
<p><strong>页面渲染周期</strong>则进一步细分为：</p>
<ol>
<li><strong>配置加载</strong>：解析页面<code>json</code>配置，确定使用的自定义组件与页面特性</li>
<li><strong>模板编译</strong>：并行加载 WXML 模板与 WXSS 样式，编译生成虚拟 DOM 树</li>
<li><strong>逻辑初始化</strong>：执行页面 JS 文件，通过<code>Page()</code>构造函数创建上下文环境</li>
<li><strong>数据绑定</strong>：将<code>data</code>对象与模板动态关联，触发首次渲染流水线</li>
</ol>
<p><strong>开发注意点</strong>：应避免在<code>data</code>初始化阶段执行耗时操作，以防阻塞渲染线程。对于复杂数据结构的传输，建议使用<code>JSON.parse(JSON.stringify())</code>进行深拷贝以避免引用污染。</p>
<h3 id="微信小程序组件"><a href="#微信小程序组件" class="headerlink" title="微信小程序组件"></a>微信小程序组件</h3><p>小程序组件体系基于 Web Components 思想进行封装，但与 HTML 标准元素存在显著差异：组件功能更场景化、属性配置更声明式。</p>
<p><code>view</code> - <code>div</code><br>作为基础布局单元，<code>&lt;view&gt;</code> 与 <code>&lt;div&gt;</code> 的异同值得关注：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 小程序 --&gt;</span><br><span class="line">&lt;view class=&quot;container&quot; hover-class=&quot;active&quot;&gt;</span><br><span class="line">  &lt;text&gt;可交互视图容器&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- HTML --&gt;</span><br><span class="line">&lt;div class=&quot;container&quot; onclick=&quot;handleClick()&quot;&gt;</span><br><span class="line">  &lt;span&gt;普通块级容器&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></div>

<p><code>scroll-view</code> - 原生滚动<br>长列表场景下的实现差异：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 小程序纵向滚动 --&gt;</span><br><span class="line">&lt;scroll-view scroll-y style=&quot;height: 300rpx&quot;&gt;</span><br><span class="line">  &lt;view wx:for=&quot;&#123;&#123;list&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;</span><br><span class="line">&lt;/scroll-view&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- HTML 实现 --&gt;</span><br><span class="line">&lt;div style=&quot;height: 300px; overflow-y: auto&quot;&gt;</span><br><span class="line">  &lt;div v-for=&quot;item in list&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></div>

<p><code>text</code> - <code>span</code><br>文本处理的核心差异：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 小程序长按选择 --&gt;</span><br><span class="line">&lt;text selectable&gt;&#123;&#123;content&#125;&#125;&lt;/text&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- HTML 实现类似功能需添加CSS --&gt;</span><br><span class="line">&lt;span style=&quot;user-select: all&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure></div>

<p><code>rich-text</code> - <code>innerHTML</code><br>富文本解析的安全策略对比：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 小程序安全渲染 --&gt;</span><br><span class="line">&lt;rich-text nodes=&quot;&#123;&#123;htmlContent&#125;&#125;&quot;&gt;&lt;/rich-text&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- HTML 危险做法 --&gt;</span><br><span class="line">&lt;div v-html=&quot;htmlContent&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 安全做法需配合 sanitize 库 --&gt;</span><br><span class="line">&lt;div id=&quot;safeContainer&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  sanitizeHTML(htmlContent, &#123; allowTags: [&#x27;b&#x27;] &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p><code>button</code> - 表单按钮<br>功能扩展性对比：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 小程序开放能力 --&gt;</span><br><span class="line">&lt;button open-type=&quot;share&quot;&gt;分享&lt;/button&gt;</span><br><span class="line">&lt;button open-type=&quot;getPhoneNumber&quot;&gt;获取手机号&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- HTML 需复杂实现 --&gt;</span><br><span class="line">&lt;button onclick=&quot;handleShare()&quot;&gt;调用原生分享接口&lt;/button&gt;</span><br></pre></td></tr></table></figure></div>

<p><code>input</code> - 表单输入<br>数据绑定差异：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 小程序双向绑定 --&gt;</span><br><span class="line">&lt;input value=&quot;&#123;&#123;value&#125;&#125;&quot; bindinput=&quot;onInput&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- HTML 现代框架实现 --&gt;</span><br><span class="line">&lt;input :value=&quot;value&quot; @input=&quot;onInput&quot; /&gt;</span><br></pre></td></tr></table></figure></div>

<p>image vs img<br>图片处理优化方案对比：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 小程序懒加载 --&gt;</span><br><span class="line">&lt;image src=&quot;url&quot; lazy-load mode=&quot;aspectFit&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- HTML 实现需交叉观察器 --&gt;</span><br><span class="line">&lt;img src=&quot;url&quot; loading=&quot;lazy&quot; class=&quot;aspect-fit&quot;&gt;</span><br></pre></td></tr></table></figure></div>

<p><code>navigator</code> - <code>a</code> 标签<br>路由跳转机制差异：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 小程序页面跳转 --&gt;</span><br><span class="line">&lt;navigator url=&quot;/pages/detail?id=1&quot; open-type=&quot;navigate&quot;&gt;</span><br><span class="line">  详情页</span><br><span class="line">&lt;/navigator&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- HTML 传统跳转 --&gt;</span><br><span class="line">&lt;a href=&quot;/detail.html?id=1&quot;&gt;详情页&lt;/a&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="微信小程序-API"><a href="#微信小程序-API" class="headerlink" title="微信小程序 API"></a>微信小程序 API</h3><p><strong>事件监听 API</strong>（Event Listening API）<br>是小程序与原生环境交互的重要通道，其命名规范与调用方式具有显著特征。这类 API <strong>统一以 <code>on</code> 前缀开头</strong>，遵循<strong>发布-订阅模式</strong>实现事件响应。</p>
<p>以窗口尺寸监听为例，开发者可通过 <code>wx.onWindowResize()</code> 注册全局事件：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册窗口尺寸变化监听</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resizeHandler</span> = (<span class="params">res</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;窗口新尺寸:&#x27;</span>, res.<span class="property">windowWidth</span>, res.<span class="property">windowHeight</span>)</span><br><span class="line">&#125;</span><br><span class="line">wx.<span class="title function_">onWindowResize</span>(resizeHandler)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适时移除防止内存泄漏</span></span><br><span class="line">wx.<span class="title function_">offWindowResize</span>(resizeHandler)</span><br></pre></td></tr></table></figure></div>

<p>小程序不存在 <code>window</code> 对象，<code>wx</code> 作为全局命名空间承载核心能力</p>
<p><strong>同步 API</strong>（Synchronous API）<br>通过阻塞式调用简化流程控制，其命名以 <code>Sync</code> 后缀为标识。这类 API 直接返回执行结果，异常处理需依赖 <code>try...catch</code> 结构：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安全写入本地存储</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  wx.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;sessionKey&#x27;</span>, <span class="string">&#x27;a1b2c3&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> value = wx.<span class="title function_">getStorageSync</span>(<span class="string">&#x27;sessionKey&#x27;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读取成功:&#x27;</span>, value)</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;存储操作异常:&#x27;</span>, error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反例：未捕获异常导致崩溃</span></span><br><span class="line">wx.<span class="title function_">setStorageSync</span>(<span class="string">&#x27;invalidKey&#x27;</span>, <span class="literal">undefined</span>) <span class="comment">// 抛出 TypeError</span></span><br></pre></td></tr></table></figure></div>

<p><strong>异步 API</strong>（Asynchronous API）<br>构成小程序非阻塞式编程的核心，采用回调函数处理延迟操作结果。其设计理念与 jQuery 的 <code>$.ajax</code> 相似，但遵循更严格的<strong>成功&#x2F;失败状态分离</strong>原则：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准网络请求示例</span></span><br><span class="line">wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;https://api.example.com/data&#x27;</span>,</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="property">statusCode</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;数据获取成功:&#x27;</span>, res.<span class="property">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">fail</span>: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求失败:&#x27;</span>, err.<span class="property">errMsg</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">complete</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求流程结束&#x27;</span>) <span class="comment">// 始终执行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现代实践：结合 async/await 包装</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">promisify</span>(wx.<span class="property">request</span>)(&#123; <span class="attr">url</span>: <span class="string">&#x27;...&#x27;</span> &#125;)</span><br><span class="line">    <span class="comment">// 数据处理逻辑</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 统一错误处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h1><p>微信小程序采用 声明式数据绑定（Declarative Data Binding）机制，其实现基于两个核心步骤：</p>
<p><strong>数据定义</strong>与<strong>模板引用</strong>。</p>
<p>在页面逻辑层（.js 文件）的 <code>data</code> 对象中定义初始值，这些数据将自动与视图层（.wxml 文件）建立响应式关联。</p>
<p>数据定义规范需在页面构造函数中明确定义初始状态：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面逻辑文件（page.js）</span></span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="string">&#x27;init data&#x27;</span>, <span class="comment">// 字符串类型数据</span></span><br><span class="line">    <span class="attr">msgList</span>: [ <span class="comment">// 数组类型数据</span></span><br><span class="line">      &#123; <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">msg</span>: <span class="string">&#x27;world&#x27;</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">isLoading</span>: <span class="literal">false</span> <span class="comment">// 布尔型状态标识</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p>此处的数据结构设计直接影响渲染性能，建议避免嵌套过深的对象。对于复杂数据类型，可使用 <code>JSON.parse(JSON.stringify())</code> 进行深拷贝来解除引用关系。</p>
<h3 id="Mustache-语法解析"><a href="#Mustache-语法解析" class="headerlink" title="Mustache 语法解析"></a>Mustache 语法解析</h3><p>通过双大括号 <code>&#123;&#123;&#125;&#125;</code> 实现数据插值，其核心能力是将逻辑层数据动态注入视图层。</p>
<p><strong>内容动态绑定</strong><br>基础文本绑定直接映射数据字段：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 视图层模板（page.wxml） --&gt;</span><br><span class="line">&lt;view class=&quot;content&quot;&gt;&#123;&#123;info&#125;&#125;&lt;/view&gt;</span><br></pre></td></tr></table></figure></div>

<p>当 <code>info</code> 值变更时，视图层将自动更新。</p>
<p><strong>属性动态绑定</strong><br>组件属性同样支持响应式数据绑定，适用于动态资源配置场景：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;image</span><br><span class="line">  src=&quot;&#123;&#123;imgSrc&#125;&#125;&quot;</span><br><span class="line">  mode=&quot;aspectFit&quot;</span><br><span class="line">  class=&quot;banner-image&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></div>

<p>对应的数据定义需注意资源路径的完整性：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">imgSrc</span>: <span class="string">&#x27;https://example.com/logo.png&#x27;</span> <span class="comment">// 完整HTTPS地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="数据运算处理"><a href="#数据运算处理" class="headerlink" title="数据运算处理"></a>数据运算处理</h3><p>Mustache 语法支持表达式运算，但需遵循<strong>轻逻辑原则</strong>：仅允许进行数据格式化等简单操作，复杂计算应前置到逻辑层处理。</p>
<h5 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h5><p>通过三元表达式实现动态内容切换：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view class=&quot;status&quot;&gt;</span><br><span class="line">  &#123;&#123;isLoading ? &#x27;加载中...&#x27; : &#x27;数据加载完成&#x27;&#125;&#125;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></div>

<p>对应的状态管理：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">isLoading</span>: <span class="literal">true</span> <span class="comment">// 初始加载状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>最佳实践</strong>：当条件分支超过两个时，应改用 <code>wx:if</code> 和 <code>wx:else</code> 指令集以提高可读性。</p>
<h5 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h5><p>可在模板内执行基础算术运算：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;view&gt;价格：￥&#123;&#123;(unitPrice * quantity).toFixed(2)&#125;&#125;&lt;/view&gt;</span><br></pre></td></tr></table></figure></div>

<p>但更推荐在逻辑层预先计算：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">unitPrice</span>: <span class="number">12.5</span>,</span><br><span class="line">    <span class="attr">quantity</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">total</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">onLoad</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">total</span>: (<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">unitPrice</span> * <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">quantity</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><strong>性能考量</strong>：模板内频繁运算会触发多余的渲染流程，对于移动端长列表场景需特别注意优化。</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>ECMAScript入门</title>
    <url>/2024/04/19/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%89%8D%E7%AB%AF/ECMAScript%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="ECMAScript-概述"><a href="#ECMAScript-概述" class="headerlink" title="ECMAScript 概述"></a>ECMAScript 概述</h1><p>ECMAScript 是定义脚本语言的规范, 而 JavaScript 是遵循 ECMAScript 规范实现的一种编程语言.</p>
<p>ECMAScript 好比是一本书的目录, 而 JavaScript 是这本书的具体内容.</p>
<h4 id="ES6-和-JavaScript-有什么区别？"><a href="#ES6-和-JavaScript-有什么区别？" class="headerlink" title="ES6 和 JavaScript 有什么区别？"></a>ES6 和 JavaScript 有什么区别？</h4><p>ES6(ECMAScript 2015)是 ECMAScript 规范的第六个版本, 而 JavaScript 是基于 ECMAScript 规范实现的编程语言.</p>
<p>ES6 可以被看作是 JavaScript 的一个重要的版本更新.</p>
<h1 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h1><h3 id="变量-Variable"><a href="#变量-Variable" class="headerlink" title="变量(Variable)"></a>变量(Variable)</h3><p>是用于存储数据的名称(标识符), 变量可以是任何类型, 如 “数值、字符串” 等.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &quot;字符串&quot;</span><br><span class="line">let num = 100</span><br></pre></td></tr></table></figure></div>

<p>变量可以重新赋值</p>
<blockquote>
<p>ES6 不区分整型和浮点型, 所有数字都使用 <code>number类型</code> 来表示</p>
</blockquote>
<h3 id="常量-Constant"><a href="#常量-Constant" class="headerlink" title="常量(Constant)"></a>常量(Constant)</h3><p>是一个固定的值, 在程序运行中常量的值保持不变</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const PI = 3.14</span><br></pre></td></tr></table></figure></div>

<h3 id="如何选择使用-let-或-const"><a href="#如何选择使用-let-或-const" class="headerlink" title="如何选择使用 let 或 const"></a>如何选择使用 let 或 const</h3><ol>
<li>默认使用 const.</li>
<li>当其需求为可变时, 使用 let 进行可变声明.</li>
</ol>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h3 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 string</h3><p>字符串类型用于存储字符序列</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p><code>length</code> 字符串长度</p>
</li>
<li><p><code>toLowerCase</code> &#x2F; <code>toUpperCase</code> 转小写&#x2F;转大写</p>
</li>
<li><p><code>字符串[索引]</code> 返回索引处的字符</p>
</li>
<li><p><code>[...字符串]</code> 字符串转为字符数组</p>
</li>
<li><p><code>parseInt(&quot;1234&quot;)</code> 字符串转 int</p>
</li>
<li><p><code>replaceALL(&quot;目标字符串&quot;,&quot;替换成的字符串&quot;)</code> 替换全部字符串替换</p>
</li>
<li><p><code>replacece(&quot;目标字符串&quot;,&quot;替换成的字符串&quot;)</code>替换一个字符串替换</p>
</li>
</ul>
<h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">`姓名:$&#123;this.name&#125; 年龄:$&#123;this.age&#125;`</span><br></pre></td></tr></table></figure></div>

<h3 id="数值-number"><a href="#数值-number" class="headerlink" title="数值 number"></a>数值 number</h3><p>用于存储数字, 可以表示整数、浮点数</p>
<h3 id="布尔类型-boolean"><a href="#布尔类型-boolean" class="headerlink" title="布尔类型 boolean"></a>布尔类型 boolean</h3><p>布尔类型只能取两个值,true(真) 和 false(假)</p>
<h3 id="函数-function"><a href="#函数-function" class="headerlink" title="函数 function"></a>函数 function</h3><p>函数是一段<strong>可重复执行的代码块</strong>，可以接收输入参数并返回一个值或执行某些操作.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义一个计算两数之和的函数</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&quot;add&quot;, add(1, 2))</span><br><span class="line"></span><br><span class="line">// 匿名函数</span><br><span class="line">let sub = function(x,y) &#123;</span><br><span class="line">  return x-y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sub(1, 2))</span><br><span class="line"></span><br><span class="line">// 箭头函数</span><br><span class="line">let plus = (a,b) =&gt; &#123;</span><br><span class="line">  return a+b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(plus(1, 2))</span><br><span class="line"></span><br><span class="line">// 隐式返回</span><br><span class="line">let minus = (a,b) =&gt; a-b</span><br><span class="line"></span><br><span class="line">let double = n =&gt; 2n</span><br></pre></td></tr></table></figure></div>

<h3 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 array</h3><p>数组是一种<strong>有序集合</strong>, 可以包含不同类型的元素，并且数组的长度是<strong>可变的</strong>.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;] //定义了一个包含4个字符串的数组</span><br><span class="line"></span><br><span class="line">let arr = [&quot;1&quot;,&quot;3.14&quot;,&quot;a&quot;]</span><br></pre></td></tr></table></figure></div>

<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p><code>push(元素1,元素2)</code> 向数组<strong>末尾</strong>添加一个或多个元素(用逗号隔开元素), 并返回<strong>修改后数组的长度</strong></p>
</li>
<li><p><code>unshift(元素1,元素2)</code> 向数组<strong>开头</strong>添加一个或多个元素, 并返回修<strong>改后数组的长度</strong></p>
</li>
<li><p><code>pop()</code> 删除数组<strong>最后一个</strong>元素, 并返回被删除元素删</p>
</li>
<li><p><code>shift()</code> 除数组中<strong>第一个</strong>元素, 并返回被删除元素</p>
</li>
<li><p><code>splice(要删除元素的索引位置, 要删除的元素数量)</code> 删除元素, 并返回包含被删除元素的数组</p>
</li>
<li><p><code>reverse()</code> 反转数组中元素的顺序</p>
</li>
<li><p><code>sort()</code> 数组中的元素按照首字母顺序排序</p>
</li>
</ul>
<p>使用 <code>sort()</code> 排序数组 [5,20,13,1,4] ,由于只比较首字母的缘故, 会得到 [1,13,20,4,5] 的结果.</p>
<p>配合比较函数 <code>(a,b) =&gt; a-b</code>, 实现数字排序:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.sort((a,b) =&gt; a-b)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>filter()</code> 筛选符合条件的元素</li>
</ul>
<p>例如, 筛选值大于 12 的元素</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.filter((n) =&gt; n&gt;12)</span><br></pre></td></tr></table></figure></div>

<h4 id="数组的-for-循环遍历"><a href="#数组的-for-循环遍历" class="headerlink" title="数组的 for 循环遍历"></a>数组的 for 循环遍历</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let item of arr)&#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.forEach((value,index) =&gt; &#123;console.log(value,index)&#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>Set 是一种特殊的数据结构, 用于存储<strong>无序且唯一</strong>的值的集合.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let number = new Set([1, 2, 3, 4, 5]) //定义了一个包含5个&quot;不重复&quot;的整数的集合</span><br><span class="line"></span><br><span class="line">//错误示范</span><br><span class="line">let numbers = new Set([1, 2, 3, 4, 5, 5])</span><br></pre></td></tr></table></figure></div>

<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><p><code>add(&#39;元素&#39;)</code> 向 Set 集合中添加新的元素</p>
</li>
<li><p><code>delete(&#39;元素&#39;)</code> 从 Set 集合中删除元素</p>
</li>
<li><p><code>clear()</code> 清空 Set 集合</p>
</li>
<li><p><code>has(&#39;元素&#39;)</code> 检查 Set 集合是否包含指定元素</p>
</li>
<li><p><code>size</code> 获取 Set 集合的大小</p>
</li>
<li><p><code>Array.from(set集合)</code> 将 Set 集合 转换为 数组</p>
</li>
<li><p>使用扩展运算符<code>...</code>将 Set 集合 转换为 数组</p>
</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [...Set集合]</span><br></pre></td></tr></table></figure></div>

<p>扩展运算符可用于展开可迭代对象(如数组、字符串等)</p>
<p>例如</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let str = &#x27;一个字符串&#x27;</span><br><span class="line">console.log(str) // [&#x27;一&#x27;,&#x27;个&#x27;,&#x27;字&#x27;,&#x27;符&#x27;,&#x27;串&#x27;,]</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将 数组 转换为 Set 集合</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let numberArr = [1, 2, 3, 3, 2, 1]</span><br><span class="line">let numberSet = new Set(numberArr)</span><br><span class="line"></span><br><span class="line">// 输出为 [1,2,3]</span><br></pre></td></tr></table></figure></div>

<p>利用 Set 集合 特性, 可实现数组去重</p>
<h4 id="Set-集合的-for-循环遍历"><a href="#Set-集合的-for-循环遍历" class="headerlink" title="Set 集合的 for 循环遍历"></a>Set 集合的 for 循环遍历</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let item of set)&#123;</span><br><span class="line">  console.log(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr.forEach((value,index) =&gt; &#123;console.log(value,index)&#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="对象-object"><a href="#对象-object" class="headerlink" title="对象 object"></a>对象 object</h3><p>对象是一种<strong>复合的数据类型</strong>, 可以通过键值对的方式存储多个值.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义了一个包含姓名、年龄和体重的对象</span><br><span class="line"></span><br><span class="line">let boy = &#123;</span><br><span class="line">  name: &quot;David&quot;,</span><br><span class="line">  age: 28,</span><br><span class="line">  weight: 70.5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>向对象中添加新的属性 <code>对象.新属性 = 值</code></li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">boy.height = 175</span><br></pre></td></tr></table></figure></div>

<p>在对象中, 每个键都是唯一的, 当使用相同的键再次赋值时, 会替换原来键对应的值.</p>
<ul>
<li><p>删除属性 <code>delete 对象.属性</code></p>
</li>
<li><p>清空对象 <code>对象 = &#123;&#125;</code></p>
</li>
<li><p>检查对象是否包含指定属性 <code>&quot;属性&quot; in 对象</code></p>
</li>
<li><p>获取对象的属性数量 <code>Object.keys(person).length</code></p>
</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name: &quot;张三&quot;,</span><br><span class="line">  gender: &quot;男&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Object.keys() 用于获取对象属性名(key)的数组</span><br><span class="line">console.log(Object.keys(person)) // 输出为数组, [&quot;name&quot;,&quot;gender&quot;]</span><br><span class="line"></span><br><span class="line">console.log(Object.keys(person).length)</span><br></pre></td></tr></table></figure></div>

<p>除了 <code>Object.keys(数组)</code> 取对象的属性名, 输出为数组, 还有:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Object.values(对象)) // 取对象的值输出为数组</span><br><span class="line"></span><br><span class="line">console.log(Object.entries(对象)) // 取对象的键值对输出为数组</span><br></pre></td></tr></table></figure></div>

<ul>
<li>将对象转换为数组 <code>Object.entries(对象)</code></li>
</ul>
<h4 id="对象的-for-循环遍历"><a href="#对象的-for-循环遍历" class="headerlink" title="对象的 for 循环遍历"></a>对象的 for 循环遍历</h4><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let key in 对象) &#123;</span><br><span class="line">  console.log(key, 对象[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.enties(对象).forEach(</span><br><span class="line">  ([key, value]) =&gt; &#123;</span><br><span class="line">  console.log(key, value)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 是一种特殊的数据结构,用于存储<strong>键值对</strong>的有序集合.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//定义了一个包含姓名、年龄和体重的map</span><br><span class="line">let girl = new Map([</span><br><span class="line">  [&quot;name&quot;, &quot;Luna&quot;],</span><br><span class="line">  [&quot;age&quot;, 20],</span><br><span class="line">  [&quot;weight&quot;, 50.5]</span><br><span class="line">])</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>Map 相对于对象提供了更灵活、有序、高效的键值对存储和操作方式,当需要在大量键值对中快速查找或删除特定键值对时, Map 比对象更高效<br>Map 提供了一些便捷的方法来操作键值对, 如: <code>get()</code>、<code>set()</code>、<code>delete()</code><br>Map 提供了一些便捷的迭代方法, 如: <code>forEach()</code>、<code>keys()</code>、<code>values()</code>、<code>entries()</code></p>
</blockquote>
<h5 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h5><ul>
<li>向 Map 集合中添加新的元素 <code>set(&#39;键&#39;,&#39;键值&#39;)</code></li>
</ul>
<blockquote>
<p>在 Map 集合中, 每个键都是唯一的, 当使用相同的键再次调用 <code>set()</code> 方法时, 会替换原来键对应的值.</p>
</blockquote>
<ul>
<li><p>删除元素 <code>delete(&#39;元素&#39;)</code></p>
</li>
<li><p>检查 Map 集合是否包含指定元素 <code>has(&#39;元素&#39;)</code></p>
</li>
<li><p>获取 Map 集合的大小 <code>size()</code></p>
</li>
<li><p><code>clear()</code> 清空 Map 集合</p>
</li>
<li><p>将 Map 集合转换为数组 <code>Array.from(Map集合)</code></p>
</li>
<li><p>使用扩展运算符<code>...</code>将 Map 集合 转换为 数组</p>
</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [...Map集合]</span><br></pre></td></tr></table></figure></div>

<h4 id="map-集合的-for-循环遍历"><a href="#map-集合的-for-循环遍历" class="headerlink" title="map 集合的 for 循环遍历"></a>map 集合的 for 循环遍历</h4><p><code>[key, value]</code> 就是一种解构语法, 解构可以从数组或对象中提取值并赋给变量.<br>将 Map 集合中的键值对解构为 key 和 value 两个变量.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let [key, value] of person) &#123;</span><br><span class="line">console.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">person.forEach(</span><br><span class="line">  (value, key) =&gt; &#123;</span><br><span class="line">  console.log(key, value)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<h3 id="类-class"><a href="#类-class" class="headerlink" title="类 class"></a>类 class</h3><p>类是一种蓝图或模板，用于<strong>创建具有相同属性和方法的</strong>对象.<br>命名时 类 的首字母大写.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">  //若在类中没有显式声明属性, 但在构造函数或方法中引用了未声明的属性, 会自动将其视为实例属性</span><br><span class="line"></span><br><span class="line">  name</span><br><span class="line">  age</span><br><span class="line"></span><br><span class="line">  //构造函数 用于初始化属性</span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //方法 返回个人信息</span><br><span class="line">  info() &#123;</span><br><span class="line">    console.log(&quot;姓名&quot;, this.name, &quot;年龄&quot;, this.age)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新建对象</span><br><span class="line">const person = new Person(&quot;张三&quot;, 22)</span><br><span class="line"></span><br><span class="line">//调用info()方法</span><br><span class="line">person.info()</span><br></pre></td></tr></table></figure></div>

<h1 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h1><p>私有属性是指仅在类内部可访问和操作的属性, 外部无法直接访问和修改.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  #name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>定义私有属性时, 在变量前添加 <code>#</code></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">get web()&#123;</span><br><span class="line">  return this.#name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set web(value)&#123;</span><br><span class="line">  this.#web = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承 extends .被继承的类称为 <strong>父类</strong>.继承的类称为 <strong>子类</strong>.</p>
<p>子类不但能调用父类的方法, 而且还能拥有自己的方法.<br>子类在调用时, 使用 <code>super(父类属性)</code> 调用父类属性.</p>
<p>例如</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义一个父类</span><br><span class="line">class Fater&#123;</span><br><span class="line">  name</span><br><span class="line">  gender</span><br><span class="line"></span><br><span class="line">  constructor(name, gender)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.gender = gender</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sleep()&#123;</span><br><span class="line">    return `$&#123;this.name&#125; 睡觉中...`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义一个子类</span><br><span class="line">class Son extends Father&#123; // 子类继承父类</span><br><span class="line">  age // 子类特有属性</span><br><span class="line"></span><br><span class="line">  constructor(name, gender, age)&#123;</span><br><span class="line">    super(name, gender) // 调用父类属性</span><br><span class="line"></span><br><span class="line">    this.age = age</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  eat()&#123;</span><br><span class="line">    return `$&#123;this.name&#125; 吃饭中...`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let son = new Son(&quot;儿子&quot;, &quot;男&quot;, &quot;22&quot;)</span><br><span class="line"></span><br><span class="line">console.log(son.eat())</span><br><span class="line">console.log(son.sleep()) // 子类不仅可以有自己的方法, 还能随时调用父类的方法</span><br></pre></td></tr></table></figure></div>

<h1 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h1><p>可以从数组或对象中提取值并赋给变量.</p>
<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>将数组 <code>[1,2]</code> 的值分别赋给 <code>x</code> ,<code>y</code></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [x, y] = [1 ,2]</span><br></pre></td></tr></table></figure></div>

<p>只需要将想赋值的变量放到对应的位置上即可.<br>同理的, 将数组 <code>[1,2,3]</code> 最后一个值赋给变量 <code>c</code> :</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [ , , c] = [1,2,3]</span><br></pre></td></tr></table></figure></div>

<p>配合使用扩展运算符<code>...</code>将其 转换为 数组 , 然后赋给变量.<br>例如:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [A, ...B] = [1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure></div>

<p>这样, <code>A</code> 的值为 <code>1</code>. <code>B</code> 的值为 数组 <code>[2,3,4,5,6]</code></p>
<blockquote>
<p>注意: 扩展运算符 <code>...</code> 解构必须放到最后, 否则会报错.</p>
</blockquote>
<p>反过来, 两个变量解构一个值时, 只会有第一个变量得到这个值.<br>例如:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [e,f] = [100] // e = 100, f = undefined</span><br></pre></td></tr></table></figure></div>

<p>这时我们可以给予变量默认值.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [e,f = 200] = [100] // e = 100, f = 200</span><br></pre></td></tr></table></figure></div>

<p>要注意的是, 给予默认值的优先级较低, 若通过解构再赋值, 默认值会被覆盖.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [e= 200,f ] = [100] // e = 100, f = undefined</span><br></pre></td></tr></table></figure></div>

<p>快速交换变量的值</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let X = 10,Y = 2;</span><br><span class="line">[X,Y]=[Y,X]</span><br></pre></td></tr></table></figure></div>

<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>定义一个对象</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let person = &#123;</span><br><span class="line">  name = &quot;张三&quot;</span><br><span class="line">  gender = &quot;男&quot;</span><br><span class="line">  age = 22</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>解构对象, 获取属性值</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123;name,gender,age&#125; = person</span><br><span class="line"></span><br><span class="line">console.log(name) // 输出 张三</span><br><span class="line">console.log(gender) // 输出 男</span><br><span class="line">console.log(age) // 输出 22</span><br></pre></td></tr></table></figure></div>

<p>设置默认值, 也能给不存在的属性赋默认值.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let &#123;name = &quot;李四&quot;&#125; = person</span><br><span class="line"></span><br><span class="line">let &#123;hight = 175&#125; = person // 给不存在的属性赋默认值</span><br></pre></td></tr></table></figure></div>

<p>重命名解构值</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let &#123;name:userName &#125; = person // 将 name 重命名为 userName</span><br></pre></td></tr></table></figure></div>

<p>扩展运算符<code>...</code>将其 转换为 对象</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123;name,...rest&#125; = person</span><br><span class="line"></span><br><span class="line">console.log(name) // 输出 张三</span><br><span class="line">console.log(rest) // 输出 &#123;gender: &quot;男&quot;, age: 22&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="承诺-Promise"><a href="#承诺-Promise" class="headerlink" title="承诺 Promise"></a>承诺 Promise</h1><blockquote>
<p>异步操作 是指在程序执行过程中, 某个操作不会立即返回结果, 而是需要一段时间的等待.</p>
<p>例如用户登陆时, 需要一段等待的时间, 不会立即返回结果.</p>
</blockquote>
<p>Promise 对象有三种状态:</p>
<ol>
<li>pending (进行中) - 初始状态</li>
<li>fulfilled (已成功)</li>
<li>rejected (已失败)</li>
</ol>
<p>当创建一个 Promise 对象时, 它的初始状态为 <code>pending</code>, 表示异步执行还未完成.<br>当异步执行成功时, 会调用 resolve 函数把 Promise 对象的状态改变为 <code>fulfilled</code>, 可通过 then 方法来获取异步操作的结果.<br>当异步执行异常时, 会调用 reject 函数把 Promise 对象的状态更改为 <code>rejected</code>, 可通过 catch 方法来处理错误.</p>
<p>结合三元运算, 例如:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const myPromise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    // 异步操作</span><br><span class="line">    true ? resolve(&#x27;已成功&#x27;) : reject(&#x27;已失败&#x27;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>这里, <code>resolve(&#39;已成功&#39;)</code> 被调用时, 它会将字符串 <code>&#39;已成功&#39;</code> 设置为 Promise 的解析值.<br>但是, 这个值并不会立即被输出到控制台.</p>
<p>输出发生在你使用 .then() 方法时.</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">myPromise</span><br><span class="line">    .then((value) =&gt; &#123;</span><br><span class="line">        // 当 promise 被成功 resolve 时执行</span><br><span class="line">        console.log(value); // 这里输出: Promise is fulfilled.</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((error) =&gt; &#123;</span><br><span class="line">        // 当 promise 被 reject 时执行</span><br><span class="line">        console.log(error);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div>

<p><code>.catch()</code> 方法来添加失败情况的回调函数.<br>使用 <code>.finally</code> , 无论是成功还是失败都会执行, 可用于输出日志.</p>
<h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><p>fetch 是基于 Promise 的 api, 它可以发送 http 请求并接收服务器返回的响应数据<br>fetch 返回的是一个 Promise 对象</p>
<blockquote>
<p>API(Application Programming Interface) 中文通常翻译为 <code>&quot;应用程序编程接口&quot;</code>.</p>
<p>API 是一组预定义的函数, 协议和工具. 用于构建软件应用.</p>
</blockquote>
<h1 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h1><p>不同的模块之间可以通过使用 <code>export</code> 关键字将代码导出为模块,其他模块可以使用 <code>import</code> 关键字导入该模块.</p>
<p>使用 <code>export</code> 导出多个变量或函数:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//index.js</span><br><span class="line">let num  = 22</span><br><span class="line">let name = 张三</span><br><span class="line"></span><br><span class="line">let eat = () =&gt; &#123;</span><br><span class="line">  return &quot;好饿!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export&#123; num, name, eat &#125;</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>import</code> 从 index.js 文件中导入 num,name,eat 变量&#x2F;函数,<br>使用 <code>as</code> 重定义别名</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; num as age, name, eat &#125; from &#x27;./index.js&#x27;</span><br><span class="line"></span><br><span class="line">console.log(age)</span><br><span class="line">console.log(name)</span><br><span class="line">console.log(eat())</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>default</code> 将一个对象作为整体导出, 导出的对象包含 num,name,eat 三个属性</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//index.js</span><br><span class="line">let num  = 22</span><br><span class="line">let name = 张三</span><br><span class="line"></span><br><span class="line">let eat = () =&gt; &#123;</span><br><span class="line">  return &quot;好饿!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123; num, name, eat &#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"> <span class="comment">// 添加 type=&quot;module&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> obj <span class="keyword">from</span> <span class="string">&quot;./index.js&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">num</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">eat</span>())</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>另外, <code>* as</code> 与 <code>default</code> 功能上等价.</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>入门基础</tag>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript-常用API</title>
    <url>/2025/03/07/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%89%8D%E7%AB%AF/JavaScript-%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[<p>Web API 是浏览器为 JavaScript 提供的<strong>双向通信接口</strong>，使脚本具备两大核心能力：</p>
<ol>
<li>操作网页内容（DOM&#x2F;Document Object Model）</li>
<li>控制浏览器行为（BOM）</li>
</ol>
<pre class="mermaid">graph TD
    JS[JavaScript] --> ES[ECMAScript]
    JS --> WA[Web APIs]
    ES -->|定义基础规则| 语法[变量/函数/循环]
    WA -->|操作页面| DOM[文档对象模型]
    WA -->|控制浏览器| BOM[浏览器对象模型]</pre>

<h1 id="DOM-文档对象模型"><a href="#DOM-文档对象模型" class="headerlink" title="DOM 文档对象模型"></a>DOM 文档对象模型</h1><p>操作网页内容，刻意开发网页内容特效和实现用户交互。</p>
<h3 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h3><p>文档树直观的体现了标签与标签之间的关系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E5%B8%B8%E7%94%A8api/file-20250315100909171.jpg"
                     
                ></p>
<p>有了 DOM 树， HTML  就转换为可编程的<strong>对象</strong>。<br>所有元素挂载在  <code>document</code>  对象下。</p>
<h3 id="获取-DOM-元素"><a href="#获取-DOM-元素" class="headerlink" title="获取 DOM 元素"></a>获取 DOM 元素</h3><p>要操作任何元素，首先得获取。</p>
<h4 id="精准定位-querySelector"><a href="#精准定位-querySelector" class="headerlink" title="精准定位 .querySelector()"></a>精准定位 <code>.querySelector()</code></h4><p>只会选择定位到的<strong>首个</strong>元素</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 CSS 选择器定位</span></span><br><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>) <span class="comment">// 可以获取首个 div</span></span><br><span class="line"><span class="keyword">const</span> nav = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#nav&#x27;</span>) <span class="comment">// 也可使用 ID 选择器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstLi = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul li:first-child&#x27;</span>) <span class="comment">// 结合伪类选择器操作</span></span><br><span class="line"><span class="keyword">const</span> indexLi = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">`li:nth-child(<span class="subst">$&#123;index+<span class="number">1</span>&#125;</span>`</span>)</span><br></pre></td></tr></table></figure></div>

<h4 id="批量获取-querySelectorAll"><a href="#批量获取-querySelectorAll" class="headerlink" title="批量获取 .querySelectorAll()"></a>批量获取 <code>.querySelectorAll()</code></h4><p>选择满足条件的所有元素</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lis = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;ul li&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类数组特性：</span></span><br><span class="line">lis.<span class="property">length</span> <span class="comment">// 元素数量</span></span><br><span class="line">lis[<span class="number">0</span>] <span class="comment">// 索引访问</span></span><br><span class="line">lis.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123; <span class="comment">/* 遍历操作 */</span> &#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="操作元素内容"><a href="#操作元素内容" class="headerlink" title="操作元素内容"></a>操作元素内容</h3><p>如果想修改标签元素里的内容，可以使用：</p>
<h4 id="直接操作文字-innerText"><a href="#直接操作文字-innerText" class="headerlink" title="直接操作文字 .innerText"></a>直接操作文字 <code>.innerText</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯文本模式</span></span><br><span class="line">box.<span class="property">innerText</span> = <span class="string">&#x27;你好世界&#x27;</span> <span class="comment">// 直接修改文字，但不解析HTML标签</span></span><br></pre></td></tr></table></figure></div>

<h4 id="解析标签-innerHTML"><a href="#解析标签-innerHTML" class="headerlink" title="解析标签 .innerHTML"></a>解析标签 <code>.innerHTML</code></h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取元素</span></span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML模式</span></span><br><span class="line">box.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;strong&gt;重点内容&lt;/strong&gt;&#x27;</span> <span class="comment">// 可以插入加粗/颜色等效果</span></span><br></pre></td></tr></table></figure></div>

<h3 id="操作元素样式"><a href="#操作元素样式" class="headerlink" title="操作元素样式"></a>操作元素样式</h3><h4 id="行内样式修改-style"><a href="#行内样式修改-style" class="headerlink" title="行内样式修改 style"></a>行内样式修改 <code>style</code></h4><p>能够直接操作元素，优先级最高，适合<strong>少量动态样式调整</strong> 。<br>多单词属性需用驼峰命名（如 <code>fontSize</code>）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个样式修改</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;#fff&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量修改（了解，更推荐类名替换）</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(box.<span class="property">style</span>, &#123;</span><br><span class="line">  <span class="attr">padding</span>: <span class="string">&#x27;10px&#x27;</span>,</span><br><span class="line">  <span class="attr">border</span>: <span class="string">&#x27;1px solid #ddd&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h4 id="类名替换-className"><a href="#类名替换-className" class="headerlink" title="类名替换 className"></a>类名替换 <code>className</code></h4><p>直接替换元素，适合<strong>整体样式切换</strong><br> 会覆盖原有类名，需手动拼接保留原有类</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 覆盖模式</span></span><br><span class="line">box.<span class="property">className</span> = <span class="string">&#x27;active&#x27;</span> <span class="comment">// 一个CSS类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加模式（了解，更推荐类列表操作）</span></span><br><span class="line">box.<span class="property">className</span> += <span class="string">&#x27; active&#x27;</span> <span class="comment">// 原始类需存在空格结尾</span></span><br></pre></td></tr></table></figure></div>

<h4 id="类列表操作-classList"><a href="#类列表操作-classList" class="headerlink" title="类列表操作 classList"></a>类列表操作 <code>classList</code></h4><p>精准增删类，<strong>现代开发首选方案</strong><br>不破坏原有类、支持批量操作、自带状态检测</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常用操作</span></span><br><span class="line">box.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>)    <span class="comment">// 添加类</span></span><br><span class="line">box.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;box&#x27;</span>)    <span class="comment">// 移除类</span></span><br><span class="line">box.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;show&#x27;</span>)   <span class="comment">// 切换类 有就删掉，没有就加上。</span></span><br><span class="line"></span><br><span class="line">box.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;active&#x27;</span>)   <span class="comment">// 看看包不包含某个类，如果有返回true，没有返回false</span></span><br></pre></td></tr></table></figure></div>

<h3 id="操作表单元素"><a href="#操作表单元素" class="headerlink" title="操作表单元素"></a>操作表单元素</h3><p><strong>常规属性操作</strong></p>
<p>普通的有属性有取值的跟其他的标签属性没有任何区别（例如 <code>type</code>&#x2F;<code>value</code>）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取密码框元素</span></span><br><span class="line"><span class="keyword">const</span> pwdInput = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#password&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pwdInput.<span class="property">type</span>) <span class="comment">// &quot;password&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性实现密码显示切换</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">togglePassword</span>(<span class="params"></span>) &#123;</span><br><span class="line">  pwdInput.<span class="property">type</span> = pwdInput.<span class="property">type</span> === <span class="string">&#x27;password&#x27;</span> ? <span class="string">&#x27;text&#x27;</span> : <span class="string">&#x27;password&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>布尔属性操作</strong></p>
<p>表单属性中添加就有效果，移除就没有效果，一律使用布尔值表示</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 禁用按钮</span></span><br><span class="line">submitBtn.<span class="property">disabled</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 勾选复选框</span></span><br><span class="line">checkbox.<span class="property">checked</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选中下拉选项</span></span><br><span class="line">option.<span class="property">selected</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p><strong>标准属性</strong></p>
<p>HTML 标签原生支持的属性，比如 <code>classid</code> ，<code>title</code> 等，可以直接使用点语法操作。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取class属性</span></span><br><span class="line"><span class="keyword">const</span> className = element.<span class="property">className</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改title属性</span></span><br><span class="line">element.<span class="property">title</span> = <span class="string">&#x27;新的提示信息&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>自定义属性</strong></p>
<p>在 HTML5 中推出来了专门的 data-自定义属性，标签上一律以 data-开头。</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML定义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">data-user-id</span>=<span class="string">&quot;123&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">data-order-status</span>=<span class="string">&quot;pending&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>DOM 对象上一律以 <code>dataset</code> 对象方式获取：</p>
<table>
<thead>
<tr>
<th>选择器类型</th>
<th>示例</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>存在属性</strong></td>
<td><code>[data-role]</code></td>
<td>选择所有带 data-role 的元素</td>
</tr>
<tr>
<td><strong>精确匹配</strong></td>
<td><code>[data-role=&quot;admin&quot;]</code></td>
<td>选择 data-role 等于 admin 的元素</td>
</tr>
<tr>
<td><strong>包含子串</strong></td>
<td><code>[data-tag*=&quot;error&quot;]</code></td>
<td>选择 data-tag 包含 “error” 的元素</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 dataset 对象访问（自动驼峰转换）</span></span><br><span class="line"><span class="keyword">const</span> userId = element.<span class="property">dataset</span>.<span class="property">userId</span> <span class="comment">// &quot;123&quot;</span></span><br><span class="line"><span class="keyword">const</span> orderStatus = element.<span class="property">dataset</span>.<span class="property">orderStatus</span> <span class="comment">// &quot;pending&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改属性</span></span><br><span class="line">element.<span class="property">dataset</span>.<span class="property">orderStatus</span> = <span class="string">&#x27;shipped&#x27;</span> <span class="comment">// 自动转为 data-order-status</span></span><br></pre></td></tr></table></figure></div>

<p>用 css 选择器也可以选择自定义属性：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* CSS */</span></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 所有自定义按钮 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[data-btn-type]</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">padding</span>: <span class="number">8px</span> <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 精确匹配主要按钮 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[data-btn-type=<span class="string">&quot;primary&quot;</span>]</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background</span>: <span class="number">#007bff</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 包含&quot;loading&quot;状态的元素 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[data-btn-state*=<span class="string">&quot;load&quot;</span>]</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">opacity</span>: <span class="number">0.7</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">cursor</span>: wait;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 以&quot;sec&quot;开头的按钮类型 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-attr">[data-btn-type^=<span class="string">&quot;sec&quot;</span>]</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">background</span>: <span class="number">#6c757d</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-btn-type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>主要按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-btn-type</span>=<span class="string">&quot;secondary&quot;</span>&gt;</span>次要按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">data-btn-state</span>=<span class="string">&quot;loading&quot;</span>&gt;</span>加载中<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h1 id="BOM-浏览器对象模型"><a href="#BOM-浏览器对象模型" class="headerlink" title="BOM 浏览器对象模型"></a>BOM 浏览器对象模型</h1><p>Browser Object Model（浏览器对象模型）用于提供与浏览器窗口交互的对象和方法，是浏览器提供给开发者操作浏览器窗口的接口集合。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E5%B8%B8%E7%94%A8api/file-20250324191100113.jpg"
                     
                ></p>
<p>其中  <strong><code>window</code>  对象</strong>是 BOM 的核心入口，既是全局对象（所有顶层变量&#x2F;函数都自动挂载到 window），也是浏览器窗口的抽象（控制导航栏、窗口尺寸等）。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有 var 定义的全局变量都会成为 window 的属性</span></span><br><span class="line"><span class="keyword">var</span> siteName = <span class="string">&quot;我的网站&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">siteName</span>); <span class="comment">// 输出&quot;我的网站&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内置方法本质上属于 window</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot;等同于直接调用 alert()&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<h3 id="Location-管理当前页面地址"><a href="#Location-管理当前页面地址" class="headerlink" title="Location 管理当前页面地址"></a>Location 管理当前页面地址</h3><p>Location 对象是浏览器地址栏的智能解析器，它将完整的 URL 地址拆解为多个可操作的组成部分。<br>就像快递员能快速找到包裹上的收件人信息，我们可以通过它精确获取或修改地址的各个部分。</p>
<p><strong>获取完整地址</strong> <code>.href</code></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前页面地址：&#x27;</span>, location.<span class="property">href</span>);</span><br><span class="line"><span class="comment">// 输出示例：https://www.example.com/products?id=123#details</span></span><br></pre></td></tr></table></figure></div>

<p><strong>地址跳转控制</strong> <code>.href = </code></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳转到新地址（保留历史记录）</span></span><br><span class="line">location.<span class="property">href</span> = <span class="string">&#x27;https://new.example.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制刷新页面（类似 Ctrl+F5）</span></span><br><span class="line"><span class="keyword">const</span> refreshBtn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#reloadBtn&#x27;</span>);</span><br><span class="line">refreshBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  location.<span class="title function_">reload</span>(<span class="literal">true</span>); <span class="comment">// 参数true表示跳过缓存</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><strong>解析地址参数</strong>：<code>.search/.hash</code></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设当前地址为：https://www.example.com/search?keyword=手机&amp;page=2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;查询参数：&#x27;</span>, location.<span class="property">search</span>); <span class="comment">// 输出 ?keyword=手机&amp;page=2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;哈希参数：&#x27;</span>, location.<span class="property">hash</span>);    <span class="comment">// 输出 #details（常用于单页应用路由）</span></span><br></pre></td></tr></table></figure></div>

<h3 id="Navigator-提供浏览器-设备信息"><a href="#Navigator-提供浏览器-设备信息" class="headerlink" title="Navigator 提供浏览器&#x2F;设备信息"></a>Navigator 提供浏览器&#x2F;设备信息</h3><p>Navigator 对象是浏览器的身份档案库，存储着浏览器类型、版本、操作系统等关键信息。<br>开发者可以借此实现浏览器适配。</p>
<p><strong>移动设备检测与跳转</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测用户设备</span></span><br><span class="line"><span class="keyword">const</span> isMobile = <span class="regexp">/Android|webOS|iPhone|iPad|iPod|BlackBerry/i</span>.<span class="title function_">test</span>(navigator.<span class="property">userAgent</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动跳转移动端站点</span></span><br><span class="line"><span class="keyword">if</span> (isMobile) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;https://m.example.com&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="History-管理浏览历史记录"><a href="#History-管理浏览历史记录" class="headerlink" title="History 管理浏览历史记录"></a>History 管理浏览历史记录</h3><p>History 对象管理着浏览器的访问历史记录，提供在历史记录中导航的能力。<br>可以精确控制用户的浏览轨迹。</p>
<ol>
<li><strong>基础导航</strong> <code>.back()/.forward()</code></li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后退一步（相当于点击浏览器后退按钮）</span></span><br><span class="line">history.<span class="title function_">back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进一步（相当于点击浏览器前进按钮）</span></span><br><span class="line">history.<span class="title function_">forward</span>();</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong>精确跳转</strong>：<code>go()</code></li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前进2个历史记录</span></span><br><span class="line">history.<span class="title function_">go</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退3个历史记录</span></span><br><span class="line">history.<span class="title function_">go</span>(-<span class="number">3</span>);</span><br></pre></td></tr></table></figure></div>

<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>当用户使用特定方式互动（事件类型），系统就会自动执行对应功能（处理函数）。这种机制让网页具备响应用户交互的能力。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">元素对象.<span class="title function_">addEventListener</span>(<span class="string">&#x27;事件类型&#x27;</span>，要执行的函数)</span><br></pre></td></tr></table></figure></div>

<p>事件监听有以下三要素解析:</p>
<p><strong>1. 事件源</strong> - 确定监控目标<br><strong>2. 事件类型</strong> - 定义触发方式<br><strong>3. 处理函数</strong> - 设置响应行为</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 网页结构示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;demo-btn&quot;</span>&gt;</span>点击抽奖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;result-box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 锁定抽奖按钮</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.demo-btn&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 设计抽奖逻辑</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">startLottery</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> prizes = [<span class="string">&#x27;一等奖&#x27;</span>, <span class="string">&#x27;二等奖&#x27;</span>, <span class="string">&#x27;谢谢参与&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> result = prizes[<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">3</span>)]</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.result-box&#x27;</span>).<span class="property">textContent</span> = <span class="string">`恭喜获得：<span class="subst">$&#123;result&#125;</span>`</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 建立点击监听</span></span></span><br><span class="line"><span class="language-javascript">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, startLottery)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>鼠标触发</p>
<ul>
<li><code>click</code>：鼠标点击触发</li>
<li>**<code>mouseover</code>**：鼠标经过触发</li>
<li>**<code>mouseout</code>**：鼠标离开触发</li>
<li><code>mouseenter</code>：鼠标经过触发 ❌ <strong>不冒泡</strong></li>
<li><code>mouseleave</code>：鼠标离开触发 ❌ <strong>不冒泡</strong></li>
</ul>
<h4 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h4><p>表单获得或失去光标</p>
<ul>
<li>**<code>focusin</code>**：获得焦点</li>
<li>**<code>focusout</code>**：失去焦点</li>
<li><code>focus</code>：表单元素获得焦点时触发 ❌ <strong>不冒泡</strong></li>
<li><code>blur</code>：表单元素失去焦点时触发 ❌ <strong>不冒泡</strong></li>
</ul>
<h4 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h4><p>键盘触发</p>
<ul>
<li><code>keydown</code>：键盘按下触发</li>
<li><code>keyup</code>：键盘抬起触发</li>
</ul>
<h4 id="文本事件"><a href="#文本事件" class="headerlink" title="文本事件"></a>文本事件</h4><p>表单输入触发</p>
<ul>
<li><code>input</code>：用户在表单元素中输入内容时触发</li>
<li>**<code>change</code>**：仅在值提交时触发（如输入框失焦、下拉框选择完成）</li>
</ul>
<h3 id="移动端触屏事件"><a href="#移动端触屏事件" class="headerlink" title="移动端触屏事件"></a>移动端触屏事件</h3><table>
<thead>
<tr>
<th>事件名称</th>
<th>触发时机</th>
</tr>
</thead>
<tbody><tr>
<td><strong>touchstart</strong></td>
<td>手指接触屏幕瞬间触发</td>
</tr>
<tr>
<td><strong>touchmove</strong></td>
<td>手指在屏幕上滑动时 <strong>持续触发</strong></td>
</tr>
<tr>
<td><strong>touchend</strong></td>
<td>手指离开屏幕时触发</td>
</tr>
</tbody></table>
<p><strong>标准事件绑定写法</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触摸开始（记录起始位置）</span></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;触点坐标:&#x27;</span>, e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientX</span>, e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientY</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触摸移动（实时跟踪）</span></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchmove&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>() <span class="comment">// 阻止默认滑动行为（常见于轮播图）</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;移动中:&#x27;</span>, e.<span class="property">changedTouches</span>[<span class="number">0</span>].<span class="property">clientX</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触摸结束（完成操作）</span></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作结束&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><strong>应用场景</strong></p>
<ol>
<li>图片滑动切换</li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> startX = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> slider = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.slider&#x27;</span>)</span><br><span class="line"></span><br><span class="line">slider.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  startX = e.<span class="property">touches</span>[<span class="number">0</span>].<span class="property">clientX</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">slider.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> endX = e.<span class="property">changedTouches</span>[<span class="number">0</span>].<span class="property">clientX</span></span><br><span class="line">  <span class="keyword">if</span> (endX - startX &gt; <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;向右滑动&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startX - endX &gt; <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;向左滑动&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>长按菜单触发</li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> timer</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(showMenu, <span class="number">1000</span>) <span class="comment">// 长按1秒显示菜单</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;touchend&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">clearTimeout</span>(timer) <span class="comment">// 提前松开则取消</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h3><p>当  <code>&lt;script&gt;</code>  标签放在  <code>&lt;head&gt;</code>  中时，DOM 元素尚未解析会导致元素获取失败。</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    // <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> 标签放在 &lt;head&gt; 中时，<span class="variable constant_">DOM</span> 元素尚未解析的问题</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">    <span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myElement&quot;</span>); <span class="comment">// 返回 null</span></span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="language-handlebars">  </span></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myElement&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>解决方案：</p>
<ul>
<li>将 JS 代码放在 <code>&lt;body&gt;</code> 末尾</li>
<li>使用 页面加载事件 <strong>(新方法)</strong></li>
</ul>
<p>页面加载事件就是用于在特定阶段执行代码，确保操作 DOM 时，元素已存在。</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发时机</th>
<th>监听对象</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>load</code></td>
<td>页面所有资源（图片&#x2F;CSS&#x2F;JS）加载完成</td>
<td>window</td>
<td>需要操作依赖外部资源的元素</td>
</tr>
<tr>
<td><code>DOMContentLoaded</code><br>(常用)</td>
<td>HTML 文档解析完成（无需等外部资源）</td>
<td>document</td>
<td>尽早操作 DOM（如绑定事件）</td>
</tr>
</tbody></table>
<p>若先解析 HTML → 优先使用<code>DOMContentLoaded</code> （性能更好）<br>若后加载资源，操作资源相关元素时 → 使用<code>load</code></p>
<h4 id="load-等待所有资源"><a href="#load-等待所有资源" class="headerlink" title="load - 等待所有资源"></a><strong><code>load</code></strong> - 等待所有资源</h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 所有资源加载完成后执行</span></span><br><span class="line">  <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(img.<span class="property">width</span>); <span class="comment">// 此时能正确获取图片尺寸</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>特点</strong>：等待图片、CSS、JS 等全部加载</li>
<li><strong>典型场景</strong>：获取图片尺寸、操作依赖外部资源的元素</li>
</ul>
<h4 id="DOMContentLoaded-优先使用"><a href="#DOMContentLoaded-优先使用" class="headerlink" title="DOMContentLoaded - 优先使用"></a><strong><code>DOMContentLoaded</code></strong> - 优先使用</h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// HTML解析完成后立即执行（无需等图片/CSS）</span></span><br><span class="line">  <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#myButton&quot;</span>);</span><br><span class="line">  btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, handleClick); <span class="comment">// 安全绑定事件</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>特点</strong>：比 <code>load</code> 更快触发，只关注 HTML 结构</li>
<li><strong>典型场景</strong>：初始化交互功能、绑定事件监听器</li>
</ul>
<h3 id="页面窗口尺寸事件"><a href="#页面窗口尺寸事件" class="headerlink" title="页面窗口尺寸事件"></a>页面窗口尺寸事件</h3><p><code>resize</code> 事件：检测屏幕宽度，当浏览器窗口大小改变时触发（如用户拖动窗口边缘、切换横竖屏）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>,<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// 执行的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>属性</th>
<th>作用说明</th>
<th>包含内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong>clientWidth</strong></td>
<td>获取元素可视区域宽度</td>
<td>内容 + padding（不含滚动条、边框）</td>
</tr>
<tr>
<td><strong>clientHeight</strong></td>
<td>获取元素可视区域高度</td>
<td>内容 + padding</td>
</tr>
</tbody></table>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E5%B8%B8%E7%94%A8api/file-20250321192523249.jpg"
                     
                ><br>不包含边框（内容+padding，不含滚动条和边框），常用于布局计算。</p>
<p>例如，监听页面尺寸变化，并作出响应：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听窗口尺寸变化</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取窗口可视区域宽度（推荐）</span></span><br><span class="line">  <span class="keyword">const</span> width = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 示例：根据宽度切换布局</span></span><br><span class="line">  <span class="keyword">if</span> (width &lt; <span class="number">768</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;移动端布局&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;桌面端布局&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h3 id="元素滚动事件"><a href="#元素滚动事件" class="headerlink" title="元素滚动事件"></a>元素滚动事件</h3><p>滚动事件用于检测用户滚动页面或元素时的行为，常用于实现动态交互效果。</p>
<p><code>scroll</code> 事件：滚动条滚动时持续触发的事件</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// 执行的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>想要获取元素滚动了多少距离，就可以使用以下两个属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>scrollTop</strong></td>
<td>获取&#x2F;设置元素垂直滚动距离（被卷去的头部高度）</td>
</tr>
<tr>
<td><strong>scrollLeft</strong></td>
<td>获取&#x2F;设置元素水平滚动距离（被卷去的左侧宽度）</td>
</tr>
</tbody></table>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E5%B8%B8%E7%94%A8api/file-20250321161551857.jpg"
                     
                ></p>
<ul>
<li>获取元素内容往左、往上滚出去看不到的距离</li>
<li>这两个值是可读写的</li>
</ul>
<blockquote>
<p>📌 <strong><code>documentElement</code></strong> <br>是  <code>document</code>  对象的一个属性，指向当前文档的  <strong>根元素</strong>。<br>通过  <code>documentElement</code>  可以直接操作  <code>&lt;html&gt;</code>  元素，常用于获取页面级属性（如滚动位置、视口尺寸）</p>
</blockquote>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听页面滚动</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 获取页面垂直滚动距离（两种方式任选其一）</span></span><br><span class="line">  <span class="keyword">const</span> scroll = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>  <span class="comment">// 推荐方式</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 示例：滚动超过100px显示元素</span></span><br><span class="line">  <span class="keyword">if</span> (scrollY &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">    backToTopBtn.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;block&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>当获取的 scrollTop 值为 0 :</p>
<ul>
<li>检查是否错误地获取了<code>body</code>而非<code>documentElement</code></li>
<li>确认元素本身是否可滚动（需设置<code>overflow: scroll</code>）</li>
</ul>
</blockquote>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>)  <span class="comment">// 表示文档根元素（即&lt;html&gt;标签），用于获取页面滚动距离</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span>)            <span class="comment">// 旧版浏览器（了解即可）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改滚动位置（自动滚动到顶部）</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>性能优化</strong></li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用防抖函数优化高频触发</span></span><br><span class="line"><span class="keyword">let</span> timer</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 实际执行的操作</span></span><br><span class="line">  &#125;, <span class="number">50</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><strong>让元素平滑滚动</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用原生方法</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(&#123;</span><br><span class="line">  <span class="attr">top</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">behavior</span>: <span class="string">&quot;smooth&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或CSS添加全局样式</span></span><br><span class="line">html &#123;</span><br><span class="line">  scroll-<span class="attr">behavior</span>: smooth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>监听局部滚动 vs 页面滚动</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听指定元素的滚动（如div容器）</span></span><br><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.scroll-box&quot;</span>)</span><br><span class="line">box.<span class="title function_">addEventListener</span>(<span class="string">&quot;scroll&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">scrollTop</span>)  <span class="comment">// 获取容器内滚动距离</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><code>scrollTo())</code> 方法可把内容滚动到指定的坐标</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">元素.<span class="title function_">scrollTo</span>(x,y)</span><br><span class="line"><span class="comment">//让页面滚动到 y 轴 1000 像素的位置</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">scrollTo</span>(<span class="number">0</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="获取元素尺寸"><a href="#获取元素尺寸" class="headerlink" title="获取元素尺寸"></a>获取元素尺寸</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E5%B8%B8%E7%94%A8api/file-20250401131938941.jpg"
                     
                ></p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>计算范围</strong></th>
<th><strong>包含内容</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>.offsetWidth</code><br><code>.offsetHeight</code></td>
<td>元素完整尺寸（包括边框）</td>
<td>内容 + padding + border</td>
</tr>
<tr>
<td><strong><code>.clientWidth</code></strong><br><code>.clientHeight</code></td>
<td>元素内部可视尺寸（不含边框）</td>
<td>内容 + padding（不含滚动条和边框）</td>
</tr>
</tbody></table>
<ul>
<li>如果元素被隐藏（<code>display: none</code>），<code>offsetWidth</code>  和  <code>clientWidth</code>  会返回  <code>0</code>。</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.target-element&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素完整尺寸（含边框 border）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;元素宽度：&#x27;</span>, box.<span class="property">offsetWidth</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;元素高度：&#x27;</span>, box.<span class="property">offsetHeight</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元素尺寸（不含边框）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;元素宽度：&#x27;</span>, box.<span class="property">clientWidth</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;元素高度：&#x27;</span>, box.<span class="property">clientHeight</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="获取元素位置"><a href="#获取元素位置" class="headerlink" title="获取元素位置"></a>获取元素位置</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E5%B8%B8%E7%94%A8api/file-20250401131919814.jpg"
                     
                ></p>
<table>
<thead>
<tr>
<th><strong>属性&#x2F;方法</strong></th>
<th><strong>作用</strong></th>
<th><strong>参照物</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>.offsetLeft</code></strong> <br><code>.offsetTop</code></td>
<td>元素左侧相对于定位父级的距离</td>
<td>最近的定位父元素（<code>position≠static</code>）</td>
<td><code>box.offsetLeft</code></td>
</tr>
<tr>
<td><strong><code>.getBoundingClientRect()</code></strong></td>
<td>返回元素大小及相对于视口的精确坐标</td>
<td>浏览器视口左上角</td>
<td><code>box.getBoundingClientRect().top</code></td>
</tr>
</tbody></table>
<ul>
<li><code>offsetParent</code>：距离最近的定位父元素（<code>position≠static</code>）</li>
<li>无定位父级时，<code>offsetLeft/Top</code>相对于<code>&lt;body&gt;</code>计算</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.target-element&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取相对定位父级的位置</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;X轴位置：&#x27;</span>, box.<span class="property">offsetLeft</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Y轴位置：&#x27;</span>, box.<span class="property">offsetTop</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取位置：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="title function_">getBoundingClientRect</span>())</span><br></pre></td></tr></table></figure></div>

<p><code>getBoundingClientRect()</code>  可以一次性告诉你  <strong>元素的大小和位置</strong>，而且是相对于  <strong>浏览器窗口（视口）</strong>  的坐标。<br>调用这个方法会返回一个对象，包含以下关键属性：</p>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>top</code></td>
<td>元素顶部到视口顶部的距离（px）</td>
</tr>
<tr>
<td><code>left</code></td>
<td>元素左侧到视口左侧的距离（px）</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td>元素底部到视口顶部的距离（px）</td>
</tr>
<tr>
<td><code>right</code></td>
<td>元素右侧到视口左侧的距离（px）</td>
</tr>
<tr>
<td><code>width</code></td>
<td>元素的宽度（包含边框和 padding）</td>
</tr>
<tr>
<td><code>height</code></td>
<td>元素的高度（包含边框和 padding）</td>
</tr>
</tbody></table>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E5%B8%B8%E7%94%A8api/file-20250401133919094.jpg"
                     
                ></p>
<p>这个方法在某些情况下使用十分方便：</p>
<p><strong>检测元素是否在视口中（懒加载）</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.lazy-image&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> rect = element.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断元素是否进入视口</span></span><br><span class="line"><span class="keyword">if</span> (rect.<span class="property">top</span> &lt; <span class="variable language_">window</span>.<span class="property">innerHeight</span> &amp;&amp; rect.<span class="property">bottom</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;元素进入视口了，可以加载图片了！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>实现拖拽功能（获取实时位置）</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousedown&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rect = element.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">  <span class="comment">// 记录初始位置</span></span><br><span class="line">  <span class="keyword">const</span> offsetX = e.<span class="property">clientX</span> - rect.<span class="property">left</span>;</span><br><span class="line">  <span class="keyword">const</span> offsetY = e.<span class="property">clientY</span> - rect.<span class="property">top</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拖拽逻辑...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><strong>计算元素居中位置</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">centerElement</span>(<span class="params">element</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rect = element.<span class="title function_">getBoundingClientRect</span>();</span><br><span class="line">  <span class="keyword">const</span> centerX = <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="number">2</span> - rect.<span class="property">width</span> / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> centerY = <span class="variable language_">window</span>.<span class="property">innerHeight</span> / <span class="number">2</span> - rect.<span class="property">height</span> / <span class="number">2</span>;</span><br><span class="line">  element.<span class="property">style</span>.<span class="property">left</span> = centerX + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">  element.<span class="property">style</span>.<span class="property">top</span> = centerY + <span class="string">&quot;px&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><p><strong>尺寸获取注意事项</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐藏元素无法获取有效尺寸</span></span><br><span class="line">hiddenElement.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(hiddenElement.<span class="property">offsetWidth</span>) <span class="comment">// 输出0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取窗口尺寸的三种方式对比</span></span><br><span class="line"><span class="keyword">const</span> windowWidth = <span class="variable language_">window</span>.<span class="property">innerWidth</span>        <span class="comment">// 包含滚动条（不推荐）</span></span><br><span class="line"><span class="keyword">const</span> clientWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>  <span class="comment">// 不包含滚动条（推荐）</span></span><br><span class="line"><span class="keyword">const</span> offsetWidth = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">offsetWidth</span>  <span class="comment">// 包含滚动条（特殊场景使用）</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="环境对象-this"><a href="#环境对象-this" class="headerlink" title="环境对象 this"></a>环境对象 <code>this</code></h2><p><strong>「谁调用，this 就是谁」</strong><br>通过函数<strong>被调用的方式</strong>确定 this 指向，而非函数定义的位置</p>
<h3 id="全局调用"><a href="#全局调用" class="headerlink" title="全局调用"></a>全局调用</h3><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showThis</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)  <span class="comment">// 输出 window 对象（浏览器环境）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>函数被全局环境直接调用，相当于 <code>window.showThis()</code></p>
<h3 id="对象方法调用"><a href="#对象方法调用" class="headerlink" title="对象方法调用"></a>对象方法调用</h3><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> phone = &#123;</span><br><span class="line">  <span class="attr">brand</span>: <span class="string">&#x27;华为&#x27;</span>,</span><br><span class="line">  <span class="attr">showInfo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">brand</span>) <span class="comment">// 输出 &quot;华为&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">phone.<span class="title function_">showInfo</span>() <span class="comment">// this → phone 对象</span></span><br></pre></td></tr></table></figure></div>

<h3 id="DOM-事件处理"><a href="#DOM-事件处理" class="headerlink" title="DOM 事件处理"></a>DOM 事件处理</h3><div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;demo-btn&quot;</span>&gt;</span>点击测试<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.demo-btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// 输出当前按钮的 DOM 对象</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p><strong>原理</strong>：事件触发时，浏览器自动将 this 绑定到触发事件的元素</p>
<ol>
<li>箭头函数中的 this 行为不同（后续专题讲解）</li>
<li>使用 <code>call</code>&#x2F;<code>apply</code> 可手动修改 this 指向（进阶内容）</li>
<li>严格模式下全局调用的 this 为 undefined</li>
</ol>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数表现为：将函数作为参数传递给另一函数，由接收方在特定时机调用。</p>
<ul>
<li><strong>参数化传递</strong>：函数被当作普通参数传递</li>
<li><strong>执行权转移</strong>：由接收函数决定何时调用</li>
<li><strong>功能解耦</strong>：分离核心逻辑与定制化操作</li>
</ul>
<p>例如，事件响应就是一个回调函数</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匿名回调函数</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#buy-btn&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;商品已加入购物车&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>当用户与网页交互（点击、滚动、输入等）触发事件时，浏览器会创建<strong>事件对象（Event Object）</strong>，并将所有与事件相关的信息封装在其中。</p>
<p>就像快递包裹单，记录了发件人、收件人、包裹内容等信息，<strong>事件对象（Event Object）</strong>   就是事件的“快递单”，告诉你事件的详细数据。</p>
<h3 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h3><p>在事件绑定的回调函数中，通过<strong>第一个参数</strong>接收事件对象：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">元素.<span class="title function_">addEventListener</span>(<span class="string">&#x27;事件类型&#x27;</span>, <span class="keyword">function</span>(<span class="params">事件对象</span>) &#123;</span><br><span class="line">  <span class="comment">// 通过事件对象获取信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p>例如，点击事件信息获取</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123; <span class="comment">// e 为事件对象</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;事件类型：&#x27;</span>, e.<span class="property">type</span>) <span class="comment">// 输出 &quot;click&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>作用说明</strong></th>
<th><strong>典型应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>e.type</code></td>
<td>获取触发的事件类型<br>（如 “click”、”keydown”）</td>
<td>判断当前事件类型</td>
</tr>
<tr>
<td><code>e.clientX/Y</code></td>
<td>光标相对于<strong>浏览器窗口</strong>左上角的坐标</td>
<td>实现拖拽元素时的位置跟踪</td>
</tr>
<tr>
<td><code>e.offsetX/Y</code></td>
<td>光标相对于<strong>当前元素</strong>左上角的坐标<br>（易受到<code>position</code>属性影响）</td>
<td>绘制画板时的笔触定位</td>
</tr>
<tr>
<td><code>e.key</code></td>
<td>用户按下的键盘按键标识<br>（如 “Enter”）</td>
<td>表单提交的快捷键支持</td>
</tr>
</tbody></table>
<h4 id="光标坐标定位"><a href="#光标坐标定位" class="headerlink" title="光标坐标定位"></a>光标坐标定位</h4><ul>
<li><p><strong>窗口坐标系</strong> (<code>clientX/Y</code>)<br>以浏览器可视区域左上角为原点，适合处理全局位置相关的交互</p>
</li>
<li><p><strong>元素坐标系</strong> (<code>offsetX/Y</code>)<br>以当前触发元素左上角为原点，适合处理元素内部相对位置</p>
</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">    <span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> area = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.area&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 鼠标移动时更新元素位置</span></span><br><span class="line">    area.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> areaEl = area.<span class="title function_">getBoundingClientRect</span>()</span><br><span class="line">      <span class="keyword">const</span> boxWidth = box.<span class="property">offsetWidth</span></span><br><span class="line">      <span class="keyword">const</span> boxHeight = box.<span class="property">offsetHeight</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> areaWidth = area.<span class="property">offsetWidth</span></span><br><span class="line">      <span class="keyword">const</span> areaHeight = area.<span class="property">offsetHeight</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 得到鼠标相对于整个区域的位置</span></span><br><span class="line">      <span class="keyword">const</span> cursorX = e.<span class="property">clientX</span> - areaEl.<span class="property">left</span></span><br><span class="line">      <span class="keyword">const</span> cursorY = e.<span class="property">clientY</span> - areaEl.<span class="property">top</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 由鼠标得到移动的元素位置</span></span><br><span class="line">      <span class="keyword">let</span> positionX = cursorX - boxWidth / <span class="number">2</span></span><br><span class="line">      <span class="keyword">let</span> positionY = cursorY - boxHeight / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 限制元素位置</span></span><br><span class="line">      positionX = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(positionX, areaWidth - boxWidth))</span><br><span class="line">      positionY = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(positionY, areaHeight - boxHeight))</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将值赋给元素</span></span><br><span class="line">      box.<span class="property">style</span>.<span class="property">left</span> = positionX + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">      box.<span class="property">style</span>.<span class="property">top</span> = positionY + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="🌟-边界限制小技巧"><a href="#🌟-边界限制小技巧" class="headerlink" title="🌟 边界限制小技巧"></a>🌟 <strong>边界限制小技巧</strong></h3><p><strong>公式</strong>：<code>数值 = Math.max(最小值, Math.min(数值, 最大值))</code><br><strong>作用</strong>：将任意数值限制在 <code>[最小值, 最大值]</code> 范围内，防止越界。</p>
<ol>
<li><p><strong>拖拽边界限制</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 水平不超出容器</span></span><br><span class="line">x = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(x, 容器宽度 - 元素宽度));</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>滚动条位置约束</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">scrollTop = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(scrollTop, 最大可滚动距离));</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>颜色透明度控制</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">alpha = <span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="number">0</span>, <span class="title class_">Math</span>.<span class="title function_">min</span>(alpha, <span class="number">1</span>)); <span class="comment">// 0~1之间</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="键盘事件-1"><a href="#键盘事件-1" class="headerlink" title="键盘事件"></a>键盘事件</h4><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keydown&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(e.<span class="property">key</span> === <span class="string">&#x27;Enter&#x27;</span>) &#123; <span class="comment">// 使用 key 属性</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户按下了回车键&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>废弃属性</strong>：<code>keyCode</code> 已不推荐使用，现代浏览器统一使用 <code>key</code></p>
</blockquote>
<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>假设页面里有个 div，当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E5%B8%B8%E7%94%A8api/file-20250321103525954.jpg"
                     
                ></p>
<p>简单来说：捕获阶段是从父到子，冒泡阶段是从子到父。<br>实际工作主要使用事件冒泡为主。</p>
<h3 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h3><h4 id="事件捕获（从外到内）"><a href="#事件捕获（从外到内）" class="headerlink" title="事件捕获（从外到内）"></a>事件捕获（从外到内）</h4><ul>
<li>从 document 根元素开始，逐级向下传递到目标元</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, 处理函数, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></div>

<h4 id="事件冒泡（从内到外-默认）"><a href="#事件冒泡（从内到外-默认）" class="headerlink" title="事件冒泡（从内到外 | 默认）"></a>事件冒泡（从内到外 | 默认）</h4><ul>
<li>从目标元素逐级向上传递到 document</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, 处理函数)</span><br><span class="line"><span class="comment">// 第三个参数默认false</span></span><br></pre></td></tr></table></figure></div>

<h3 id="事件处理-1"><a href="#事件处理-1" class="headerlink" title="事件处理"></a>事件处理</h3><h4 id="阻止冒泡-stopPropagation"><a href="#阻止冒泡-stopPropagation" class="headerlink" title="阻止冒泡 .stopPropagation()"></a>阻止冒泡 <code>.stopPropagation()</code></h4><p>因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素。<br>若想避免干扰父元素，就需要阻止事件冒泡。</p>
<p><code>事件对象.stopPropagation()</code></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="title function_">stopPropagation</span>() <span class="comment">// 阻止继续向上/向下传递</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p>注意：此方法可以阻断事件流动传播，不光在冒泡阶段有效，捕获阶段也有效。</p>
<h4 id="阻止默认行为-preventDefault"><a href="#阻止默认行为-preventDefault" class="headerlink" title="阻止默认行为 .preventDefault()"></a>阻止默认行为 <code>.preventDefault()</code></h4><p>我们某些情况下需要阻止默认行为的发生，比如阻止链接的跳转，表单域跳转.</p>
<p><code>e.preventDetault()</code></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span><br><span class="line">  &lt;inputtype=<span class="string">&quot;submit&quot;</span>value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> form =<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;form&#x27;</span>)</span><br><span class="line">  form.<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>,<span class="keyword">function</span> (<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="comment">// 阻止表单默认提交行为</span></span><br><span class="line">  e.<span class="title function_">preventDefault</span>()</span><br><span class="line">  <span class="comment">// 清空表单</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">reset</span>()</span><br><span class="line">)&#125;</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h4><p><strong>传统方式</strong></p>
<p>on 事件方式，直接使用 <code>null</code> 覆盖偶就可以实现事件的解绑。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击&#x27;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑（直接覆盖）</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure></div>

<p><strong>现代方式</strong></p>
<p>addEventListener 方式，必须使用：</p>
<p><code>removeEventListener(事件类型，事件处理函数，[获取捕获或者冒泡阶段])</code></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 必须使用命名函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;点击&#x27;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解绑（精确控制）</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick)</span><br></pre></td></tr></table></figure></div>

<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托如同<strong>快递代收点</strong>：<br>所有子元素的交互事件由父元素统一处理。利用事件冒泡机制，将子元素的事件监听委托给父元素，大幅提升代码效率和可维护性。</p>
<h3 id="1-绑定父元素"><a href="#1-绑定父元素" class="headerlink" title="1. 绑定父元素"></a>1. 绑定父元素</h3><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.list&#x27;</span>)  <span class="comment">// 获取父容器</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-识别触发源"><a href="#2-识别触发源" class="headerlink" title="2. 识别触发源"></a>2. 识别触发源</h3><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">list.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> target = e.<span class="property">target</span>  <span class="comment">// 获取实际点击元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h3 id="3-过滤目标元素-tagName-matches"><a href="#3-过滤目标元素-tagName-matches" class="headerlink" title="3. 过滤目标元素 (.tagName&#x2F;matches())"></a>3. 过滤目标元素 (<code>.tagName</code>&#x2F;<code>matches()</code>)</h3><p><code>.tagName</code> 精确匹配元素类型</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(target.<span class="property">tagName</span> === <span class="string">&#x27;LI&#x27;</span>) &#123;  <span class="comment">// 注意大写字母</span></span><br><span class="line">  target.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span>   <span class="comment">// 操作目标元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进阶：匹配特定class元素</span></span><br><span class="line"><span class="keyword">if</span>(target.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;item&#x27;</span>)) &#123;</span><br><span class="line">  <span class="comment">// 执行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>matches()</code> 使用 CSS 选择器语法，精确查找元素</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (target.<span class="title function_">matches</span>(<span class="string">&#x27;li.item&#x27;</span>)) &#123;</span><br><span class="line">  <span class="comment">// 同时满足两个条件：是 &lt;li&gt; 标签 + 有 item 类名</span></span><br><span class="line">  target.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例如，一个任务点击焦糊</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;task-list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>写项目文档<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>代码审查<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>团队会议<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.task-list&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 点击任意li时切换完成状态</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span>(e.<span class="property">target</span>.<span class="property">tagName</span> === <span class="string">&#x27;LI&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    e.<span class="property">target</span>.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;completed&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>注意</strong>：<code>tagName</code> 返回值为大写字符串（如 <code>LI</code>、<code>BUTTON</code>）</p>
</blockquote>
<p><strong><code>e.target</code>  和  <code>this</code>  的区别</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.parent&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>);    <span class="comment">// 实际点击的子元素（如按钮）</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);        <span class="comment">// 绑定事件的父元素（.parent）</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>**<code>e.target</code>**：用户点击的具体元素（可能是子元素）。</li>
<li>**<code>this</code>**：事件绑定的元素（始终是  <code>.parent</code>）。</li>
</ul>
<h1 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h1><p>DOM 树里每一个内容都称之为节点<br>节点类型包含：</p>
<ul>
<li><strong>元素节点</strong>：所有的 HTML 标签（如 <code>body</code>、<code>div</code>），</li>
<li><strong>属性节点</strong>：所有的属性 （如 <code>href</code>）</li>
<li><strong>文本节点</strong>：标签内的文字</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E5%B8%B8%E7%94%A8api/file-20250323121339239.jpg"
                     
                ></p>
<p>👉 元素节点是 DOM 操作的核心对象，其他节点通过元素节点访问</p>
<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><p>当无法直接获取目标元素时，通过已知元素与目标元素的  <strong>亲属关系</strong>  快速定位。<br>常见的 亲属关系 查找有以下三种：</p>
<h4 id="父节点查找-parentNode"><a href="#父节点查找-parentNode" class="headerlink" title="父节点查找 parentNode"></a>父节点查找 <code>parentNode</code></h4><p>使用方法：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">子元素.<span class="property">parentNode</span></span><br></pre></td></tr></table></figure></div>

<p>只返回   最近一级的 <strong>元素节点</strong>（跳过文本&#x2F;注释节点） ，找不到时返回为 null</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">closeBtn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parentNode</span>.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span> <span class="comment">// 直接操作父元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<h4 id="子节点查找-children"><a href="#子节点查找-children" class="headerlink" title="子节点查找 children"></a>子节点查找 <code>children</code></h4><ol>
<li><code>children</code>（✅ 推荐使用）</li>
</ol>
<p>返回所有  <strong>子元素节点</strong>  的 <strong>伪数组</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取列表项</span></span><br><span class="line"><span class="keyword">const</span> listItems = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>).<span class="property">children</span></span><br></pre></td></tr></table></figure></div>

<p>2. <code>childNodes</code></p>
<p>返回包含  <strong>所有类型子节点</strong>  的集合（包括文本节点、注释节点等）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 典型问题案例</span></span><br><span class="line"><span class="keyword">const</span> nodes = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>).<span class="property">childNodes</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nodes) <span class="comment">// 可能包含无意义的换行文本节点</span></span><br></pre></td></tr></table></figure></div>

<p>优先使用  <code>children</code>  精确获取子元素，避免处理干扰节点</p>
<h4 id="兄弟关系查找-ElementSibling"><a href="#兄弟关系查找-ElementSibling" class="headerlink" title="兄弟关系查找 ElementSibling"></a>兄弟关系查找 <code>ElementSibling</code></h4><p>自动跳过文本&#x2F;注释节点，只返回元素节点 ，若无兄弟元素则返回  <code>null</code></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>属性</th>
<th>返回内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong>下一个兄弟元素</strong></td>
<td><code>nextElementSibling</code></td>
<td>紧邻的下一个元素节点</td>
</tr>
<tr>
<td><strong>上一个兄弟元素</strong></td>
<td><code>previousElementSibling</code></td>
<td>紧邻的上一个元素节点</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高亮当前项的下一个兄弟元素</span></span><br><span class="line">currentItem.<span class="property">nextElementSibling</span>.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;yellow&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><p>动态增删节点能够实现用户交互驱动的  <strong>内容动态更新</strong></p>
<h4 id="创建节点-：document-createElement"><a href="#创建节点-：document-createElement" class="headerlink" title="创建节点 ：document.createElement()"></a>创建节点 ：<code>document.createElement()</code></h4><p>创造出一个新的网页元素，再通过 <strong>追加节点</strong> 把创建的节点插入</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建新元素（此时尚未显示在页面中）</span></span><br><span class="line"><span class="keyword">const</span> newDiv = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">newDiv.<span class="property">className</span> = <span class="string">&#x27;card&#x27;</span> <span class="comment">// 添加类名</span></span><br><span class="line">newDiv.<span class="property">textContent</span> = <span class="string">&#x27;新卡片&#x27;</span> <span class="comment">// 设置内容</span></span><br></pre></td></tr></table></figure></div>

<p>可创建任意 HTML 元素（<code>&#39;img&#39;</code>、<code>&#39;input&#39;</code>  等）</p>
<h4 id="克隆节点：-cloneNode"><a href="#克隆节点：-cloneNode" class="headerlink" title="克隆节点：.cloneNode()"></a>克隆节点：<code>.cloneNode()</code></h4><p>克隆一个已有的元素节点</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">元素.<span class="title function_">cloneNode</span>(boolean)</span><br></pre></td></tr></table></figure></div>

<p>复制一个原有的节点<br>再通过 <strong>追加节点</strong> 把复制的节点放入到指定的元素内部</p>
<table>
<thead>
<tr>
<th>参数类型</th>
<th>效果</th>
<th>示例代码</th>
</tr>
</thead>
<tbody><tr>
<td><code>true</code></td>
<td><strong>深克隆</strong>：复制节点+所有后代</td>
<td><code>box.cloneNode(true)</code></td>
</tr>
<tr>
<td><code>false</code> （默认）</td>
<td><strong>浅克隆</strong>：仅复制自身，不包含后代节点</td>
<td><code>btn.cloneNode()</code></td>
</tr>
</tbody></table>
<h4 id="追加节点-：定位内容容器"><a href="#追加节点-：定位内容容器" class="headerlink" title="追加节点 ：定位内容容器"></a>追加节点 ：定位内容容器</h4><p>创建后需手动插入 DOM 树才会显示。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>代码示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>appendChild()</strong></td>
<td>追加到父元素末尾</td>
<td><code>parent.appendChild(要插入的元素)</code></td>
</tr>
<tr>
<td><strong>insertBefore()</strong></td>
<td>插入到指定元素前</td>
<td><code>parent.insertBefore(要插入的元素，在哪个元素前面)</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取父容器</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.list&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式一：末尾追加（默认行为）</span></span><br><span class="line">container.<span class="title function_">appendChild</span>(newDiv)</span><br><span class="line"><span class="comment">// 方式二：插入到第一个元素前（实现置顶）</span></span><br><span class="line">container.<span class="title function_">insertBefore</span>(newDiv, container.<span class="property">firstElementChild</span>)</span><br></pre></td></tr></table></figure></div>

<p>在列表最前方插入新项：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>)      <span class="comment">// 获取列表容器</span></span><br><span class="line"><span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>)      <span class="comment">// 创建新元素</span></span><br><span class="line">li.<span class="property">textContent</span> = <span class="string">&#x27;我是新置顶项&#x27;</span>               <span class="comment">// 设置内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键操作：插入到第一个子元素前</span></span><br><span class="line">ul.<span class="title function_">insertBefore</span>(li, ul.<span class="property">children</span>[<span class="number">0</span>])          <span class="comment">// 成为新的第一项</span></span><br></pre></td></tr></table></figure></div>

<p><code>ul.children[0]</code> 表示  <code>ul</code>  元素下的  <strong>第一个子元素节点</strong>（跳过文本&#x2F;注释等非元素节点）</p>
<h4 id="删除节点：removeChild（）"><a href="#删除节点：removeChild（）" class="headerlink" title="删除节点：removeChild（）"></a>删除节点：<code>removeChild（）</code></h4><p>只能通过<strong>父元素</strong>删除指定子节点，<strong>永久移除</strong> DOM 元素<br>（对比  <code>display:none</code>  只是隐藏）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">父元素.<span class="title function_">removeChild</span>(要删除的子元素)</span><br></pre></td></tr></table></figure></div>

<p>若一个节点在页面中已不需要时，可以删除它<br>在 JavaScript 原生 DOM 操作中，要删除元素必须通过父元素删除</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除待办事项</span></span><br><span class="line">todoList.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">target</span>.<span class="property">classList</span>.<span class="title function_">contains</span>(<span class="string">&#x27;delete-btn&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = e.<span class="property">target</span>.<span class="title function_">closest</span>(<span class="string">&#x27;li&#x27;</span>)</span><br><span class="line">    item.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(item) <span class="comment">// 通过父元素删除</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭广告（无父元素查找）</span></span><br><span class="line">closeBtn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">parentElement</span>.<span class="title function_">remove</span>() <span class="comment">// 现代简化写法（需注意兼容性）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="定时器与同异步"><a href="#定时器与同异步" class="headerlink" title="定时器与同异步"></a>定时器与同异步</h1><h3 id="定时器-间歇函数-setInterval"><a href="#定时器-间歇函数-setInterval" class="headerlink" title="定时器-间歇函数 setInterval()"></a>定时器-间歇函数 <code>setInterval()</code></h3><p>定时器函数可让代码在指定时间间隔自动重复执行，无需手动触发，常用于需要周期性操作的场景。</p>
<p><strong>开启定时器 <code>setInterval</code></strong></p>
<p>通过 <code>setInterval</code> 函数实现周期性执行：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础语法</span></span><br><span class="line"><span class="keyword">const</span> 定时器<span class="variable constant_">ID</span> = <span class="built_in">setInterval</span>(要执行的函数, 间隔时间(毫秒))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：每秒输出日志</span></span><br><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;系统心跳检测...&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>函数参数可以是预定义函数名或匿名函数</li>
<li>1000 毫秒 &#x3D; 1 秒</li>
<li>定时器会返回唯一 ID 用于后续控制</li>
</ul>
<p><strong>关闭定时器 <code>clearInterval</code></strong></p>
<p>通过 <code>clearInterval</code> 终止正在运行的定时器：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存定时器ID</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">5</span></span><br><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`剩余次数：<span class="subst">$&#123;count--&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 满足条件时停止</span></span><br><span class="line">  <span class="keyword">if</span>(count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(timer)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器已停止&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="定时器-延迟函数-setTimeout"><a href="#定时器-延迟函数-setTimeout" class="headerlink" title="定时器-延迟函数 setTimeout()"></a>定时器-延迟函数 <code>setTimeout()</code></h3><p>1）单次定时器 setTimeout</p>
<p>让代码<strong>延迟指定时间后执行一次</strong>，常用于延迟加载等场景：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础用法（箭头函数更简洁）</span></span><br><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3秒后执行&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可中途取消（在3秒前调用）</span></span><br><span class="line"><span class="built_in">clearTimeout</span>(timer);</span><br></pre></td></tr></table></figure></div>

<p>2）循环定时器 setInterval</p>
<p><strong>重复执行代码</strong>直到被清除，适合轮询、简单动画：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> intervalId = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第<span class="subst">$&#123;++counter&#125;</span>次执行`</span>);</span><br><span class="line">  <span class="keyword">if</span>(counter === <span class="number">5</span>) <span class="built_in">clearInterval</span>(intervalId); <span class="comment">// 执行5次后停止</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>特性</th>
<th>setTimeout</th>
<th>setInterval</th>
</tr>
</thead>
<tbody><tr>
<td><strong>执行次数</strong></td>
<td>单次</td>
<td>循环</td>
</tr>
<tr>
<td><strong>清除方法</strong></td>
<td>clearTimeout(timerId)</td>
<td>clearInterval(timerId)</td>
</tr>
<tr>
<td><strong>常见用途</strong></td>
<td>延迟操作、超时处理</td>
<td>轮询、简单动画</td>
</tr>
</tbody></table>
<h2 id="JavaScript-执行机制"><a href="#JavaScript-执行机制" class="headerlink" title="JavaScript 执行机制"></a>JavaScript 执行机制</h2><p>JavaScript <strong>单线程设计</strong> 是语言的核心特征，意味着代码执行始终遵循”一次只做一件事”的原则。<br>这种设计源于浏览器环境中需要安全有序地操作 DOM：想象你要修改某个网页元素，若同时进行添加和删除操作，必然导致不可预知的混乱。单线程机制通过<strong>任务队列</strong>管理代码执行顺序，确保操作原子性。</p>
<blockquote>
<p>如同餐厅只有一个厨师，必须按订单顺序烹饪（同步执行），但聪明的厨师会在炖汤等待时（异步任务）准备其他菜品（处理其他任务）。</p>
</blockquote>
<h3 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h3><p>严格按照代码书写顺序执行，前一个任务完全结束后才会执行下一个</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始烧水&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;水烧开了&#x27;</span>) &#125;, <span class="number">10000</span>); <span class="comment">// 模拟10秒烧水</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始切菜&#x27;</span>); <span class="comment">// 必须等待烧水完成才能执行</span></span><br></pre></td></tr></table></figure></div>

<h3 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h3><p>主线程不等待耗时操作完成，将耗时操作挂起，继续执行后续代码</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始烧水&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;水烧开了&#x27;</span>) &#125;, <span class="number">10000</span>); <span class="comment">// 异步任务</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始切菜&#x27;</span>); <span class="comment">// 立即执行不等待</span></span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>对比维度</th>
<th>同步模式</th>
<th>异步模式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>执行顺序</strong></td>
<td>完全按代码顺序</td>
<td>优先执行非阻塞操作</td>
</tr>
<tr>
<td><strong>资源利用</strong></td>
<td>容易造成 CPU 闲置</td>
<td>充分利用等待时间</td>
</tr>
<tr>
<td><strong>代码复杂度</strong></td>
<td>简单直观</td>
<td>需要处理回调或 Promise</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>简单计算、即时操作</td>
<td>网络请求、定时任务、文件操作</td>
</tr>
</tbody></table>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>JavaScript 通过 <strong>事件循环（Event Loop）</strong> 实现单线程下的异步处理，其运作流程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E5%B8%B8%E7%94%A8api/file-20250324194615358.jpg"
                     
                ></p>
<ol>
<li><p><strong>执行栈管理</strong><br>所有同步任务在主线程形成执行栈顺序执行，如同厨师处理当前订单。</p>
</li>
<li><p><strong>异步任务分流</strong><br>遇到 定时器、AJAX 请求等异步操作时，浏览器内核模块接管实际工作，主线程继续执行后续代码。</p>
</li>
<li><p><strong>任务队列存储</strong><br>异步操作完成时，其回调函数被放入任务队列（相当于完成备餐的菜品放置区）。</p>
</li>
<li><p><strong>循环检查机制</strong><br>当执行栈清空时，事件循环开始检查任务队列，将队列中的任务按先进先出原则移入执行栈。</p>
</li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 经典示例揭示执行顺序</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始执行&#x27;</span>); <span class="comment">// 同步任务1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定时器回调&#x27;</span>); <span class="comment">// 异步任务</span></span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行结束&#x27;</span>); <span class="comment">// 同步任务2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出顺序：</span></span><br><span class="line"><span class="comment">   开始执行同步任务 → 同步任务执行结束 → 定时器回调</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<h1 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h1><p>浏览器本地存储如同一个<strong>微型数据库</strong>，能够将数据永久保存在用户设备中（除非手动删除），彻底解决传统网页”刷新即丢失”的问题。作为现代 Web 应用（如在线文档、Todo 清单）的基石。</p>
<p>浏览器提供了两种核心方案：</p>
<p><strong>localStorage</strong> 和 <strong>sessionStorage</strong> 同属 Web Storage 标准，均采用键值对存储且容量约 5MB。二者的核心差异在于：</p>
<ul>
<li><strong>数据时效</strong>：<code>localStorage</code> 永久有效，<code>sessionStorage</code> 随窗口关闭失效</li>
<li><strong>作用范围</strong>：<code>localStorage</code> 支持同源多窗口共享，<code>sessionStorage</code> 仅限当前窗口</li>
</ul>
<p>例如：用户主题设置应存于 localStorage 实现长期生效，而表单草稿适合用 sessionStorage 临时保存防止隐私泄露。</p>
<h2 id="localStorage-长期存储"><a href="#localStorage-长期存储" class="headerlink" title="localStorage 长期存储"></a>localStorage 长期存储</h2><p><strong>存储数据（增&#x2F;改）</strong> <code>localStorage.setItem(key, value)</code></p>
<p>当键名不存在时自动创建新条目，若键名已存在则直接覆盖原值，所有类型数据均会被自动转换为<strong>字符串</strong>存储<br>（注意数字的类型转换，对象会变成 <code>[object Object]</code>）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储用户主题配置</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;ui_theme&#x27;</span>, <span class="string">&#x27;dark-mode&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改已存在的配置（直接覆盖）</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;ui_theme&#x27;</span>, <span class="string">&#x27;light-mode&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>读取数据（查）</strong><code>localStorage.getItem(key)</code></p>
<p>若键名不存在则返回 <code>null</code>。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取存储的主题配置</span></span><br><span class="line"><span class="keyword">const</span> theme = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;ui_theme&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前主题：&#x27;</span>, theme); <span class="comment">// 输出 &quot;light-mode&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理不存在数据的情况</span></span><br><span class="line"><span class="keyword">const</span> fontSize = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;font_size&#x27;</span>) || <span class="string">&#x27;16px&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/javascript-%E5%B8%B8%E7%94%A8api/file-20250328120934948.jpg"
                     
                ></p>
<p><strong>删除数据（删）</strong> <code>localStorage.removeItem(key)</code></p>
<p>定向清除。该方法安全无副作用，对不存在的键名操作时静默跳过。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储用户信息</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;码农小明&#x27;</span>);</span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;user_level&#x27;</span>, <span class="string">&#x27;VIP3&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户等级</span></span><br><span class="line"><span class="keyword">const</span> level = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;user_level&#x27;</span>);</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">`欢迎 <span class="subst">$&#123;<span class="variable language_">localStorage</span>.getItem(<span class="string">&#x27;username&#x27;</span>)&#125;</span>，您的等级是：<span class="subst">$&#123;level&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除单个数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;user_level&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空全部存储（慎用！）</span></span><br><span class="line"><span class="comment">// localStorage.clear();</span></span><br></pre></td></tr></table></figure></div>

<h3 id="复杂数据存储方案"><a href="#复杂数据存储方案" class="headerlink" title="复杂数据存储方案"></a>复杂数据存储方案</h3><p>由于 localStorage 只能存储字符串类型数据。<br>处理对象、数组等复杂结构时需遵循 <strong>序列化 → 存储 → 反序列化</strong> 的标准流程。</p>
<p>核心方法是使用：</p>
<ul>
<li><code>JSON.stringify()</code> 存储转换（对象 → JSON 字符串）</li>
<li><code>JSON.parse()</code> 读取解析（JSON 字符串 → 对象）</li>
</ul>
<p>进行数据格式转换，确保数据结构完整性。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userProfile = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;李小明&#x27;</span>,</span><br><span class="line">  <span class="attr">level</span>: <span class="string">&#x27;VIP3&#x27;</span>,</span><br><span class="line">  <span class="attr">lastLogin</span>: <span class="string">&#x27;2023-08-20&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储转换</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;user&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(userProfile));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取解析</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;user&#x27;</span>));</span><br><span class="line"><span class="comment">// 一个序列化JSON &#123;&quot;name&quot;:&quot;李小明&quot;,&quot;level&quot;:&quot;VIP3&quot;,&quot;lastLogin&quot;:&quot;2023-08-20&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storedData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;user&#x27;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(storedData); <span class="comment">// 一个 Object 对象</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>JSON 序列化</strong> 是存储复杂数据的关键步骤，需特别注意其严格的格式要求：<br>所有属性名必须使用<strong>双引号</strong>包裹，值支持字符串、数字、布尔值、数组、对象及<code>null</code>类型。</p>
</blockquote>
<h2 id="sessionStorage-临时存储"><a href="#sessionStorage-临时存储" class="headerlink" title="sessionStorage 临时存储"></a>sessionStorage 临时存储</h2><p>适合需要短期保存的敏感信息，例如支付流程中的临时数据：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启支付流程时存储</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;paymentId&#x27;</span>, <span class="string">&#x27;P123456&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支付页面中读取</span></span><br><span class="line"><span class="keyword">const</span> paymentId = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;paymentId&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户关闭窗口后数据自动清除</span></span><br></pre></td></tr></table></figure></div>

<h1 id="正则表达"><a href="#正则表达" class="headerlink" title="正则表达"></a>正则表达</h1><p>正则表达式（Regular Expression）是用于匹配字符串中字符组合的规则模板。在 JavaScript 中，正则表达式以对象形式存在，被多种编程语言支持。核心用途包括：</p>
<ul>
<li><strong>匹配验证</strong>（如：用户名只能包含字母、数字、下划线  <code>/^[a-z0-9_-]&#123;3,16&#125;$/</code>）</li>
<li><strong>文本替换</strong>（如：过滤敏感词）</li>
<li><strong>内容提取</strong>（如：从字符串提取特定部分）</li>
</ul>
<h3 id="正则表达式语法与使用"><a href="#正则表达式语法与使用" class="headerlink" title="正则表达式语法与使用"></a>正则表达式语法与使用</h3><ol>
<li>定义规则<br><strong>语法</strong>：<code>const 变量名 = /表达式/</code><br>示例：</li>
</ol>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reg = <span class="regexp">/前端/</span>; <span class="comment">// 定义规则：匹配&quot;前端&quot;字符串</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>检测方法</li>
</ol>
<p>检测方法有 <strong><code>test()</code> 与 <code>exec()</code></strong> 两种：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>test()</code></td>
<td>判断是否有匹配文本</td>
<td>true &#x2F; false</td>
</tr>
<tr>
<td><code>exec()</code></td>
<td>提取匹配的详细信息</td>
<td>数组 &#x2F; null</td>
</tr>
</tbody></table>
<h5 id="test-：判断是否匹配"><a href="#test-：判断是否匹配" class="headerlink" title="test()：判断是否匹配"></a><code>test()</code>：判断是否匹配</h5><p><code>正则对象.test(字符串)</code> 检测字符串中是否存在符合规则的文本，返回布尔值。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;前端开发培训，web前端培训&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">test</span>(str)); <span class="comment">// true（找到匹配）</span></span><br></pre></td></tr></table></figure></div>

<h5 id="exec-：提取匹配结果"><a href="#exec-：提取匹配结果" class="headerlink" title="exec()：提取匹配结果"></a><code>exec()</code>：提取匹配结果</h5><p><code>正则对象.exec(字符串)</code> 查找并返回匹配的详细信息，未找到则返回 <code>null</code>。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">exec</span>(str));</span><br><span class="line"><span class="comment">// 输出结果示例：[&#x27;前端&#x27;, index: 5, input: &#x27;原始字符串&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure></div>

<p><strong>返回值说明</strong>：</p>
<ul>
<li>数组首元素：匹配到的文本</li>
<li><code>index</code>：匹配文本的起始位置</li>
<li><code>input</code>：原始被检测的字符串</li>
</ul>
<p><strong>示例：</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证用户名规则：3-16位字母/数字/下划线</span></span><br><span class="line"><span class="keyword">const</span> usernameReg = <span class="regexp">/^[a-z0-9_-]&#123;3,16&#125;$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(usernameReg.<span class="title function_">test</span>(<span class="string">&quot;user_123&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取第一个&quot;前端&quot;的位置</span></span><br><span class="line"><span class="keyword">const</span> result = reg.<span class="title function_">exec</span>(<span class="string">&quot;学习前端开发，做前端工程师&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">0</span>]); <span class="comment">// &quot;前端&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">index</span>); <span class="comment">// 2（匹配的起始位置）</span></span><br></pre></td></tr></table></figure></div>

<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p><strong>普通字符</strong>是正则表达式中最基础的匹配单位，它们只能匹配与自身完全一致的字符。例如字母  <code>a</code>  仅能匹配字符串中的 “a”，数字  <code>5</code>  只能匹配 “5”。这种一对一的匹配方式简单直观，但功能单一。</p>
<p><strong>元字符</strong>（Meta Character）则完全不同，它们被赋予特殊含义，能实现更强大的规则控制。例如  <code>[a-z]</code>  并非匹配具体字母，而是表示「任意一个小写字母」——就像一把万能钥匙，可以匹配 a 到 z 之间的所有字符。</p>
<p>元字符的核心优势体现在两方面：</p>
<ul>
<li><strong>简化规则</strong>：用简洁符号表达复杂逻辑（如用  <code>\d</code>  代替  <code>0-9</code>  的所有数字组合）</li>
<li><strong>灵活匹配</strong>：支持范围匹配、排除匹配、重复次数控制等高级功能</li>
</ul>
<p>这种「符号化规则」的设计，让正则表达式既能保持简洁，又能应对文本匹配中的多样化需求。</p>
<h5 id="1-边界符（定位字符）"><a href="#1-边界符（定位字符）" class="headerlink" title="1. 边界符（定位字符）"></a>1. 边界符（定位字符）</h5><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>匹配字符串<strong>开头</strong>的文本</td>
<td><code>/^abc/</code></td>
<td>以 “abc” 开头</td>
</tr>
<tr>
<td><code>$</code></td>
<td>匹配字符串<strong>结尾</strong>的文本</td>
<td><code>/xyz$/</code></td>
<td>以 “xyz” 结尾</td>
</tr>
<tr>
<td><code>^$</code></td>
<td><strong>精确匹配</strong>整个字符串</td>
<td><code>/^abc$/</code></td>
<td>只能是 “abc” 字符串</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/^a/</span>.<span class="title function_">test</span>(<span class="string">&quot;apple&quot;</span>));   <span class="comment">// true（以a开头）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/a$/</span>.<span class="title function_">test</span>(<span class="string">&quot;banana&quot;</span>));  <span class="comment">// true（以a结尾）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/^a$/</span>.<span class="title function_">test</span>(<span class="string">&quot;a&quot;</span>));      <span class="comment">// true（只能是a）</span></span><br></pre></td></tr></table></figure></div>

<h5 id="2-量词（控制重复次数）"><a href="#2-量词（控制重复次数）" class="headerlink" title="2. 量词（控制重复次数）"></a>2. 量词（控制重复次数）</h5><table>
<thead>
<tr>
<th>量词</th>
<th>含义</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>重复 <strong>0 次或多次</strong></td>
<td><code>/a*/</code></td>
<td>如 “”, “a”, “aaa”</td>
</tr>
<tr>
<td><code>+</code></td>
<td>重复 <strong>1 次或多次</strong></td>
<td><code>/a+/</code></td>
<td>如 “a”, “aaa”（至少 1 次）</td>
</tr>
<tr>
<td><code>?</code></td>
<td>重复 <strong>0 次或 1 次</strong></td>
<td><code>/a?/</code></td>
<td>如 “”, “a”</td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td>重复 <strong>n 次</strong></td>
<td><code>/a&#123;3&#125;/</code></td>
<td>如 “aaa”</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td>重复 <strong>n 次或更多次</strong></td>
<td><code>/a&#123;2,&#125;/</code></td>
<td>如 “aa”, “aaaaa”</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td>重复 <strong>n 到 m 次</strong></td>
<td><code>/a&#123;2,4&#125;/</code></td>
<td>如 “aa”, “aaaa”</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/a+/</span>.<span class="title function_">test</span>(<span class="string">&quot;apple&quot;</span>));    <span class="comment">// true（至少1个a）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/^a&#123;3&#125;$/</span>.<span class="title function_">test</span>(<span class="string">&quot;aaa&quot;</span>));  <span class="comment">// true（必须是aaa）</span></span><br></pre></td></tr></table></figure></div>

<h5 id="3-字符类（匹配字符集合）"><a href="#3-字符类（匹配字符集合）" class="headerlink" title="3. 字符类（匹配字符集合）"></a>3. 字符类（匹配字符集合）</h5><p>1）<code>[ ]</code>：匹配集合内任意字符</p>
<p><strong>基本用法</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/[abc]/</span>.<span class="title function_">test</span>(<span class="string">&quot;andy&quot;</span>));   <span class="comment">// true（包含a、b、c任意一个）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/[abc]/</span>.<span class="title function_">test</span>(<span class="string">&quot;dog&quot;</span>));    <span class="comment">// false（不包含a、b、c）</span></span><br></pre></td></tr></table></figure></div>

<p><strong>扩展功能</strong>：</p>
<ul>
<li><p>**连字符 <code>-</code>**：表示范围</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/^[a-z]$/</span>.<span class="title function_">test</span>(<span class="string">&quot;c&quot;</span>));       <span class="comment">// true（单个小写字母）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/^[A-Za-z0-9]$/</span>.<span class="title function_">test</span>(<span class="string">&quot;B&quot;</span>)); <span class="comment">// true（大小写字母或数字）</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>**取反符 <code>^</code>**：匹配不在集合中的字符（需写在 <code>[ ]</code> 内）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/[^a-z]/</span>.<span class="title function_">test</span>(<span class="string">&quot;A&quot;</span>));  <span class="comment">// true（非小写字母）</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>2）<code>.</code>：匹配<strong>除换行符外</strong>的任意单个字符</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/./</span>.<span class="title function_">test</span>(<span class="string">&quot;a&quot;</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="regexp">/./</span>.<span class="title function_">test</span>(<span class="string">&quot;\n&quot;</span>));  <span class="comment">// false（换行符不匹配）</span></span><br></pre></td></tr></table></figure></div>

<p>3）预定义类（快捷符号）：常见匹配模式的简写形式</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>等效写法</th>
<th>功能说明</th>
<th>代码示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>\d</code></td>
<td><code>[0-9]</code></td>
<td>数字字符</td>
<td><code>/\d&#123;3&#125;/.test(&quot;123&quot;)</code> → true</td>
</tr>
<tr>
<td><code>\w</code></td>
<td><code>[A-Za-z0-9_]</code></td>
<td>字母&#x2F;数字&#x2F;下划线</td>
<td><code>/\w+/.test(&quot;user_1&quot;)</code> → true</td>
</tr>
<tr>
<td><code>\s</code></td>
<td><code>[\t\r\n]</code></td>
<td>空白符（空格&#x2F;换行等）</td>
<td><code>/\s/.test(&quot; &quot;)</code> → true</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验证日期格式（YYYY-MM-DD）</span></span><br><span class="line"><span class="keyword">const</span> dateReg = <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dateReg.<span class="title function_">test</span>(<span class="string">&quot;2024-03-01&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p>4） 修饰符（模式开关）：如同电器的工作模式按钮，控制匹配规则</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>功能说明</th>
<th>代码示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>i</code></td>
<td>忽略大小写</td>
<td><code>/a/i.test(&quot;A&quot;)</code> → true</td>
</tr>
<tr>
<td><code>g</code></td>
<td>全局匹配</td>
<td><code>&quot;a1b2&quot;.match(/\d/g)</code> → [1,2]</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换所有数字为*</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;id:123, tel:456&quot;</span>.<span class="title function_">replace</span>(<span class="regexp">/\d/g</span>, <span class="string">&quot;*&quot;</span>));</span><br><span class="line"><span class="comment">// 输出：&quot;id:***, tel:***&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>综合案例：</strong></p>
<p>腾讯 QQ 号验证：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> qqReg = <span class="regexp">/^[1-9]\d&#123;4,&#125;$/</span>;  <span class="comment">// 解释：</span></span><br><span class="line">                                <span class="comment">// ^[1-9] 首位非0</span></span><br><span class="line">                                <span class="comment">// \d&#123;4,&#125; 后续至少4位数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(qqReg.<span class="title function_">test</span>(<span class="string">&quot;10086&quot;</span>)); <span class="comment">// true（有效QQ号）</span></span><br></pre></td></tr></table></figure></div>

<p>敏感词过滤：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;禁止讨论暴力和赌博内容&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> filtered = text.<span class="title function_">replace</span>(<span class="regexp">/暴力|赌博/g</span>, <span class="string">&quot;***&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filtered); <span class="comment">// &quot;禁止讨论***和***内容&quot;</span></span><br></pre></td></tr></table></figure></div>

<h1 id="日期对象"><a href="#日期对象" class="headerlink" title="日期对象"></a>日期对象</h1><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>在代码中发现了 new 关键字时，一般将这个操作称为实例化。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定时间（注意月份从0开始）</span></span><br><span class="line"><span class="keyword">const</span> specificDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2022-04-30&#x27;</span>); <span class="comment">// 实际表示2022年5月1日</span></span><br></pre></td></tr></table></figure></div>

<h3 id="时间对象方法"><a href="#时间对象方法" class="headerlink" title="时间对象方法"></a>时间对象方法</h3><p>因为日期对象返回的数据我们不能直接使用，所以需要转换为实际开发中常用的格式。<br>常用的方式如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>getFullYear()</code></td>
<td>获取年份</td>
<td>4 位数字（如 2022）</td>
</tr>
<tr>
<td><code>getMonth()</code></td>
<td>获取月份</td>
<td>0-11（0&#x3D;一月）</td>
</tr>
<tr>
<td><code>getDate()</code></td>
<td>获取日期</td>
<td>1-31</td>
</tr>
<tr>
<td><code>getDay()</code></td>
<td>获取星期</td>
<td>0-6（0&#x3D;周日）</td>
</tr>
<tr>
<td><code>getHours()</code></td>
<td>获取小时</td>
<td>0-23</td>
</tr>
<tr>
<td><code>getMinutes()</code></td>
<td>获取分钟</td>
<td>0-59</td>
</tr>
<tr>
<td><code>getSeconds()</code></td>
<td>获取秒数</td>
<td>0-59</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：<br><code>getMonth()</code> 和 <code>getDay()</code><br>为了方便配合数组操作，获取的第一个值为 0</p>
</blockquote>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建日期对象（示例时间：2023年9月15日 周五 14点05分30秒）</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2023</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">30</span>) <span class="comment">// 注意：月份参数是8表示九月</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始数据（直接使用会有问题）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getMonth</span>())       <span class="comment">// 输出：8 → 需要+1才是实际月份</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getDay</span>())         <span class="comment">// 输出：5 → 需要转换星期文字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为常用格式</span></span><br><span class="line"><span class="keyword">const</span> formatDate = &#123;</span><br><span class="line">  <span class="attr">year</span>: date.<span class="title function_">getFullYear</span>(),        <span class="comment">// 2023（直接使用）</span></span><br><span class="line">  <span class="attr">month</span>: date.<span class="title function_">getMonth</span>() + <span class="number">1</span>,      <span class="comment">// 9（月份+1修正）</span></span><br><span class="line">  <span class="attr">date</span>: date.<span class="title function_">getDate</span>(),            <span class="comment">// 15（直接使用）</span></span><br><span class="line">  <span class="attr">week</span>: [<span class="string">&#x27;日&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;二&#x27;</span>, <span class="string">&#x27;三&#x27;</span>, <span class="string">&#x27;四&#x27;</span>, <span class="string">&#x27;五&#x27;</span>, <span class="string">&#x27;六&#x27;</span>][date.<span class="title function_">getDay</span>()], <span class="comment">// 转换为中文星期</span></span><br><span class="line">  <span class="attr">hours</span>: date.<span class="title function_">getHours</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>),   <span class="comment">// 14 → &quot;14&quot;</span></span><br><span class="line">  <span class="attr">minutes</span>: date.<span class="title function_">getMinutes</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>), <span class="comment">// 5 → &quot;05&quot;</span></span><br><span class="line">  <span class="attr">seconds</span>: date.<span class="title function_">getSeconds</span>().<span class="title function_">toString</span>().<span class="title function_">padStart</span>(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>)  <span class="comment">// 30 → &quot;30&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终格式化输出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="string">`<span class="subst">$&#123;formatDate.year&#125;</span>-<span class="subst">$&#123;formatDate.month&#125;</span>-<span class="subst">$&#123;formatDate.date&#125;</span> `</span> +</span><br><span class="line">  <span class="string">`<span class="subst">$&#123;formatDate.hours&#125;</span>:<span class="subst">$&#123;formatDate.minutes&#125;</span>:<span class="subst">$&#123;formatDate.seconds&#125;</span> `</span> +</span><br><span class="line">  <span class="string">`周<span class="subst">$&#123;formatDate.week&#125;</span>`</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 输出：2023-9-15 14:05:30 周五</span></span><br></pre></td></tr></table></figure></div>

<p>还有几个本地化显示日期时间的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>示例输出</th>
</tr>
</thead>
<tbody><tr>
<td><code>toLocaleString()</code></td>
<td>显示  <strong>日期+时间</strong></td>
<td><code>&quot;2022/4/1 12:21:00&quot;</code></td>
</tr>
<tr>
<td><code>toLocaleDateString()</code></td>
<td>仅显示  <strong>日期</strong></td>
<td><code>&quot;2022/4/1&quot;</code></td>
</tr>
<tr>
<td><code>toLocaleTimeString()</code></td>
<td>仅显示  <strong>时间</strong></td>
<td><code>&quot;12:21:00&quot;</code></td>
</tr>
</tbody></table>
<p>所有方法都支持可选参数：<code>locales</code>：语言&#x2F;地区代码<br>（如  <code>&#39;en-US&#39;</code>, <code>&#39;zh-CN&#39;</code>）</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2022-04-01T12:21:00&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认格式（中文环境）</span></span><br><span class="line">date.<span class="title function_">toLocaleString</span>();       <span class="comment">// &quot;2022/4/1 12:21:00&quot;</span></span><br><span class="line">date.<span class="title function_">toLocaleDateString</span>();   <span class="comment">// &quot;2022/4/1&quot;</span></span><br><span class="line">date.<span class="title function_">toLocaleTimeString</span>();   <span class="comment">// &quot;12:21:00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定美式英语格式</span></span><br><span class="line">date.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;en-US&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;4/1/2022, 12:21:00 PM&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>如果计算倒计时效果，前面方法无法直接计算，需要借助于时间戳完成<br>时间戳是 <code>1970-01-01 00:00:00 UTC</code> 至今的<strong>毫秒数</strong></p>
<p>三种方式获取时间戳：</p>
<h4 id="new-Date-（推荐）"><a href="#new-Date-（推荐）" class="headerlink" title="+new Date() （推荐）"></a><code>+new Date()</code> （推荐）</h4><p>一行代码同时支持 <strong>当前时间戳</strong> 和 <strong>指定时间戳</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间戳（最简写法）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取未来时间戳（如2024年跨年）</span></span><br><span class="line"><span class="keyword">const</span> future = +<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2024-01-01 00:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<h4 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a><code>Date.now()</code></h4><p>仅需当前时间戳的高性能场景</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高频次获取当前时间（如游戏帧同步）</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Date</span>.<span class="title function_">now</span>()); <span class="comment">// 直接调用</span></span><br><span class="line">  count++;</span><br><span class="line">&#125;, <span class="number">16</span>);</span><br></pre></td></tr></table></figure></div>

<p>⚠️ 注意：无法获取指定时间戳</p>
<h4 id="date-getTime"><a href="#date-getTime" class="headerlink" title="date.getTime()"></a><code>date.getTime()</code></h4><p>兼容旧浏览器时的保底方案</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式获取当前时间戳</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getTime</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取历史时间戳（如2008年奥运会）</span></span><br><span class="line"><span class="keyword">const</span> oldDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2008-08-08&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(oldDate.<span class="title function_">getTime</span>());</span><br></pre></td></tr></table></figure></div>

<p>倒计时算法：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> future = +<span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2024-01-01&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="keyword">const</span> remaining = (future - now) / <span class="number">1000</span>; <span class="comment">// 剩余秒数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTime</span>(<span class="params">timer</span>) &#123;</span><br><span class="line"><span class="comment">// 转换为对应单位，数值取整场景下，Math.floor 更高效且语义明确</span></span><br><span class="line">  <span class="keyword">const</span> hour = <span class="title class_">Math</span>.<span class="title function_">floor</span>(timer / <span class="number">60</span> / <span class="number">60</span>)</span><br><span class="line">  <span class="keyword">const</span> minutes = <span class="title class_">Math</span>.<span class="title function_">floor</span>(timer / <span class="number">60</span> % <span class="number">60</span>)</span><br><span class="line">  <span class="keyword">const</span> scond = <span class="title class_">Math</span>.<span class="title function_">floor</span>(timer % <span class="number">60</span>)</span><br><span class="line"><span class="comment">// 格式化并展示</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;hour&#x27;</span>).<span class="property">innerHTML</span> = hour &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + hour : hour</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;minutes&#x27;</span>).<span class="property">innerHTML</span> = minutes &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + minutes : minutes</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;scond&#x27;</span>).<span class="property">innerHTML</span> = scond &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + scond : scond</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>渐进式框架-VUE</title>
    <url>/2024/11/24/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%89%8D%E7%AB%AF/%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%A1%86%E6%9E%B6-VUE/</url>
    <content><![CDATA[<p>Vue 是一款用于 <strong>构建用户界面</strong> 的 <strong>渐进式</strong> 的 JavaScript <strong>框架</strong><br>官方网站：<a class="link"   href="https://cn.vuejs.org/" >https://cn.vuejs.org<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<ul>
<li><strong>构建用户界面:</strong> 基于数据就能渲染出用户看到的界面</li>
<li><strong>渐进式:</strong> 循序渐进. 不需要把所有的组件、语法全部学习完毕才可以使用 Vue. 可以需要什么用什么.</li>
<li><strong>框架:</strong> 是一套完整的项目解决方案，用于快速构建项目.</li>
</ul>
<p>VUE 只需要具备基础的 <a href="/2023/09/17/猎识印记-领域/软件工程/前端/网页之骨架-HTML/">HTML</a> 和 <a href="/2023/11/06/猎识印记-领域/软件工程/前端/网页之大脑-Javascript/">JavaScript</a> 知识即可快速上手!</p>
<blockquote>
<p>总的来说, VUE 主要的工作是通过调用预定义的 JS 组件, 快速将数据渲染到页面上.<br>并且确保当数据变化时, 网页能够自动更新.</p>
</blockquote>
<h1 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h1><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1). 准备工作"></a>1). 准备工作</h4><ul>
<li>准备一个 HTML 文件, 在其<code>body</code>中引入 VUE 模块. 引入模块化的 js 时, 需要设置 <code>type=&quot;module&quot;</code> , 浏览器才能正确识别其为模块化的 js.</li>
</ul>
<ul>
<li>创建 VUE 程序的应用实例, 控制试图元素</li>
<li>准备元素(div), 交给 VUE 控制</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Vue 将在这里控制这个元素 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="comment">// 引入 VUE 模块</span></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">	<span class="comment">// 创建 VUE 应用实例</span></span></span><br><span class="line"><span class="language-javascript">	<span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	&#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>); <span class="comment">// 将 VUE 应用实例挂载到 id 为 &#x27;app&#x27; 的元素上</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>JavaScript</p>

    </div>
    <div class="notel-content">
      <p>模块化 JavaScript 是一种代码组织方式, 它允许我们将代码分割成独立的模块, 每个模块都有自己的功能和作用域.<br>这种方式有助于代码的维护和复用.</p>

    </div>
  </div>

<p>这三步准备工作, 是使用 Vue 的必要操作, 是固定步骤.</p>
<h4 id="2-数据驱动视图"><a href="#2-数据驱动视图" class="headerlink" title="2). 数据驱动视图"></a>2). 数据驱动视图</h4><ul>
<li>准备数据.</li>
<li>通过插值表达式渲染页面. 插值表达式的写法: <code>&#123;&#123;...&#125;&#125;</code></li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">	&lt;!-- 使用插值表达式将 message 的值渲染到页面上 --&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="title function_">createApp</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="title function_">data</span>(<span class="params"></span>)&#123; <span class="comment">// data() 是VUE内置的函数</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			<span class="keyword">return</span>&#123; <span class="comment">// 将其中的对象返回</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			<span class="attr">message</span>: <span class="string">&#x27;Hello Vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>插值表达式</p>

    </div>
    <div class="notel-content">
      <p>插值表达式是一种模板语法, 常见于许多现代前端框架和库中.<br>插值表达式用于将 JavaScript 表达式的值嵌入到 HTML 模板中, 这种语法允许你将动态数据渲染到静态的 HTML 结构中.</p>

    </div>
  </div>

<p>入门案例完整代码:</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-快速入门<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">message</span>: <span class="string">&#x27;Hello Vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h1 id="核心指令"><a href="#核心指令" class="headerlink" title="核心指令"></a>核心指令</h1><p>VUE 的指令是作用在 HTML 标签中带有 v- 前缀的特殊属性.<br>例如在 <code>&lt;p&gt;&lt;/p&gt;</code> 标签中使用 VUE 的指令:</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-xxx</span>=<span class="string">&quot;....&quot;</span>&gt;</span>.....<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>指令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>v-for</code></td>
<td>列表渲染，遍历容器的元素或者对象的属性</td>
</tr>
<tr>
<td><code>v-bind</code></td>
<td>为 HTML 标签绑定属性值，如设置 href , css 样式等</td>
</tr>
<tr>
<td><code>v-if/v-else-if/v-else</code></td>
<td>条件性的渲染某元素，判定为 true 时渲染,否则不渲染</td>
</tr>
<tr>
<td>v-show&#96;</td>
<td>根据条件展示某元素，区别在于切换的是 display 属性的值</td>
</tr>
<tr>
<td><code>v-model</code></td>
<td>在表单元素上创建双向数据绑定</td>
</tr>
<tr>
<td><code>v-on</code></td>
<td>为 HTML 标签绑定事件</td>
</tr>
</tbody></table>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><p>列表渲染, 遍历容器的元素或者对象的属性.</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>参数：</strong></p>
<ul>
<li>items 为遍历的数组</li>
<li>item 为遍历出来的元素</li>
<li>index 为索引&#x2F;下标，从 0 开始 ；可以省略，省略 index 语法： <code>v-for = &quot;item in items&quot;</code></li>
</ul>
<p><strong>key：</strong></p>
<ul>
<li>作用：给元素添加的唯一标识，便于 vue 进行列表项的正确排序复用，提升渲染性能</li>
<li>推荐使用 id 作为 key（唯一），不推荐使用 index 作为 key（会变化，不对应）</li>
</ul>
<p><strong>注意：遍历的数组，必须在 data 中定义； 要想让哪个标签循环展示多次，就在哪个标签上使用 v-for 指令。</strong></p>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><p>动态为 HTML 标签绑定属性值，如设置 href，src，style 样式等。</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-bind:属性名=&quot;属性值&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;item.image&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30px&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简化写法 :属性名=&quot;属性值&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;item.image&quot;</span> <span class="attr">width</span>=<span class="string">&quot;30px&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>由于之前的插值表达式无法在标签内使用, 因此想在标签内达到插值表达式的效果, 只能只用这个指令.</p>
<p>另外, v-bind 所绑定的数据同插值表达式, 必须在 data 中定义&#x2F;或基于 data 中定义的数据而来.</p>
<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><p>基于条件判断, 来控制创建或移除元素节点(条件渲染). 要么渲染这个元素，要么删除这个元素.</p>
<p>适用于 <strong>不频繁切换的场景</strong>.</p>
<p>类似于编程语言的流程控制语法, 同理的, 可以配合 <code>v-else-if</code> &#x2F; <code>v-else</code> 进行链式调用条件判断.</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- v-if=&quot;表达式&quot;，表达式值为 true-显示；false-隐藏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;emp.job === &#x27;1&#x27;&quot;</span>&gt;</span>班主任<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;emp.job === &#x27;2&#x27;&quot;</span>&gt;</span>讲师<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>其他<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><p>类似于 <code>v-if</code> 这两类指令，都是用来控制元素的显示与隐藏的.</p>
<p>区别于 <code>v-if</code> , 是基于 CSS 样式 <code>display</code> 来控制显示与隐藏. 无论条件是否成立, 都会渲染. 然后才会判断其显示还是隐藏.</p>
<p>适用于 <strong>频繁切换显示隐藏的场景</strong>.</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-show=&quot;表达式&quot;，表达式值为 true-显示；false-隐藏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;emp.job === &#x27;1&#x27;&quot;</span>&gt;</span>班主任<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;emp.job === &#x27;2&#x27;&quot;</span>&gt;</span>讲师<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;emp.job === &#x27;3&#x27;&quot;</span>&gt;</span>学工主管<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;emp.job === &#x27;4&#x27;&quot;</span>&gt;</span>教研主管<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-show</span>=<span class="string">&quot;emp.job === &#x27;5&#x27;&quot;</span>&gt;</span>咨询师<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><p>在表单元素上使用，<strong>双向数据绑定</strong>。可以方便的 <strong>获取</strong> 或 <strong>设置</strong> 表单项数据</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-model=&quot;变量名&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;serachForm.name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>双向数据绑定</p>

    </div>
    <div class="notel-content">
      <p>是指 Vue 中的数据变, 会影响视图中的数据展示 . 视图中的输入的数据变化, 也会影响 Vue 的数据模型 .</p>

    </div>
  </div>

<blockquote>
<p><strong>注意：v-model 中绑定的变量, 必须在 data 中定义.</strong></p>
</blockquote>
<ul>
<li>为员工列表案例的搜索栏的表单项，绑定数据：</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 搜索表单区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;search-form&quot;</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;姓名&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;searchEmp.name&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;searchEmp.gender&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;job&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;searchEmp.job&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>职位<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">			...</span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>&gt;</span>咨询师<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span>清空<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 定义 v-model 绑定的变量</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">searchEmp</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">gender</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">job</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">empList</span>: [</span></span><br><span class="line"><span class="language-javascript">				表单数据;</span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">            ]</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#container&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>为 html 标签绑定事件 (添加事件监听)</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- v-on:事件名=&quot;方法名&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我一下试试&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handle&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简写为 @事件名=&quot;…&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我一下试试&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handle&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>定义的 handle 函数，同之前提到的指令, 也需要在 Vue 应用实例创建的时候创建出来，在 methods 定义, 其与 data 平级.</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 表单区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;search-form&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;search&quot;</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;clear&quot;</span>&gt;</span>清空<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          ...;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 此处声明函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">search</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">searchEmp</span>)</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">searchEmp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">gender</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">job</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#container&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>注意： methods 函数中的 this 指向 Vue 实例，可以通过 this 获取到 data 中定义的数据。</strong></p>
<h1 id="完整案例"><a href="#完整案例" class="headerlink" title="完整案例"></a>完整案例</h1><div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Tlias智能学习辅助系统<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 顶栏样式 */</span></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.header</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">justify-content</span>: space-between;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#c2c0c0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">5px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>);</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 加大加粗标题 */</span></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.header</span> <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">24px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 文本链接样式 */</span></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.header</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-decoration</span>: none;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: <span class="number">#333</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 搜索表单区域 */</span></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.search-form</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#f9f9f9</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 表单控件样式 */</span></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.search-form</span> <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;text&quot;</span>]</span>, <span class="selector-class">.search-form</span> <span class="selector-tag">select</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">26%</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 按钮样式 */</span></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.search-form</span> <span class="selector-tag">button</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#007bff</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: none;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 清空按钮样式 */</span></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.search-form</span> <span class="selector-tag">button</span><span class="selector-class">.clear</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#6c757d</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.table</span> &#123;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">min-width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">         <span class="attribute">border-collapse</span>: collapse;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 设置表格单元格边框 */</span></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.table</span> <span class="selector-tag">td</span>, <span class="selector-class">.table</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">8px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.avatar</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">object-fit</span>: cover;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 页脚版权区域 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#c2c0c0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.footer</span> <span class="selector-class">.company-name</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">1.1em</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.footer</span> <span class="selector-class">.copyright</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">font-size</span>: <span class="number">0.9em</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#container</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">80%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">margin</span>: <span class="number">0</span> auto;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 顶栏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Tlias智能学习辅助系统<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 搜索表单区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;search-form&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;姓名&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;searchEmp.name&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;searchEmp.gender&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;job&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;searchEmp.job&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>职位<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>班主任<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>讲师<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>学工主管<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>教研主管<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>&gt;</span>咨询师<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;search&quot;</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;clear&quot;</span>&gt;</span>清空<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table table-striped table-bordered&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>头像<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>职位<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>入职日期<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>最后操作时间<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;(emp, index) in empList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; emp.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; emp.gender === 1 ? &#x27;男&#x27; : &#x27;女&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;emp.image&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&#123;&#123; emp.name &#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;emp.job === &#x27;1&#x27;&quot;</span>&gt;</span>班主任<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;emp.job === &#x27;2&#x27;&quot;</span>&gt;</span>讲师<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;emp.job === &#x27;3&#x27;&quot;</span>&gt;</span>学工主管<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;emp.job === &#x27;4&#x27;&quot;</span>&gt;</span>教研主管<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else-if</span>=<span class="string">&quot;emp.job === &#x27;5&#x27;&quot;</span>&gt;</span>咨询师<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; emp.entrydate &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; emp.updatetime &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">td</span> <span class="attr">class</span>=<span class="string">&quot;btn-group&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;edit&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;delete&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 页脚版权区域 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;company-name&quot;</span>&gt;</span>江苏传智播客教育科技股份有限公司<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;copyright&quot;</span>&gt;</span>版权所有 Copyright 2006-2024 All Rights Reserved<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">createApp</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">searchEmp</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">gender</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">job</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">empList</span>: [</span></span><br><span class="line"><span class="language-javascript">              &#123; <span class="string">&quot;id&quot;</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;谢逊&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;image&quot;</span>: <span class="string">&quot;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/4.jpg&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;gender&quot;</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;job&quot;</span>: <span class="string">&quot;1&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;entrydate&quot;</span>: <span class="string">&quot;2023-06-09&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;updatetime&quot;</span>: <span class="string">&quot;2024-07-30T14:59:38&quot;</span></span></span><br><span class="line"><span class="language-javascript">              &#125;,</span></span><br><span class="line"><span class="language-javascript">              &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;id&quot;</span>: <span class="number">2</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;韦一笑&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;image&quot;</span>: <span class="string">&quot;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/1.jpg&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;gender&quot;</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;job&quot;</span>: <span class="string">&quot;1&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;entrydate&quot;</span>: <span class="string">&quot;2020-05-09&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;updatetime&quot;</span>: <span class="string">&quot;2023-07-01T00:00:00&quot;</span></span></span><br><span class="line"><span class="language-javascript">              &#125;,</span></span><br><span class="line"><span class="language-javascript">              &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;id&quot;</span>: <span class="number">3</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;黛绮丝&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;image&quot;</span>: <span class="string">&quot;https://web-framework.oss-cn-hangzhou.aliyuncs.com/2023/2.jpg&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;gender&quot;</span>: <span class="number">2</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;job&quot;</span>: <span class="string">&quot;2&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;entrydate&quot;</span>: <span class="string">&quot;2021-06-01&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="string">&quot;updatetime&quot;</span>: <span class="string">&quot;2023-07-01T00:00:00&quot;</span></span></span><br><span class="line"><span class="language-javascript">              &#125;</span></span><br><span class="line"><span class="language-javascript">            ]</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">search</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">searchEmp</span>)</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">searchEmp</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">gender</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">              <span class="attr">job</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#container&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h1 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h1><p>vue 的生命周期 是 vue 对象从创建到销毁的过程.<br>其完整的生命周期如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%A1%86%E6%9E%B6-vue/file-20241128122923519.jpg"
                     
                ></p>
<p>vue 的生命周期包含 8 个阶段., 每触发一个生命周期事件, 会自动执行一个生命周期方法, 这些生命周期方法也被称为 <strong>钩子方法</strong>.</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>阶段周期</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>创建前</td>
</tr>
<tr>
<td>created</td>
<td>创建后</td>
</tr>
<tr>
<td>beforeMount</td>
<td>挂载前</td>
</tr>
<tr>
<td>mounted</td>
<td>挂载完成</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>更新前</td>
</tr>
<tr>
<td>updated</td>
<td>更新后</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>销毁前</td>
</tr>
<tr>
<td>destroyed</td>
<td>销毁后</td>
</tr>
</tbody></table>
<p>其中我们需要重点关注的是 mounted，其他的我们了解即可。</p>
<h4 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h4><p>挂载完成，Vue 初始化成功，HTML 页面渲染成功。<strong>以后我们一般用于页面初始化自动的 ajax 请求后台数据</strong></p>
<p>那我们要想在页面加载完毕，就查询出员工列表，就可以在 mounted 钩子函数中，发送异步请求查询员工数据了。</p>
<p>具体代码如下：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">search</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">//基于axios发送异步请求，请求https://web-server.itheima.net/emps/list，根据条件查询员工列表</span></span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">`https://web-server.itheima.net/emps/list?name=<span class="subst">$&#123;<span class="variable language_">this</span>.searchForm.name&#125;</span>&amp;gender=<span class="subst">$&#123;<span class="variable language_">this</span>.searchForm.gender&#125;</span>&amp;job=<span class="subst">$&#123;<span class="variable language_">this</span>.searchForm.job&#125;</span>`</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">empList</span> = result.<span class="property">data</span>.<span class="property">data</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">searchForm</span>= &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">gender</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        <span class="attr">job</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">search</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">search</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">mount</span>(<span class="string">&#x27;#container&#x27;</span>)</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>web前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>网页之衣裳-CSS</title>
    <url>/2023/09/17/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%89%8D%E7%AB%AF/%E7%BD%91%E9%A1%B5%E4%B9%8B%E8%A1%A3%E8%A3%B3-CSS/</url>
    <content><![CDATA[<h1 id="CSS-核心概念"><a href="#CSS-核心概念" class="headerlink" title="CSS 核心概念"></a>CSS 核心概念</h1><p>层叠样式表(Casading Style Sheets) 控制网页外观，用于美化 HTML 内容。核心功能：<strong>定义元素的颜色、大小、布局等视觉样式</strong>。</p>
<p>CSS 的基本结构由选择器、属性和属性值组成：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">  属性: 值;  <span class="comment">/* 声明块 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>选择器</strong>：定位要修饰的 HTML 元素（如标签名&#x2F;类名&#x2F;#ID）</li>
<li><strong>属性</strong>：要修改的样式类型（如  <code>color</code>&#x2F;<code>font-size</code>）</li>
<li><strong>值</strong>：样式的具体设定（如  <code>red</code>&#x2F;<code>16px</code>）</li>
</ul>
<p>█ 特性：每个样式由<strong>键值对</strong>构成（属性:值），多个样式用分号隔开</p>
<h3 id="三种引入方式"><a href="#三种引入方式" class="headerlink" title="三种引入方式"></a>三种引入方式</h3><h3 id="1-内部样式表"><a href="#1-内部样式表" class="headerlink" title="1. 内部样式表"></a>1. 内部样式表</h3><p>在 HTML 文件 <code>&lt;head&gt;</code> 内通过 <code>&lt;style&gt;</code> 标签编写</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123; <span class="attribute">color</span>: blue; &#125;  <span class="comment">/* 只作用于当前页面 */</span></span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>▌ 适用场景：单个页面简单调试</p>
<h3 id="2-外部样式表（最常用）"><a href="#2-外部样式表（最常用）" class="headerlink" title="2. 外部样式表（最常用）"></a>2. 外部样式表（最常用）</h3><p>CSS 独立存为 <code>.css</code> 文件，通过 <code>&lt;link&gt;</code> 引入</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- rel和href必填 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;样式文件路径.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>▌ 优势：多页面共享样式，便于维护</p>
<h3 id="3-行内样式（慎用）"><a href="#3-行内样式（慎用）" class="headerlink" title="3. 行内样式（慎用）"></a>3. 行内样式（慎用）</h3><p>直接在 HTML 标签的 <code>style</code> 属性写样式</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red; margin:10px&quot;</span>&gt;</span>文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>▌ 使用场景：配合 JS 动态修改样式<br>▌ 缺陷：样式与结构混杂，难以批量修改</p>
<h1 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h1><p>通过选择器定位网页元素，为指定元素添加样式规则。</p>
<h2 id="基础选择器（必会四件套）"><a href="#基础选择器（必会四件套）" class="headerlink" title="基础选择器（必会四件套）"></a>基础选择器（必会四件套）</h2><h3 id="通配符选择器-全员匹配"><a href="#通配符选择器-全员匹配" class="headerlink" title="通配符选择器 - 全员匹配"></a>通配符选择器 - 全员匹配</h3><ul>
<li><strong>符号</strong>：<code>*</code></li>
<li><strong>作用</strong>：选中页面所有元素（慎用，性能消耗大）</li>
<li><strong>典型场景</strong>：基础样式重置</li>
</ul>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;     <span class="comment">/* 清除默认外边距 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;    <span class="comment">/* 清除默认内边距 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="标签选择器-批量操作"><a href="#标签选择器-批量操作" class="headerlink" title="标签选择器 - 批量操作"></a>标签选择器 - 批量操作</h3><ul>
<li><strong>写法</strong>：直接使用标签名（如<code>p</code>&#x2F;<code>div</code>）</li>
<li><strong>特点</strong>：影响所有同类标签</li>
<li><strong>适用场景</strong>：统一基础样式</li>
</ul>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">text-indent</span>: <span class="number">2em</span>;  <span class="comment">/* 段落首行缩进 */</span></span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.6</span>;  <span class="comment">/* 文字行间距 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="类选择器-精准控制（最常用）"><a href="#类选择器-精准控制（最常用）" class="headerlink" title="类选择器 - 精准控制（最常用）"></a>类选择器 - 精准控制（最常用）</h3><ul>
<li><strong>符号</strong>：<code>.</code>开头（如<code>.header</code>）</li>
<li><strong>使用流程</strong>：<ol>
<li>定义样式</li>
<li>添加类名</li>
</ol>
</li>
<li><strong>优势</strong>：可重复使用、支持多类名</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="comment">/* 定义类选择器 */</span></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.color</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.size</span>&#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用类选择器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 一个类能给多个标签使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;color&quot;</span>&gt;</span>这是div标签1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用空格隔开多个类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;color size&quot;</span>&gt;</span>这是div标签2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="ID-选择器-唯一标识"><a href="#ID-选择器-唯一标识" class="headerlink" title="ID 选择器 - 唯一标识"></a>ID 选择器 - 唯一标识</h3><ul>
<li><strong>符号</strong>：<code>#</code>开头（如<code>#main-nav</code>）</li>
<li><strong>重要规则</strong>：<ul>
<li>全页面唯一，不能重复</li>
<li>主要配合 JavaScript 操作</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="comment">/* 定义id选择器 */</span></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#red</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>:red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用id选择器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span>&gt;</span>这是 div 标签<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h2><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><ul>
<li><strong>符号</strong>：空格（如<code>ul li</code>）</li>
<li><strong>作用</strong>：选中嵌套结构中所有符合的子元素</li>
</ul>
<h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><ul>
<li><strong>符号</strong>：<code>&gt;</code>（如<code>ul &gt; li</code>）</li>
<li><strong>特点</strong>：只选择直接（最近的）的子元素</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 后代 vs 子代选择器对比示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 后代选择器：选中.nav下所有层级的a标签 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.nav</span> <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: red;  <span class="comment">/* 所有导航链接变红 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 子代选择器：只选中.nav的直接子级a标签 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.nav</span> &gt; <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">20px</span>;  <span class="comment">/* 仅一级导航放大 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 导航结构 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>一级导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span>          <span class="comment">&lt;!-- 同时应用两个样式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sub-nav&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>二级导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span>       <span class="comment">&lt;!-- 仅文字变红 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>另一个一级导航<span class="tag">&lt;/<span class="name">a</span>&gt;</span>    <span class="comment">&lt;!-- 同时应用两个样式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><ul>
<li><strong>符号</strong>：逗号（如<code>h1, h2, .title</code>）</li>
<li><strong>作用</strong>：同时给多个元素相同样式</li>
</ul>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 统一标题样式 */</span></span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-class">.section-title</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;微软雅黑&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><ul>
<li><strong>符号</strong>：<code>:</code>开头</li>
<li><strong>典型应用</strong>：<ul>
<li><code>:hover</code> 鼠标悬停</li>
<li><code>:active</code> 点击瞬间</li>
<li><code>:nth-child(n)</code> 选择第 n 个元素</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 鼠标悬停时变色 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background</span>: lightblue;  <span class="comment">/* 悬停背景变浅蓝 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 点击按钮时改变文字颜色 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.btn</span><span class="selector-pseudo">:active</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: white;  <span class="comment">/* 按住按钮时文字变白 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 选中第二个列表项 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-weight</span>: bold;  <span class="comment">/* 第二个列表项加粗 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;padding:20px;border:1px solid&quot;</span>&gt;</span></span><br><span class="line">  鼠标移上来试试</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击效果示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background:green;padding:10px&quot;</span>&gt;</span></span><br><span class="line">  点击按住查看效果</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定位子元素示例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>普通列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>我是加粗的第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  <span class="comment">&lt;!-- 自动加粗 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>普通列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h1 id="CSS-三大核心特性"><a href="#CSS-三大核心特性" class="headerlink" title="CSS 三大核心特性"></a>CSS 三大核心特性</h1><p>CSS 能化简代码&#x2F;定位问题,并解决问题</p>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p>子元素自动继承父元素的<strong>文字相关属性</strong></p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-family</span>: <span class="string">&#x27;微软雅黑&#x27;</span>;  <span class="comment">/* 所有子元素默认继承该字体 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: <span class="number">#333</span>;            <span class="comment">/* 默认文字颜色 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这段文字自动使用body的字体和颜色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>⚠️ <strong>注意</strong>：盒模型属性（width&#x2F;margin 等）不可继承，需手动设置</p>
<h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>▌ <strong>核心原则</strong>：</p>
<ol>
<li><strong>相同属性</strong> → 后写的覆盖先写的</li>
<li><strong>不同属性</strong> → 自动合并效果</li>
</ol>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: red;    <span class="comment">/* 将被下面的同属性覆盖 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">10px</span>;  <span class="comment">/* 保留生效 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.special</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: blue;   <span class="comment">/* 最终文字颜色 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">20px</span>; <span class="comment">/* 新增属性 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box special&quot;</span>&gt;</span>同时应用两个类的样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>当多个样式冲突时，按以下规则生效：</p>
<ol>
<li><strong>ID 选择器</strong> &gt; <strong>类选择器</strong> &gt; <strong>标签选择器</strong></li>
<li><code>!important</code> 强制最高优先级（慎用）</li>
<li><strong>更具体的选择器</strong> &gt; 简单选择器</li>
</ol>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 基础选择器优先级对比 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123; <span class="attribute">color</span>: black; &#125;            <span class="comment">/* 标签选择器 - 权重1 → 未生效 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.text</span> &#123; <span class="attribute">color</span>: blue; &#125;           <span class="comment">/* 类选择器 - 权重10 → 未生效 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#target</span> &#123; <span class="attribute">color</span>: green; &#125;        <span class="comment">/* ID选择器 - 权重100 → 生效 */</span></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 复合选择器权重累加 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> <span class="selector-class">.content</span> &#123; <span class="attribute">color</span>: purple; &#125; <span class="comment">/* 10+10=20 → 未生效 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#main</span> <span class="selector-class">.text</span> &#123; <span class="attribute">color</span>: orange; &#125;   <span class="comment">/* 100+10=110 → 生效 */</span></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* !important暴力模式 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.important-text</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: pink <span class="meta">!important</span>; <span class="comment">/* 无视所有规则 */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 测试案例1：ID vs 类 vs 标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>这个文字显示绿色<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ID选择器胜出 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试案例2：复合选择器权重计算 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;content text&quot;</span>&gt;</span>这个文字显示橙色）<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- #main .text 权重110  .box .content 权重20 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 测试案例3：!important 终极对决 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;special&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">class</span>=<span class="string">&quot;important-text&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span> <span class="comment">&lt;!-- 行内样式权重1000 → 被!important覆盖 --&gt;</span></span><br><span class="line">        这个文字显示粉色</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- !important最高优先级 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="标签的显示模式"><a href="#标签的显示模式" class="headerlink" title="标签的显示模式"></a>标签的显示模式</h3><p>布局页面的时候, 根据需求选择合适的标签显示模式摆放内容.</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>常见标签</th>
<th>支持设置的样式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>块元素</strong></td>
<td>独占一行，宽度撑满父容器</td>
<td><code>div</code>&#x2F;<code>h1</code>&#x2F;<code>p</code>&#x2F;<code>ul</code></td>
<td>宽高、边距全生效</td>
</tr>
<tr>
<td><strong>行内元素</strong></td>
<td>同行显示，宽高由内容决定</td>
<td><code>span</code>&#x2F;<code>a</code>&#x2F;<code>em</code></td>
<td>宽高不生效</td>
</tr>
<tr>
<td><strong>行内块</strong></td>
<td>同行显示且可设宽高</td>
<td><code>img</code>&#x2F;<code>input</code>&#x2F;<code>button</code></td>
<td>宽高、边距全生效</td>
</tr>
</tbody></table>
<p>使用属性 <code>display</code> 可以转换模式。</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 行内转块级 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span><span class="selector-class">.nav-link</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: block;     <span class="comment">/* 让链接独占一行 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">200px</span>;      <span class="comment">/* 此时可设置宽度 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 块级转行内块 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span><span class="selector-class">.gallery</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">display</span>: inline-block;  <span class="comment">/* 并排显示 */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">10px</span>;           <span class="comment">/* 边距生效 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h1 id="前端尺寸"><a href="#前端尺寸" class="headerlink" title="前端尺寸"></a>前端尺寸</h1><p>全局用 rem，精准用 px，流动用百分比，视口适配靠 vw&#x2F;vh</p>
<h4 id="REM：响应式布局核心"><a href="#REM：响应式布局核心" class="headerlink" title="REM：响应式布局核心"></a><strong>REM：响应式布局核心</strong></h4><p>所有与布局相关的尺寸（如容器宽高、内外边距）优先使用 <code>rem</code>。它直接挂钩于 <code>&lt;html&gt;</code> 标签的 <code>font-size</code>（默认 16px），只需通过媒体查询或 JavaScript 动态调整根字体（比如设为视口宽度的 1&#x2F;10），整个页面元素会按比例缩放，实现“一次调整，全局响应”。<br>例如，设置根字体为 <code>10px</code> 时，<code>2rem</code> 即为 <code>20px</code>，避免反复计算。</p>
<h4 id="PX：精确控制"><a href="#PX：精确控制" class="headerlink" title="PX：精确控制"></a>PX：精确控制</h4><p>固定尺寸场景（图标大小、边框粗细）坚持用 <code>px</code>。比如一个「删除」图标设为 <code>24x24px</code>，无论屏幕如何缩放都保持清晰；边框 <code>1px</code> 能精准呈现细线效果。<br>这类需要视觉绝对稳定的元素，用 <code>px</code> 最可靠。</p>
<h4 id="百分比：流动布局的助手"><a href="#百分比：流动布局的助手" class="headerlink" title="百分比：流动布局的助手"></a><strong>百分比：流动布局的助手</strong></h4><p>希望元素随父级容器变化时（如侧边栏占父容器 20%），使用百分比单位 <code>%</code>。它擅长实现两栏布局、图片容器等比缩放，但需注意：父元素必须有明确尺寸，且 <code>border</code>、<code>margin</code> 等属性不支持百分比，需搭配 <code>px</code> 或 <code>rem</code> 使用。</p>
<h3 id="VW-VH：视口自适应的利器"><a href="#VW-VH：视口自适应的利器" class="headerlink" title="VW&#x2F;VH：视口自适应的利器"></a><strong>VW&#x2F;VH：视口自适应的利器</strong></h3><p>全屏轮播图的高度设为 <code>50vh</code>（视口高度一半），或标题字体用 <code>3vw</code>（随视口宽度缩放），这类与视口强相关的场景适合 <code>vw/vh</code>。<br>但移动端慎用 <code>vh</code>，因浏览器地址栏可能影响计算，可用 <code>window.innerHeight</code> 的 JS 方案替代。</p>
<h3 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h3><p><strong>REM 定全局，PX 保精准，百分比做流动，视口单位抓自适应，其他单位按需取。</strong> 初期掌握这四点，能解决 90% 的尺寸布局问题。</p>
<h1 id="CSS-属性"><a href="#CSS-属性" class="headerlink" title="CSS 属性"></a>CSS 属性</h1><h2 id="前端尺寸-1"><a href="#前端尺寸-1" class="headerlink" title="前端尺寸"></a>前端尺寸</h2><h4 id="像素-px"><a href="#像素-px" class="headerlink" title="像素 px"></a>像素 <code>px</code></h4><p>像素是屏幕上的一个点, 是计算机显示系统的基本单位. 在前端开发中, px 代表的是相对于<strong>显示器屏幕分辨率</strong>的绝对单位.</p>
<p>像素值不会随着视口大小或缩放级别变化, 保持固定不变.<br>适用于通常用于需要精确布局的场合, 如图形设计, 图标大小等.</p>
<h4 id="相对长度单位-em"><a href="#相对长度单位-em" class="headerlink" title="相对长度单位 em"></a>相对长度单位 <code>em</code></h4><p>em 是一个相对长度单位, 其大小相对于<strong>当前元素的字体</strong>尺寸. 如果当前元素没有设置字体大小, 则相对于父元素的字体大小.</p>
<p>em 单位的尺寸会根据其参考元素的字体大小变化而变化, 具有一定的灵活性.<br>适合需要根据字体大小动态调整布局的场合，如响应式设计中的文本缩放.</p>
<h4 id="根元素相对长度-rem"><a href="#根元素相对长度-rem" class="headerlink" title="根元素相对长度 rem"></a>根元素相对长度 <code>rem</code></h4><p>rem 是 CSS3 新增的单位, 与 em 类似, 但它是相对于<strong>根元素</strong> (html) 的字体大小来计算的.</p>
<p>rem 单位使得整个页面的尺寸调整更加一致和方便, 但不支持的浏览器需要特定的回退策略.<br>在需要整体控制字体大小和布局比例时非常有用, 特别是当想要统一调整整个页面的尺寸时.</p>
<blockquote>
<p>回退策略:<br>提供备选的尺寸单位(通常是 px), 使得页面布局和样式能够降级到一个可接受的状态.</p>
</blockquote>
<h4 id="视口单位-vw-vh"><a href="#视口单位-vw-vh" class="headerlink" title="视口单位 vw&#x2F;vh"></a>视口单位 <code>vw</code>&#x2F;<code>vh</code></h4><p>vw 和 vh 是基于视口的单位，分别代表视口宽度和高度的百分比. 1vw 等于视口<strong>宽度</strong>的 1%, 1vh 等于视口<strong>高度</strong>的 1%.</p>
<p>vw 和 vh 单位使得元素能够随着视口大小的变化而伸缩, 非常适合创建全屏或者响应式布局.<br>适用于需要根据视口大小动态调整元素尺寸的响应式设计.</p>
<h4 id="视口最小-最大单位-vmin-vmax"><a href="#视口最小-最大单位-vmin-vmax" class="headerlink" title="视口最小&#x2F;最大单位 vmin&#x2F;vmax"></a>视口最小&#x2F;最大单位 <code>vmin</code>&#x2F;<code>vmax</code></h4><p>vmin 是 vw 和 vh 中较小的一个, vmax 是较大的一个.<br>这两个单位用于在不同方向上保持元素尺寸的一致性.</p>
<p>vmin&#x2F;vmax 单位有助于在横屏和竖屏模式下保持元素的相对大小一致.<br>在移动设备上, 当屏幕方向改变时, 使用 vmin&#x2F;vmax 可以确保元素的尺寸适应不同方向.</p>
<h4 id="百分比"><a href="#百分比" class="headerlink" title="百分比 %"></a>百分比 <code>%</code></h4><p>百分比单位表示相对于父元素的尺寸.例如, 宽度设置为 50%的元素将会占据其父元素宽度的一半.</p>
<p>百分比单位提供了一种简单的方式来创建相对于父元素尺寸的布局.<br>适用于需要根据父元素尺寸来确定自身尺寸的布局.</p>
<blockquote>
<p>border 不支持的百分比设置.</p>
</blockquote>
<h2 id="文字属性"><a href="#文字属性" class="headerlink" title="文字属性"></a>文字属性</h2><h3 id="文字颜色-color"><a href="#文字颜色-color" class="headerlink" title="文字颜色 color"></a>文字颜色 <code>color</code></h3><p>规定文本的颜色, 值支持:</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: red;                  <span class="comment">/* 英文单词（适合快速原型） */</span></span><br><span class="line"><span class="attribute">color</span>: <span class="number">#ff0000</span>;              <span class="comment">/* 十六进制（设计师常用） */</span></span><br><span class="line"><span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.5</span>);    <span class="comment">/* 带透明度（悬浮效果常用） */</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>实际开发建议使用十六进制或 CSS 变量统一管理色值</p>
</blockquote>
<h3 id="字体大小-font-size"><a href="#字体大小-font-size" class="headerlink" title="字体大小 font-size"></a>字体大小 <code>font-size</code></h3><p>设置文字尺寸,PC 端网页常用单位为 <strong>px</strong>.<br>默认大小一般是 16px.</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span>; &#125;    <span class="comment">/* 默认基准值 */</span></span><br><span class="line"><span class="selector-class">.title</span> &#123; <span class="attribute">font-size</span>: <span class="number">2rem</span>; &#125;  <span class="comment">/* 推荐 rem 适配响应式 */</span></span><br><span class="line"><span class="selector-class">.mobile</span> &#123; <span class="attribute">font-size</span>: <span class="number">4vw</span>; &#125;  <span class="comment">/* 视口动态缩放（移动端慎用） */</span></span><br></pre></td></tr></table></figure></div>

<p>⚠️ Chrome 强制最小 12px，移动端适配优先用 <code>rem</code> + 媒体查询</p>
<h3 id="字体粗细-font-weight"><a href="#字体粗细-font-weight" class="headerlink" title="字体粗细 font-weight"></a>字体粗细 <code>font-weight</code></h3><p>设置字体的粗细。</p>
<table>
<thead>
<tr>
<th>数值</th>
<th>等效关键字</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>normal</td>
<td>正文默认</td>
</tr>
<tr>
<td>700</td>
<td>bold</td>
<td>标题&#x2F;重点强调</td>
</tr>
<tr>
<td>300</td>
<td>-</td>
<td>纤薄字体（需字体支持）</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 优先用数字写法 */</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">font-weight</span>: <span class="number">700</span>; &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="字体样式-font-style"><a href="#字体样式-font-style" class="headerlink" title="字体样式 font-style"></a>字体样式 <code>font-style</code></h3><p>一般用来 <strong>清除</strong> 字体的默认倾斜.</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code></td>
<td>不倾斜</td>
</tr>
<tr>
<td><code>italic</code></td>
<td>倾斜</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">em</span> &#123;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;  <span class="comment">/* 取消 &lt;em&gt; 默认斜体 */</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#f00</span>;         <span class="comment">/* 改为红色强调 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="字体族-font-family"><a href="#字体族-font-family" class="headerlink" title="字体族 font-family"></a>字体族 <code>font-family</code></h3><p>设置字体样式.<br>属性值填写字体名称即可,多个字体逗号隔开. 如果字体名称包含空格，它必须加上引号.</p>
<p>Windows 优先用微软雅黑，macOS 用苹方<br>中文字体文件过大，建议用 <code>font-display: swap</code> 防阻塞渲染</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>:</span><br><span class="line">    <span class="string">&quot;Microsoft Yahei&quot;</span>,   <span class="comment">/* 首选字体 */</span></span><br><span class="line">    <span class="string">&quot;PingFang SC&quot;</span>,       <span class="comment">/* macOS 字体 */</span></span><br><span class="line">    sans-serif;          <span class="comment">/* 兜底通用字体 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>中文字体名称需加引号，最后必须设置通用字体族（sans-serif &#x2F; serif &#x2F; monospace）</p>
</blockquote>
<h3 id="复合属性-font"><a href="#复合属性-font" class="headerlink" title="复合属性 font"></a>复合属性 <code>font</code></h3><p>节省代码量,能集合字体的其他属性调整.</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 完整格式：style weight size/line-height family */</span></span><br><span class="line"><span class="attribute">font</span>: italic <span class="number">700</span> <span class="number">16px</span>/<span class="number">1.5</span> <span class="string">&quot;Arial&quot;</span>, sans-serif;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 最简写法（必须包含 size 和 family） */</span></span><br><span class="line"><span class="attribute">font</span>: <span class="number">14px</span> <span class="string">&quot;SimSun&quot;</span>;</span><br></pre></td></tr></table></figure></div>

<p>未设置的属性会重置为默认值。</p>
<h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><h3 id="文本对齐-text-align"><a href="#文本对齐-text-align" class="headerlink" title="文本对齐 text-align"></a>文本对齐 <code>text-align</code></h3><p>控制文本水平排列方向，适用于块级元素</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基础用法 */</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">text-align</span>: center; &#125;    <span class="comment">/* 标题居中 */</span></span><br><span class="line"><span class="selector-class">.nav</span> &#123; <span class="attribute">text-align</span>: right; &#125;   <span class="comment">/* 导航右对齐 */</span></span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>值</th>
<th>效果</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td>left</td>
<td>左对齐（默认）</td>
<td>正文段落</td>
</tr>
<tr>
<td>center</td>
<td>居中对齐</td>
<td>标题&#x2F;按钮文字</td>
</tr>
<tr>
<td>right</td>
<td>右对齐</td>
<td>时间戳&#x2F;操作按钮</td>
</tr>
<tr>
<td>justify</td>
<td>两端对齐</td>
<td>报刊杂志式排版</td>
</tr>
</tbody></table>
<h3 id="文本修饰-text-decoration"><a href="#文本修饰-text-decoration" class="headerlink" title="文本修饰 text-decoration"></a>文本修饰 <code>text-decoration</code></h3><p>控制文本装饰线条样式</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">text-decoration</span>: none; &#125;     <span class="comment">/* 去除链接下划线 */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.discount</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: line-through; <span class="comment">/* 商品价格删除线 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.highlight</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline wavy <span class="number">#ff0000</span>; <span class="comment">/* 波浪形下划线 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>属性值</th>
<th>效果扩展</th>
</tr>
</thead>
<tbody><tr>
<td>underline</td>
<td>支持定义线型和颜色（CSS3）</td>
</tr>
<tr>
<td>overline</td>
<td>常用于设计元素装饰</td>
</tr>
<tr>
<td>line-through</td>
<td>电商场景表示原价</td>
</tr>
</tbody></table>
<h3 id="控制文本大小写-text-transform"><a href="#控制文本大小写-text-transform" class="headerlink" title="控制文本大小写 text-transform"></a>控制文本大小写 <code>text-transform</code></h3><p>强制控制文字大小写，不改变原始内容</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;  <span class="comment">/* 按钮文字全大写 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">text-transform</span>: capitalize; <span class="comment">/* 每个单词首字母大写 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>值</th>
<th>效果说明</th>
</tr>
</thead>
<tbody><tr>
<td>uppercase</td>
<td>全大写（如：BUTTON）</td>
</tr>
<tr>
<td>lowercase</td>
<td>全小写（如：alert）</td>
</tr>
<tr>
<td>capitalize</td>
<td>首字母大写（如：Hello World）</td>
</tr>
</tbody></table>
<h3 id="文本缩进-text-indent"><a href="#文本缩进-text-indent" class="headerlink" title="文本缩进 text-indent"></a>文本缩进 <code>text-indent</code></h3><p>控制段落首行缩进，支持负值</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">text-indent</span>: <span class="number">2em</span>;   <span class="comment">/* 首行缩进2字符 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hidden-text</span> &#123;</span><br><span class="line">  <span class="attribute">text-indent</span>: -<span class="number">9999px</span>; <span class="comment">/* SEO隐藏文字技巧 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>推荐使用相对单位：<br><code>1em = 当前字体尺寸</code>，适配不同屏幕比例</p>
</blockquote>
<h3 id="行高控制-line-height"><a href="#行高控制-line-height" class="headerlink" title="行高控制 line-height"></a>行高控制 <code>line-height</code></h3><p>影响垂直排版的属性</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">40px</span>;  <span class="comment">/* 单行文字垂直居中 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.article</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.6</span>;   <span class="comment">/* 无单位值，基于当前字体尺寸 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="推荐技巧："><a href="#推荐技巧：" class="headerlink" title="推荐技巧："></a>推荐技巧：</h4><ol>
<li><strong>单行居中</strong>：<code>line-height = height</code></li>
<li><strong>阅读优化</strong>：正文建议 1.5-1.8 倍行距</li>
<li><strong>数值类型</strong>：优先使用无单位数值（继承更安全）</li>
</ol>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 最佳实践 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.6</span>;  <span class="comment">/* 实际计算值 16px * 1.6 = 25.6px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="背景图属性"><a href="#背景图属性" class="headerlink" title="背景图属性"></a>背景图属性</h2><p><strong>常用方式</strong></p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f0f0f0</span>;       <span class="comment">/* 设置纯色背景 */</span></span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;bg.jpg&quot;</span>); <span class="comment">/* 添加背景图 */</span></span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;    <span class="comment">/* 禁止平铺 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="背景平铺-background-repeat"><a href="#背景平铺-background-repeat" class="headerlink" title="背景平铺 background-repeat"></a>背景平铺 <code>background-repeat</code></h3><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.banner</span> &#123;</span><br><span class="line">  <span class="attribute">background-repeat</span>: repeat-x;     <span class="comment">/* 横向平铺制作条纹背景 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pattern</span> &#123;</span><br><span class="line">  <span class="attribute">background-repeat</span>: repeat;       <span class="comment">/* 小尺寸图案无缝平铺 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>值</th>
<th>效果</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>no-repeat</td>
<td>不重复（最常用）</td>
<td>banner&#x2F;封面图</td>
</tr>
<tr>
<td>repeat-x</td>
<td>横向重复</td>
<td>渐变条纹背景</td>
</tr>
<tr>
<td>space</td>
<td>等间距平铺（CSS3）</td>
<td>网格布局</td>
</tr>
</tbody></table>
<h3 id="背景定位-background-position"><a href="#背景定位-background-position" class="headerlink" title="背景定位 background-position"></a>背景定位 <code>background-position</code></h3><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-position</span>: right <span class="number">10px</span> center; <span class="comment">/* 右侧10px垂直居中 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hero</span> &#123;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">80%</span> <span class="number">50%</span>; <span class="comment">/* 焦点图主体居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>开发技巧</strong>：</p>
<ul>
<li>使用方位词组合更直观（left top&#x2F;center bottom）</li>
<li>百分比定位公式：<code>(容器尺寸 - 图片尺寸) * 百分比</code></li>
<li>雪碧图定位推荐像素单位</li>
</ul>
<h3 id="背景缩放-background-size"><a href="#背景缩放-background-size" class="headerlink" title="背景缩放 background-size"></a>背景缩放 <code>background-size</code></h3><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;     <span class="comment">/* 完全覆盖容器（可能裁剪） */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.product</span> &#123;</span><br><span class="line">  <span class="attribute">background-size</span>: contain;   <span class="comment">/* 完整显示图片（可能留白） */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.avatar</span> &#123;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">80px</span> auto; <span class="comment">/* 固定宽度自适应高度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>值</th>
<th>效果对比</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>cover</td>
<td>铺满容器无空白</td>
<td>全屏背景图</td>
</tr>
<tr>
<td>contain</td>
<td>完整显示图片</td>
<td>产品展示图</td>
</tr>
</tbody></table>
<h3 id="复合属性"><a href="#复合属性" class="headerlink" title="复合属性"></a>复合属性</h3><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, <span class="number">#ff6b6b30</span>, <span class="number">#4ecdc430</span>), <span class="comment">/* 渐变遮罩层 */</span></span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&quot;card-bg.jpg&quot;</span>) center/cover no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>正确简写顺序</strong>：<br><code>color image repeat attachment position/size</code></p>
<blockquote>
<p>⚠️ 注意：老版本浏览器需分开写 <code>background-size</code></p>
</blockquote>
<h3 id="实战开发建议"><a href="#实战开发建议" class="headerlink" title="实战开发建议"></a>实战开发建议</h3><ol>
<li><p><strong>性能优化</strong></p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 雪碧图方案 */</span></span><br><span class="line"><span class="selector-class">.icon-home</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;sprite.png&quot;</span>) -<span class="number">120px</span> <span class="number">0</span> / <span class="number">400px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>响应式适配</strong></p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.banner</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;mobile-bg.jpg&quot;</span>);</span><br><span class="line">    <span class="attribute">background-size</span>: contain;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>备用方案</strong></p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hero</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#2c3e50</span> <span class="built_in">url</span>(<span class="string">&quot;hero.jpg&quot;</span>) center/cover;</span><br><span class="line">  <span class="comment">/* 图片加载失败时显示背景色 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>视差效果</strong></p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parallax</span> &#123;</span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed; <span class="comment">/* 创建滚动视差 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><strong>图片拉伸失真</strong><br>👉 使用<code>background-size: contain</code> + 给容器设置<code>max-width</code></p>
<p><strong>Retina 屏幕模糊</strong><br>👉 提供 2 倍尺寸图片 + 设置<code>background-size: 50% auto</code></p>
<p><strong>多重背景叠加</strong><br>👉 用逗号分隔多组背景，最先写的层级最高</p>
<p><strong>渐变+图片组合</strong><br>👉 先写渐变后写图片，用半透明渐变实现遮罩效果</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.overlay</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>:</span><br><span class="line">    <span class="built_in">linear-gradient</span>(<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.5</span>),</span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&quot;image.jpg&quot;</span>) center/cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="表格属性"><a href="#表格属性" class="headerlink" title="表格属性"></a>表格属性</h3><p>使用 <code>border</code> 属性指定表格边框</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span>, <span class="selector-tag">td</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="折叠边框-border-collapse"><a href="#折叠边框-border-collapse" class="headerlink" title="折叠边框 border-collapse"></a>折叠边框 <code>border-collapse</code></h4><p>border-collapse 属性设置表格的边框是否被折叠成一个单一的边框或隔开</p>
<h3 id="光标类型更改"><a href="#光标类型更改" class="headerlink" title="光标类型更改"></a>光标类型更改</h3><p>设置鼠标悬停在元素上的样式</p>
<p>属性名: cursor</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>pointer</td>
<td>小手效果</td>
</tr>
<tr>
<td>text</td>
<td>文字输入效果</td>
</tr>
<tr>
<td>move</td>
<td>十字光标效果</td>
</tr>
<tr>
<td>default</td>
<td>默认效果</td>
</tr>
</tbody></table>
<h2 id="表格与光标属性实战指南"><a href="#表格与光标属性实战指南" class="headerlink" title="表格与光标属性实战指南"></a>表格与光标属性实战指南</h2><h3 id="表格样式优化"><a href="#表格样式优化" class="headerlink" title="表格样式优化"></a>表格样式优化</h3><h4 id="基础边框控制"><a href="#基础边框控制" class="headerlink" title="基础边框控制"></a>基础边框控制</h4><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse;  <span class="comment">/* 合并边框（必选项） */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;                <span class="comment">/* 默认自适应容器 */</span></span><br><span class="line">  <span class="attribute">table-layout</span>: fixed;        <span class="comment">/* 固定列宽算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">td</span>, <span class="selector-tag">th</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#e0e0e0</span>;  <span class="comment">/* 单元格边框 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">12px</span>;              <span class="comment">/* 内边距必须设置 */</span></span><br><span class="line">  <span class="attribute">text-align</span>: left;           <span class="comment">/* 文本对齐 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>开发技巧</strong>：</p>
<ul>
<li>始终优先使用<code>border-collapse: collapse</code>避免双边框问题</li>
<li>设置<code>table-layout: fixed</code>提升渲染性能，配合<code>width</code>控制列宽</li>
<li>移动端适配添加<code>overflow-x: auto</code>实现横向滚动</li>
</ul>
<h4 id="进阶样式处理"><a href="#进阶样式处理" class="headerlink" title="进阶样式处理"></a>进阶样式处理</h4><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 斑马纹效果 */</span></span><br><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(even) &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f8f9fa</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 表头样式 */</span></span><br><span class="line"><span class="selector-tag">th</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#2c3e50</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">600</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 响应式表格 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">td</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">attr</span>(data-label);  <span class="comment">/* 使用data-label属性 */</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="光标类型应用"><a href="#光标类型应用" class="headerlink" title="光标类型应用"></a>光标类型应用</h3><h4 id="常用光标类型"><a href="#常用光标类型" class="headerlink" title="常用光标类型"></a>常用光标类型</h4><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clickable</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;       <span class="comment">/* 按钮/可点击元素 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.draggable</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: move;          <span class="comment">/* 可拖拽元素 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.disabled</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: not-allowed;   <span class="comment">/* 禁用状态 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.help-text</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: help;          <span class="comment">/* 帮助提示 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>完整属性参考</strong>：</p>
<table>
<thead>
<tr>
<th>光标类型</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>pointer</td>
<td>所有可点击元素</td>
</tr>
<tr>
<td>text</td>
<td>文本输入区域</td>
</tr>
<tr>
<td>move</td>
<td>可拖拽组件</td>
</tr>
<tr>
<td>not-allowed</td>
<td>禁用按钮&#x2F;不可操作状态</td>
</tr>
<tr>
<td>wait</td>
<td>加载等待状态</td>
</tr>
<tr>
<td>crosshair</td>
<td>绘图工具&#x2F;选区工具</td>
</tr>
<tr>
<td>zoom-in&#x2F;out</td>
<td>图片缩放操作</td>
</tr>
</tbody></table>
<h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 自定义光标 */</span></span><br><span class="line"><span class="selector-class">.drag-drop</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&#x27;drag-icon.svg&#x27;</span>), auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 禁用文本选择 */</span></span><br><span class="line"><span class="selector-class">.unselectable</span> &#123;</span><br><span class="line">  user-<span class="selector-tag">select</span>: none;</span><br><span class="line">  <span class="attribute">cursor</span>: default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h3><h4 id="表格最佳实践"><a href="#表格最佳实践" class="headerlink" title="表格最佳实践"></a>表格最佳实践</h4><ol>
<li><strong>语义化标记</strong>：始终使用<code>&lt;th&gt;</code>定义表头单元格</li>
<li><strong>响应式方案</strong>：<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">data-label</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>打印优化</strong>：添加<code>@media print</code>媒体查询调整表格样式</li>
</ol>
<h4 id="光标使用原则"><a href="#光标使用原则" class="headerlink" title="光标使用原则"></a>光标使用原则</h4><ol>
<li>不要滥用<code>cursor: pointer</code>（仅限真正可交互元素）</li>
<li>禁用状态必须同时设置<code>pointer-events: none</code><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.disabled</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: not-allowed;</span><br><span class="line">  <span class="attribute">pointer-events</span>: none;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>自定义光标保持尺寸 ≤32x32px，提供 fallback 方案</li>
</ol>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 硬件加速优化 */</span></span><br><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 避免复杂选择器 */</span></span><br><span class="line"><span class="selector-tag">tr</span><span class="selector-pseudo">:not</span>(<span class="selector-class">.empty-row</span>)<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f1f1f1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决"></a>常见问题解决</h3><p><strong>表格边框显示不全</strong><br>👉 检查是否设置<code>border-collapse: collapse</code>和正确的<code>border</code>继承</p>
<p><strong>移动端表格溢出</strong><br>👉 容器添加<code>overflow-x: auto</code> + 设置<code>min-width: 600px</code></p>
<p><strong>光标闪烁问题</strong><br>👉 自定义光标文件使用.cur 或.png 格式，避免.svg 格式兼容问题</p>
<p><strong>表格列宽不均</strong><br>👉 设置<code>table-layout: fixed</code> + 为<code>th</code>定义明确宽度：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">th</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123; <span class="attribute">width</span>: <span class="number">120px</span>; &#125;</span><br><span class="line"><span class="selector-tag">th</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123; <span class="attribute">width</span>: <span class="number">60%</span>; &#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h1><h3 id="基本盒子模型的组成"><a href="#基本盒子模型的组成" class="headerlink" title="基本盒子模型的组成"></a>基本盒子模型的组成</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%BD%91%E9%A1%B5%E4%B9%8B%E8%A1%A3%E8%A3%B3-css/file-20250309204230952.jpg"
                     
                ></p>
<p>每个元素都是一个矩形盒子，从内到外由四层组成：</p>
<ol>
<li><strong>内容区</strong>：通过  <code>width/height</code>  控制尺寸</li>
<li><strong>内边距</strong>：<code>padding</code>  控制内容与边框间距</li>
<li><strong>边框</strong>：<code>border</code>  包裹内边距与内容</li>
<li><strong>外边距</strong>：<code>margin</code>  隔离相邻盒子（不计入盒子总尺寸）</li>
</ol>
<h3 id="尺寸的计算"><a href="#尺寸的计算" class="headerlink" title="尺寸的计算"></a>尺寸的计算</h3><ul>
<li><strong>默认情况</strong></li>
</ul>
<p>如果增加 padding, 盒子尺寸会变大.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%BD%91%E9%A1%B5%E4%B9%8B%E8%A1%A3%E8%A3%B3-css/file-20250309204416190.jpg"
                     
                ></p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">box-sizing</span>: content-box; &#125;</span><br><span class="line"><span class="comment">/* 总宽度 = width + padding + border */</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>智能內减</strong>（推荐）</li>
</ul>
<p>设置为自动减去 border&#x2F;padding 的尺寸</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">box-sizing</span>: border-box; &#125;</span><br><span class="line"><span class="comment">/* 总宽度 = width（自动扣除 padding 和 border）*/</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>实际开发建议全局设置：<br><code>* &#123; box-sizing: border-box; &#125;</code></p>
</blockquote>
<h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><p>行内元素添加内外边距, 无法改变元素的垂直位置</p>
<p>解决方法:<br>添加 line-height 改变垂直位置</p>
<h1 id="盒子模型相关属性"><a href="#盒子模型相关属性" class="headerlink" title="盒子模型相关属性"></a>盒子模型相关属性</h1><h3 id="边框线"><a href="#边框线" class="headerlink" title="边框线"></a>边框线</h3><table>
<thead>
<tr>
<th>边框样式</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>solid</code></td>
<td>实线（最常用）</td>
</tr>
<tr>
<td><code>dashed</code></td>
<td>虚线</td>
</tr>
<tr>
<td><code>dotted</code></td>
<td>点线</td>
</tr>
</tbody></table>
<p>使用属性: border-radius 添加圆角.</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 基础边框 */</span></span><br><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#333</span>; <span class="comment">/* 粗细 样式 颜色 */</span></span><br><span class="line"><span class="attribute">border-top-style</span>: dotted; <span class="comment">/* 单独控制某边 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 圆角进阶 */</span></span><br><span class="line"><span class="selector-class">.avatar</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>; <span class="comment">/* 正圆 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">20px</span>; <span class="comment">/* 胶囊按钮 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="内外边距"><a href="#内外边距" class="headerlink" title="内外边距"></a>内外边距</h3><p><strong>padding</strong>：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;           <span class="comment">/* 四边相同 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">5px</span> <span class="number">20px</span>;       <span class="comment">/* 上下 | 左右 */</span></span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">0</span> <span class="number">15px</span>;    <span class="comment">/* 上 | 左右 | 下 */</span></span><br></pre></td></tr></table></figure></div>

<p><strong>margin</strong>：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>: <span class="number">0</span> auto; <span class="comment">/* 水平居中经典写法 */</span></span><br><span class="line"><span class="selector-class">.parent</span> &#123; <span class="attribute">margin-bottom</span>: <span class="number">30px</span>; &#125; <span class="comment">/* 推荐用 padding 替代 margin 分隔父子元素 */</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>行内元素注意</strong>：垂直方向的 <code>padding/margin</code> 不生效，改用 <code>line-height</code> 调整间距</p>
</blockquote>
<h4 id="外边距两大经典问题"><a href="#外边距两大经典问题" class="headerlink" title="外边距两大经典问题"></a>外边距两大经典问题</h4><ol>
<li><p><strong>兄弟元素合并</strong>：垂直排列的两个元素，上下 <code>margin</code> 会合并取最大值</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方案：统一使用单方向 margin */</span></span><br><span class="line"><span class="selector-class">.item</span> &#123; <span class="attribute">margin-bottom</span>: <span class="number">20px</span>; &#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>父子元素塌陷</strong>：子元素的 <code>margin-top</code> 会穿透父容器</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 解决方案（任选其一） */</span></span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;     <span class="comment">/* 触发 BFC */</span></span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">1px</span>;     <span class="comment">/* 添加最小 padding */</span></span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid transparent; <span class="comment">/* 透明边框 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="清除默认样式"><a href="#清除默认样式" class="headerlink" title="清除默认样式"></a>清除默认样式</h3><div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box; <span class="comment">/* 关键！统一尺寸计算方式 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none; <span class="comment">/* 去除列表默认符号 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="标准流与浮动"><a href="#标准流与浮动" class="headerlink" title="标准流与浮动"></a>标准流与浮动</h1><p>在网页布局中，标准流（文档流）是 HTML 元素默认的排列规则。元素根据类型自动按照从上到下、从左到右的顺序排布，但存在以下限制：</p>
<ol>
<li>块级元素独占一行，行内元素无法直接设置宽高</li>
<li>行内元素默认<strong>底边对齐</strong>，若高度不一致会产生缝隙</li>
<li>连续空格或换行会触发<strong>空白折叠现象</strong>（多个空格合并为单个）</li>
</ol>
<h4 id="脱离标准流的方式"><a href="#脱离标准流的方式" class="headerlink" title="脱离标准流的方式"></a>脱离标准流的方式</h4><p>当需要突破标准流限制时，可通过三种方式实现：</p>
<ul>
<li><strong>浮动（float）</strong></li>
<li><strong>绝对定位（absolute）</strong></li>
<li><strong>固定定位（fixed）</strong></li>
</ul>
<h3 id="浮动特性与问题"><a href="#浮动特性与问题" class="headerlink" title="浮动特性与问题"></a>浮动特性与问题</h3><p>通过<code>float: left/right</code>让元素<strong>脱离标准流</strong>，产生以下特性：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;  <span class="comment">/* 元素向左浮动 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>; <span class="comment">/* 块元素转为行内块特性 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>核心表现</strong>：</p>
<ol>
<li>浮动元素自动转为行内块模式，可水平排列</li>
<li>后续未浮动元素会<strong>紧贴浮动元素边缘</strong>布局</li>
<li>父元素未设置高度时，浮动会导致<strong>高度塌陷</strong>（子元素无法撑开父容器）</li>
</ol>
<p><strong>典型问题场景</strong>：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- 浮动元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sibling&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- 受影响的兄弟元素 --&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>此时<code>.sibling</code>会向上移动填补空间，导致布局错乱。</p>
<h3 id="清除浮动的影响"><a href="#清除浮动的影响" class="headerlink" title="清除浮动的影响"></a>清除浮动的影响</h3><p><strong>方法一：手动定义父容器高度</strong></p>
<p>直接通过 CSS 固定高度，但缺乏灵活性：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123; <span class="attribute">height</span>: <span class="number">300px</span>; &#125; <span class="comment">/* 需预知内容高度 */</span></span><br></pre></td></tr></table></figure></div>

<p><strong>方法二：尾部插入清除元素</strong></p>
<p>在父容器末尾添加空块级元素并设置<code>clear</code>属性：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;float-box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- 清除元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123; <span class="attribute">clear</span>: both; &#125; <span class="comment">/* 阻断浮动影响 */</span></span><br></pre></td></tr></table></figure></div>

<p><strong>方法三：触发 BFC 特性</strong></p>
<p>通过<code>overflow</code>属性让父元素形成独立布局空间：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden; <span class="comment">/* 触发BFC */</span></span><br><span class="line">  <span class="attribute">clear</span>: both;      <span class="comment">/* 兼容旧浏览器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>浮动仍适用于图文环绕等传统场景，但复杂布局应优先考虑 Flex&#x2F;Grid 方案。</p>
<h1 id="Flex-弹性盒子模型"><a href="#Flex-弹性盒子模型" class="headerlink" title="Flex 弹性盒子模型"></a><code>Flex</code> 弹性盒子模型</h1><p>Flex 布局通过<strong>容器</strong>与<strong>子项目</strong>的联动机制实现灵活排版，彻底解决了传统浮动布局的痛点。只需为父元素设置<code>display: flex</code>，子元素将自动获得弹性伸缩特性。</p>
<h4 id="核心概念与属性"><a href="#核心概念与属性" class="headerlink" title="核心概念与属性"></a>核心概念与属性</h4><p><strong>容器属性</strong>控制整体排列规则，<strong>项目属性</strong>调整单个元素行为。以下为关键属性的快速索引：</p>
<table>
<thead>
<tr>
<th>控制维度</th>
<th>属性名</th>
<th>常用值示例</th>
<th>核心作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>主轴方向</strong></td>
<td><code>flex-direction</code></td>
<td><code>row</code>&#x2F;<code>column</code></td>
<td>定义项目的排列基准轴</td>
</tr>
<tr>
<td><strong>主轴对齐</strong></td>
<td><code>justify-content</code></td>
<td><code>center</code>&#x2F;<code>space-between</code></td>
<td>控制主轴空间分配策略</td>
</tr>
<tr>
<td><strong>交叉轴对齐</strong></td>
<td><code>align-items</code></td>
<td><code>stretch</code>&#x2F;<code>flex-start</code></td>
<td>定义侧轴对齐方式</td>
</tr>
<tr>
<td><strong>多行排列</strong></td>
<td><code>flex-wrap</code></td>
<td><code>wrap</code>&#x2F;<code>nowrap</code></td>
<td>允许项目换行显示</td>
</tr>
</tbody></table>
<h3 id="主轴控制详解"><a href="#主轴控制详解" class="headerlink" title="主轴控制详解"></a>主轴控制详解</h3><h4 id="flex-direction-方向设置"><a href="#flex-direction-方向设置" class="headerlink" title="flex-direction 方向设置"></a><code>flex-direction</code> 方向设置</h4><p>通过基准轴定义项目的排列流向：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><strong>column</strong></td>
<td>垂直方向, 从上到下</td>
</tr>
<tr>
<td>row</td>
<td>水平方向, 从左向右(默认)</td>
</tr>
<tr>
<td>row-reverse</td>
<td>水平方向, 从右向左</td>
</tr>
<tr>
<td>column-reverse</td>
<td>垂直方向, 从下向上</td>
</tr>
</tbody></table>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%BD%91%E9%A1%B5%E4%B9%8B%E8%A1%A3%E8%A3%B3-css/file-20250411152745580.jpg"
                     
                ></p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row; <span class="comment">/* 水平排列（默认） */</span></span><br><span class="line">  <span class="comment">/* column: 垂直排列 | row-reverse: 反向水平排列 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="justify-content-空间分配方式"><a href="#justify-content-空间分配方式" class="headerlink" title="justify-content 空间分配方式"></a><code>justify-content</code> 空间分配方式</h4><p>控制项目在主轴上的分布方式：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><strong>center</strong></td>
<td>整体居中</td>
</tr>
<tr>
<td><strong>space-between</strong></td>
<td><strong>首尾贴边</strong>，中间等距</td>
</tr>
<tr>
<td><strong>space-around</strong></td>
<td>每个项目<strong>两侧</strong>等距（视觉间距递增）</td>
</tr>
<tr>
<td><strong>space-evenly</strong></td>
<td>所有间隙<strong>完全相等</strong></td>
</tr>
<tr>
<td>felx-start</td>
<td>左对齐（默认）</td>
</tr>
<tr>
<td>felx-end</td>
<td>弹性盒子从主轴终点依次排起.</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between; <span class="comment">/* 典型应用场景 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>优先使用 Flex 处理<strong>一维线性布局</strong>（单行或单列）</p>
<h1 id="定位-position"><a href="#定位-position" class="headerlink" title="定位 position"></a>定位 <code>position</code></h1><p>通过  <code>position</code>  属性可灵活控制盒子在网页中的位置，其核心逻辑分为两步：<strong>启用定位模式</strong>（设置<code>position</code>属性值）和<strong>使用边偏移属性</strong>（<code>left</code>&#x2F;<code>right</code>&#x2F;<code>top</code>&#x2F;<code>bottom</code>）调整位置。常见的定位模式特性如下：</p>
<ul>
<li><strong>相对定位</strong>（<code>relative</code>）：元素相对于自身原位置偏移，<strong>通常用于作为子级绝对定位的参照容器</strong>，不脱离文档流。</li>
<li><strong>绝对定位</strong>（<code>absolute</code>）：元素相对于最近的定位父级（非<code>static</code>）进行偏移，<strong>脱离文档流</strong>，常用于父级设置<code>relative</code>后精准定位子元素，显示模式具备了行内块的特点。</li>
<li><strong>固定定位</strong>（<code>fixed</code>）：元素相对于浏览器视口定位，<strong>脱离文档流且不随页面滚动</strong>，适合悬浮按钮、导航栏等场景。</li>
</ul>
<h4 id="定位居中"><a href="#定位居中" class="headerlink" title="定位居中"></a>定位居中</h4><p>实现绝对定位元素的水平垂直居中需分两步：</p>
<ol>
<li>将元素左上角定位到父级中心点：<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;  <span class="comment">/* 水平偏移50% */</span></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;   <span class="comment">/* 垂直偏移50% */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>通过平移将元素自身尺寸回退一半，<strong>推荐使用<code>transform</code>简化代码</strong>：<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>); <span class="comment">/* 向左上移动自身宽高的一半 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<strong>注意</strong>：直接使用<code>margin</code>调整需明确元素尺寸，而<code>transform</code>无需预知尺寸，适配性更强。</li>
</ol>
<h3 id="堆叠层级-z-index"><a href="#堆叠层级-z-index" class="headerlink" title="堆叠层级 z-index"></a>堆叠层级 z-index</h3><p>当多个定位元素重叠时，可通过<code>z-index</code>控制显示优先级：</p>
<ul>
<li>默认按 HTML 书写顺序层叠（后写元素覆盖前写元素）</li>
<li><strong>属性值为整数</strong>，数值越大层级越高，默认值为 0</li>
<li><strong>仅对定位元素生效</strong>（如<code>absolute</code>&#x2F;<code>relative</code>&#x2F;<code>fixed</code>）</li>
</ul>
<h2 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h2><p>通过将多个小图合并为一张精灵图，减少服务器请求次数，提升加载性能。实现步骤：</p>
<ol>
<li><strong>容器匹配尺寸</strong>：创建与目标小图尺寸一致的盒子</li>
<li><strong>设置背景图</strong>：将精灵图作为容器背景</li>
<li><strong>精确定位</strong>：通过负值<code>background-position</code>移动背景图，使目标区域显示在容器中</li>
</ol>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.icon-home</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;sprites.png&quot;</span>);</span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">60px</span> -<span class="number">120px</span>; <span class="comment">/* 显示精灵图中位于(60px,120px)的小图 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>核心优势</strong>：减少 HTTP 请求，降低服务器压力，提升页面加载速度。</p>
<h1 id="元素溢出解决方法"><a href="#元素溢出解决方法" class="headerlink" title="元素溢出解决方法"></a>元素溢出解决方法</h1><p>通过 <code>overflow</code> 控制内容超出容器时的显示方式：</p>
<ul>
<li><strong>hidden</strong>：直接隐藏溢出内容</li>
<li><strong>scroll</strong>：始终显示滚动条（即使内容未溢出）</li>
<li><strong>auto</strong>：智能判定，仅在溢出时显示滚动条</li>
</ul>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;  <span class="comment">/* 按需显示滚动条 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h1><p>通过 <code>box-shadow</code> 添加立体效果，参数格式为：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 水平偏移 垂直偏移 模糊度 扩散范围 颜色 内外阴影 */</span></span><br><span class="line"><span class="attribute">box-shadow</span>: <span class="number">5px</span> <span class="number">5px</span> <span class="number">10px</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.3</span>) inset;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>省略<code>inset</code>时默认为外阴影</li>
<li>模糊半径和扩散半径可缺省，如仅设置基础效果：<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="number">#ccc</span>;  <span class="comment">/* 水平 垂直 模糊 颜色 */</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id="垂直对齐方式-vertical-align"><a href="#垂直对齐方式-vertical-align" class="headerlink" title="垂直对齐方式 vertical-align"></a>垂直对齐方式 <code>vertical-align</code></h1><p>控制 <strong>行内元素</strong> 或 <strong>表格单元格</strong> 的垂直对齐方式，常见场景包括：</p>
<ul>
<li>图片与同行文字的对齐</li>
<li>表格单元格内内容的垂直位置</li>
<li>行内块元素（如图标与文本混合排版）</li>
</ul>
<p><strong>注意</strong>：该属性 <strong>对块级元素无效</strong>（如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>）。</p>
<p><strong>生效元素</strong>：</p>
<ul>
<li>行内元素（<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>）</li>
<li>行内块元素（<code>&lt;img&gt;</code>、<code>&lt;button&gt;</code>）</li>
<li>表格单元格（<code>&lt;td&gt;</code>）</li>
<li><strong>默认值</strong>：<code>baseline</code>（基线对齐）</li>
</ul>
<h4 id="常用属性值与效果"><a href="#常用属性值与效果" class="headerlink" title="常用属性值与效果"></a>常用属性值与效果</h4><table>
<thead>
<tr>
<th>属性值</th>
<th>效果描述</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>baseline</strong></td>
<td>元素基线与父级基线对齐（默认行为）</td>
<td>文本与图片默认对齐方式</td>
</tr>
<tr>
<td><strong>top</strong></td>
<td>元素顶部与行内最高元素的顶部对齐</td>
<td>多行文本&#x2F;图标顶部对齐</td>
</tr>
<tr>
<td><strong>middle</strong></td>
<td>元素中线与父级基线 + 父级 x-height 中线对齐</td>
<td>图标与文字垂直居中</td>
</tr>
<tr>
<td><strong>bottom</strong></td>
<td>元素底部与行内最低元素的底部对齐</td>
<td>多元素底部统一对齐</td>
</tr>
<tr>
<td><strong>数值&#x2F;百分比</strong></td>
<td>相对基线偏移（正数上移，负数下移）</td>
<td>微调图标位置（如 <code>2px</code>）</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 示例：图片与文字居中对齐 */</span></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle; <span class="comment">/* 中线对齐 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>典型问题与解决方案</strong></p>
<ul>
<li>问题 1：图片底部默认间隙<br><strong>现象</strong>：<code>&lt;img&gt;</code> 下方出现空白，即使无 margin&#x2F;padding。<br><strong>原因</strong>：图片默认按 <code>baseline</code> 对齐，基线与父级基线存在间隙。<br><strong>解决</strong>：</li>
</ul>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: bottom;  <span class="comment">/* 或 top/middle */</span></span><br><span class="line">  <span class="comment">/* 或直接设置为块级元素 */</span></span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>问题 2：行内块元素高度撑开父级<br><strong>现象</strong>：父级高度被行内块元素异常撑大。<br><strong>原因</strong>：不同 <code>vertical-align</code> 值影响行内元素垂直排列方式。<br><strong>解决</strong>：</li>
</ul>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0</span>;  <span class="comment">/* 配合调整行高 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top; <span class="comment">/* 统一对齐方式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><strong>对齐基准差异</strong>：<code>middle</code> 并非绝对居中，实际效果受父级字体影响。</li>
<li><strong>数值偏移方向</strong>：<code>vertical-align: 10px</code> 表示 <strong>向上</strong> 偏移，与常规坐标系相反。</li>
<li><strong>表格单元格优先级</strong>：在 <code>&lt;td&gt;</code> 中，<code>vertical-align</code> 优先级高于 <code>align-items</code>。</li>
</ol>
<p><code>vertical-align</code> 的生效效果高度依赖上下文环境，明确 <strong>父级基线位置</strong> 和 <strong>同行元素对齐方式</strong> 是精准控制的关键。</p>
<h3 id="透明度效果控制"><a href="#透明度效果控制" class="headerlink" title="透明度效果控制"></a>透明度效果控制</h3><table>
<thead>
<tr>
<th>属性&#x2F;方法</th>
<th>作用对象</th>
<th>继承性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>opacity</code></strong></td>
<td>整个元素（含子元素）</td>
<td>是</td>
<td>整体透明度调整（如淡入淡出）</td>
</tr>
<tr>
<td><strong><code>rgba()</code></strong></td>
<td>元素的<strong>背景&#x2F;颜色</strong></td>
<td>否</td>
<td>仅背景或文本颜色透明</td>
</tr>
<tr>
<td><strong><code>hsla()</code></strong></td>
<td>同 <code>rgba()</code></td>
<td>否</td>
<td>同 <code>rgba()</code>，色域模式不同</td>
</tr>
</tbody></table>
<h4 id="opacity-属性"><a href="#opacity-属性" class="headerlink" title="opacity 属性"></a>opacity 属性</h4><p>控制元素及子元素的整体透明度，取值范围 <code>0（完全透明）</code> ~ <code>1（完全不透明）</code>：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;  <span class="comment">/* 元素整体半透明 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>子元素会继承父级透明度（无法单独设置子元素不透明）</li>
<li>元素即便完全透明（<code>opacity: 0</code>）<strong>仍占据布局空间</strong></li>
<li>常用于过渡动画效果：<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.button</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: opacity <span class="number">0.3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.7</span>;  <span class="comment">/* 悬停时半透明 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="rgba-hsla-颜色函数"><a href="#rgba-hsla-颜色函数" class="headerlink" title="rgba&#x2F;hsla 颜色函数"></a>rgba&#x2F;hsla 颜色函数</h4><p>仅针对特定颜色值（背景、边框、字体颜色）设置透明度，不影响元素内容：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3</span>);  <span class="comment">/* 红色背景，30% 不透明 */</span></span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">hsla</span>(<span class="number">120</span>, <span class="number">100%</span>, <span class="number">50%</span>, <span class="number">0.8</span>);        <span class="comment">/* 亮绿色文字，80% 不透明 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>优势</strong>：</p>
<ul>
<li><strong>精准控制</strong>：独立调整背景、文字、边框的透明度</li>
<li><strong>无继承性</strong>：子元素不受父级颜色透明的影响</li>
</ul>
<p>实现 <strong>背景透明但文字清晰</strong> 的效果：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);  <span class="comment">/* 半透明黑色背景 */</span></span><br><span class="line">  <span class="attribute">color</span>: white;                          <span class="comment">/* 文字保持不透明 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li><strong>点击事件穿透</strong>：<code>opacity: 0</code> 的元素仍可触发鼠标事件（需配合 <code>visibility: hidden</code> 完全隐藏）</li>
<li><strong>性能差异</strong>：<code>opacity</code> 变化可通过 GPU 加速渲染，性能优于 <code>visibility</code></li>
<li><strong>旧版 IE 兼容</strong>：IE8 及以下不支持 <code>rgba()</code>，需备用方案：<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgb</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);          <span class="comment">/* 兼容 IE8 */</span></span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);     <span class="comment">/* 现代浏览器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p><strong>常见问题</strong></p>
<ul>
<li>为何父级 <code>opacity: 0.5</code> 时，子元素无法恢复不透明？</li>
</ul>
<p>子元素实际透明度 &#x3D; 父级透明度 × 子级透明度。若父级 <code>opacity: 0.5</code>，子级即使设置 <code>opacity: 1</code>，实际仍为 <code>0.5 × 1 = 0.5</code>。<br>改用 <code>rgba()</code> 控制父级背景透明度，避免继承影响。</p>
<ul>
<li>如何实现背景图透明但文字不透明？</li>
</ul>
<p>使用 <code>rgba()</code> 设置背景色透明度<br>或通过伪元素独立控制背景层：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.banner</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;image.jpg&quot;</span>) <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.5</span>);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>关键结论</strong>：</p>
<ul>
<li>需整体透明 → <code>opacity</code></li>
<li>需局部透明（背景&#x2F;文字） → <code>rgba()</code>&#x2F;<code>hsla()</code></li>
<li>完全隐藏元素且不占位 → <code>opacity: 0</code> + <code>visibility: hidden</code></li>
</ul>
<hr>
<h3 id="CSS-cursor-属性详解"><a href="#CSS-cursor-属性详解" class="headerlink" title="CSS cursor 属性详解"></a>CSS <code>cursor</code> 属性详解</h3><hr>
<h4 id="核心作用"><a href="#核心作用" class="headerlink" title="核心作用"></a><strong>核心作用</strong></h4><p>控制鼠标悬停在元素上时的光标样式，直观反馈当前元素的交互行为（如可点击、拖拽、输入等），<strong>提升用户体验的直观性</strong>。</p>
<hr>
<h4 id="常用属性值与场景"><a href="#常用属性值与场景" class="headerlink" title="常用属性值与场景"></a><strong>常用属性值与场景</strong></h4><table>
<thead>
<tr>
<th>属性值</th>
<th>光标样式</th>
<th>典型应用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>default</code></td>
<td>默认箭头（系统默认）</td>
<td>普通元素（无特殊交互时）</td>
</tr>
<tr>
<td><code>pointer</code></td>
<td>手型图标</td>
<td>可点击元素（按钮、链接）</td>
</tr>
<tr>
<td><code>text</code></td>
<td>文本输入「I」型光标</td>
<td>文本输入框、可编辑区域</td>
</tr>
<tr>
<td><code>move</code></td>
<td>十字箭头</td>
<td>可拖拽元素（如拖拽调整位置）</td>
</tr>
<tr>
<td><code>grab</code> &#x2F; <code>grabbing</code></td>
<td>抓取手型</td>
<td>拖拽控制（如地图拖拽）</td>
</tr>
<tr>
<td><code>not-allowed</code></td>
<td>禁止图标</td>
<td>禁用状态（按钮不可点击时）</td>
</tr>
<tr>
<td><code>wait</code></td>
<td>加载等待（转圈）</td>
<td>操作等待提示（如提交中）</td>
</tr>
<tr>
<td><code>zoom-in</code> &#x2F; <code>zoom-out</code></td>
<td>放大镜图标</td>
<td>图片缩放控制</td>
</tr>
<tr>
<td><code>crosshair</code></td>
<td>十字准星</td>
<td>绘图工具（如选区、测量工具）</td>
</tr>
<tr>
<td><code>col-resize</code></td>
<td>左右调整双箭头</td>
<td>列宽调整（表格分隔线）</td>
</tr>
</tbody></table>
<hr>
<h4 id="自定义光标"><a href="#自定义光标" class="headerlink" title="自定义光标"></a><strong>自定义光标</strong></h4><p>通过 <code>url()</code> 指定光标图片，并设置备用值（避免图片加载失败）：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.custom-cursor</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">&quot;custom.png&quot;</span>), auto;</span><br><span class="line">  <span class="comment">/* 若图片无效，回退到 auto（默认光标） */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong>：</p>
<ul>
<li>图片格式推荐 <code>.png</code> 或 <code>.cur</code>（支持透明背景）</li>
<li>需指定备用光标（如 <code>pointer</code>、<code>default</code>）</li>
<li>图片尺寸不宜过大（一般建议 32×32 像素以内）</li>
</ul>
<hr>
<h4 id="特殊交互场景示例"><a href="#特殊交互场景示例" class="headerlink" title="特殊交互场景示例"></a><strong>特殊交互场景示例</strong></h4><ol>
<li><p><strong>禁用按钮的视觉反馈</strong>：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">button</span><span class="selector-pseudo">:disabled</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: not-allowed;  <span class="comment">/* 显示禁止操作光标 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>拖拽排序提示</strong>：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.draggable-item</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: grab;  <span class="comment">/* 未拖拽时显示抓取手型 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.draggable-item</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: grabbing;  <span class="comment">/* 拖拽中显示抓取中手型 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>输入区域提示</strong>：</p>
<div class="code-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.editable-area</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: text;  <span class="comment">/* 提示用户可输入文字 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<hr>
<h4 id="兼容性注意"><a href="#兼容性注意" class="headerlink" title="兼容性注意"></a><strong>兼容性注意</strong></h4><ul>
<li><strong>旧版浏览器</strong>（如 IE11）部分属性不支持：<ul>
<li><code>grab</code> &#x2F; <code>grabbing</code> → IE 不兼容，需降级为 <code>move</code></li>
<li><code>zoom-in</code> &#x2F; <code>zoom-out</code> → 部分浏览器需加前缀</li>
</ul>
</li>
<li><strong>自定义光标</strong>：<ul>
<li>需确保图片路径正确</li>
<li>避免使用复杂动画图片（可能导致性能问题）</li>
</ul>
</li>
</ul>
<hr>
<h4 id="关键结论"><a href="#关键结论" class="headerlink" title="关键结论"></a><strong>关键结论</strong></h4><ul>
<li><strong>直观性优先</strong>：通过光标样式明确反馈用户当前操作意图（如点击、输入、拖拽）。</li>
<li><strong>慎用自定义光标</strong>：优先使用系统默认值，确保兼容性和性能。</li>
<li><strong>禁用状态必加</strong>：对不可操作元素（如禁用按钮）添加 <code>not-allowed</code>，避免误导用户。</li>
</ul>
<h3 id="过渡效果"><a href="#过渡效果" class="headerlink" title="过渡效果"></a>过渡效果</h3><p>可以为一个元素在不同状态之前切换的时候添加过度效果.<br>加给标签本身</p>
<p><code>transation : 过度属性 花费时间(s)</code></p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>web前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>网页之大脑-Javascript</title>
    <url>/2023/11/06/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%89%8D%E7%AB%AF/%E7%BD%91%E9%A1%B5%E4%B9%8B%E5%A4%A7%E8%84%91-Javascript/</url>
    <content><![CDATA[<h1 id="JavaScript-介绍"><a href="#JavaScript-介绍" class="headerlink" title="JavaScript 介绍"></a>JavaScript 介绍</h1><p><strong>JavaScript 是网页的交互引擎</strong>，让静态页面获得响应能力。这门脚本语言无需编译即可在浏览器中直接运行，既能操作网页元素实现点击反馈、内容刷新等动态效果，也能通过 Node.js 技术扩展到服务器开发领域。</p>
<h4 id="核心规范（ECMAScript）"><a href="#核心规范（ECMAScript）" class="headerlink" title="核心规范（ECMAScript）"></a>核心规范（ECMAScript）</h4><p><strong>ECMAScript</strong>  定义了语言的基本规则（如变量、函数、循环），相当于 JavaScript 的语法教科书。</p>
<h4 id="浏览器扩展（Web-APIs）"><a href="#浏览器扩展（Web-APIs）" class="headerlink" title="浏览器扩展（Web APIs）"></a>浏览器扩展（Web APIs）</h4><p><strong>Web APIs</strong>  则是浏览器赋予的特殊能力，包含<strong>操控网页元素的 DOM 工具</strong>和<strong>管理浏览器窗口的 BOM 工具</strong>。两者如同汽车的发动机与方向盘，共同驱动现代网页应用的运行。</p>
<pre class="mermaid">graph TD
    JS[JavaScript] --> ES[ECMAScript]
    JS --> WA[Web APIs]
    ES -->|定义基础规则| 语法[变量/函数/循环]
    WA -->|操作页面| DOM[文档对象模型]
    WA -->|控制浏览器| BOM[浏览器对象模型]</pre>

<p><strong>ECMAScript 与 JavaScript 是规范与实现的关系</strong>，前者是后者的规格，后者是前者的一种实现。<br>前者定义语言标准（如 ES6 规范），后者在标准基础上扩展浏览器操作能力（DOM&#x2F;BOM），两者共同构成完整的 Web 开发解决方案。</p>
<p><a href="/2024/04/19/猎识印记-领域/软件工程/前端/ECMAScript入门/">ECMAScript入门</a></p>
<h3 id="书写位置"><a href="#书写位置" class="headerlink" title="书写位置"></a>书写位置</h3><h4 id="内部书写"><a href="#内部书写" class="headerlink" title="内部书写"></a>内部书写</h4><p><strong>直接写在 html 文件里。</strong></p>
<p>可以在网页的任意位置插入<code>&lt;script&gt;</code>标签编写 JS 代码，但通常建议放在<code>&lt;/body&gt;</code><strong>结束标签之前</strong>。<br>这样网页内容会先加载出来，不会让用户长时间面对空白页面。</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>...<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 网页内容 --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 建议将脚本放在页面底部 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;页面加载完成！&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="外部书写"><a href="#外部书写" class="headerlink" title="外部书写"></a>外部书写</h4><p><strong>将代码单独保存为.js 文件。</strong></p>
<p>像图片、CSS 文件一样，JS 代码也可以保存为独立文件（例如：<code>myScript.js</code>），通过链接引入网页。这种方式让代码更易维护，也方便多个页面重复使用。</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在head或body底部引入，注意路径正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/myScript.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>对应的<code>myScript.js</code>文件内容非常简单：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记住文件里不用再写&lt;script&gt;标签！</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;我是外部文件里的代码&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>即可达到同样的效果.</p>
<blockquote>
<p>虽然浏览器能自己猜出语句结束位置（分号<code>;</code>可省略），但保持统一更规范。</p>
</blockquote>
<h1 id="JavaScript-基础语法"><a href="#JavaScript-基础语法" class="headerlink" title="JavaScript 基础语法"></a>JavaScript 基础语法</h1><h3 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h3><p>✓ 严格区分大小写（<code>myVar</code> ≠ <code>myvar</code>）<br>✓ 语句结尾分号推荐添加（避免意外错误）</p>
<h3 id="信息交互方式"><a href="#信息交互方式" class="headerlink" title="## 信息交互方式"></a>## 信息交互方式</h3><h4 id="输出语法"><a href="#输出语法" class="headerlink" title="输出语法"></a>输出语法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用场景</th>
<th>特点说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>alert()</code></td>
<td>弹窗提示</td>
<td>阻断页面操作</td>
</tr>
<tr>
<td><code>document.write()</code></td>
<td>向网页插入内容</td>
<td>可解析 HTML 标签</td>
</tr>
<tr>
<td><code>console.log()</code></td>
<td>控制台调试输出</td>
<td>不影响页面展示</td>
</tr>
</tbody></table>
<ul>
<li><strong>弹窗警告</strong></li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;紧急通知！&#x27;</span>)  <span class="comment">// 完整写法 window.alert()</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>网页内容写入</strong></li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;&lt;span style=&quot;color:red&quot;&gt;重要内容&lt;/span&gt;&#x27;</span>)  <span class="comment">// 支持HTML标签渲染</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>调试输出</strong></li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;用户点击时间：&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>())  <span class="comment">// 可输出多个参数</span></span><br></pre></td></tr></table></figure></div>

<h3 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h3><ul>
<li><strong>基础弹窗输入</strong></li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userName = <span class="title function_">prompt</span>(<span class="string">&#x27;请输入您的名字&#x27;</span>)  <span class="comment">// 返回字符串类型输入值</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>操作网页内容</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问</span></span><br><span class="line"><span class="keyword">let</span> titleElement = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mainTitle&#x27;</span>)  <span class="comment">// 通过ID精准定位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改</span></span><br><span class="line">titleElement.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;i&gt;新标题&lt;/i&gt;&#x27;</span>  <span class="comment">// 可插入HTML标签</span></span><br><span class="line"><span class="comment">// 安全写法：titleElement.textContent = &#x27;纯文本内容&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="JavaScript-值"><a href="#JavaScript-值" class="headerlink" title="JavaScript 值"></a>JavaScript 值</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><strong>变量如同可重复使用的收纳盒</strong>，用<code>let</code>声明后可以随时更换存放内容。JavaScript 采用灵活的类型系统，同一个变量可以先后存储数字、文本等不同类型的数据。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> messageBox = <span class="string">&quot;欢迎登录&quot;</span>;  <span class="comment">// 初始存放文本（字面量）</span></span><br><span class="line">messageBox = <span class="number">2024</span>;          <span class="comment">// 更改为存放数字</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>现代写法</strong>：<code>let</code>声明块级作用域变量，禁止重复声明</li>
<li><strong>传统写法</strong>：<code>var</code>存在变量提升、可重复声明等问题（建议新手优先使用<code>let</code>）</li>
</ul>
<p><strong>命名基础规则</strong>：</p>
<ul>
<li>变量名需以字母、<code>$</code>或<code>_</code>开头，可包含数字但不可纯数字</li>
<li>严格区分大小写（如<code>user</code>与<code>User</code>视为不同变量）</li>
<li>禁止使用<code>class</code>、<code>function</code>等语言保留字</li>
</ul>
<p><strong>命名核心规范</strong>：</p>
<ul>
<li>命名应直指用途，例如用<code>studentCount</code>而非模糊的<code>s1</code></li>
<li>常规变量采用小驼峰格式如<code>firstName</code>，构造函数或类名使用大驼峰如<code>UserModel</code></li>
<li>布尔变量建议添加<code>is</code>&#x2F;<code>has</code>前缀增强可读性（如<code>isActive</code>）</li>
<li>常量则全大写加下划线（如<code>MAX_SIZE</code>）</li>
<li>函数命名以动词开头明确行为（如<code>calculateTotal()</code>），避免使用单字母或易混淆字符（如<code>l</code>、<code>O</code>），保持项目内命名风格统一</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p><strong>常量是带密码锁的保险箱</strong>，用<code>const</code>声明后内容不可更改。常用于存储固定配置、重要参数等需要保护的数据。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">MAX_USERS</span> = <span class="number">100</span>;       <span class="comment">// 声明即赋值</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">API_KEY</span> = <span class="string">&#x27;A1B2-C3D4&#x27;</span>; <span class="comment">// 重要凭证保护</span></span><br></pre></td></tr></table></figure></div>

<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>JavaScript 的数据分为两类：<strong>独立值</strong>（原始类型）和<strong>组合结构</strong>（引用类型）。两者的核心区别在于存储方式——原始类型直接存储值，引用类型存储内存地址。</p>
<h2 id="基础单元：原始类型"><a href="#基础单元：原始类型" class="headerlink" title="基础单元：原始类型"></a>基础单元：原始类型</h2><h3 id="数字型（Number）"><a href="#数字型（Number）" class="headerlink" title="数字型（Number）"></a>数字型（Number）</h3><ul>
<li>包含整数、小数、科学计数法表示</li>
<li>特殊值：<code>NaN</code>（无效运算结果）、<code>Infinity</code>（无穷大）</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> price = <span class="number">99.9</span>       <span class="comment">// 普通数字</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">10</span> / <span class="string">&#x27;a&#x27;</span>  <span class="comment">// → NaN</span></span><br><span class="line"><span class="keyword">let</span> max = <span class="number">1e500</span>        <span class="comment">// → Infinity</span></span><br></pre></td></tr></table></figure></div>

<h3 id="字符串型（String）"><a href="#字符串型（String）" class="headerlink" title="字符串型（String）"></a>字符串型（String）</h3><ul>
<li>三种包裹方式：单引号、双引号、反引号</li>
<li>反引号支持换行和变量插入（模板字符串）</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">`用户<span class="subst">$&#123;isLogin ? <span class="string">&#x27;已登录&#x27;</span> : <span class="string">&#x27;未登录&#x27;</span>&#125;</span>`</span></span><br></pre></td></tr></table></figure></div>

<h3 id="布尔型（Boolean）"><a href="#布尔型（Boolean）" class="headerlink" title="布尔型（Boolean）"></a>布尔型（Boolean）</h3><ul>
<li>仅两个值：<code>true</code>表示真，<code>false</code>表示假</li>
<li>自动类型转换：<code>0</code>、<code>&quot;&quot;</code>、<code>null</code>等会被转为<code>false</code></li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isLogin = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> (isLogin) &#123; <span class="comment">/* 不会执行 */</span> &#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="特殊原始值"><a href="#特殊原始值" class="headerlink" title="特殊原始值"></a>特殊原始值</h3><table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>undefined</code></td>
<td>未赋值的默认状态</td>
<td>声明变量未初始化时</td>
</tr>
<tr>
<td><code>null</code></td>
<td>显式标记为空值</td>
<td>主动清空对象引用时</td>
</tr>
</tbody></table>
<h2 id="组合结构：引用类型"><a href="#组合结构：引用类型" class="headerlink" title="组合结构：引用类型"></a>组合结构：引用类型</h2><h3 id="对象（Object）"><a href="#对象（Object）" class="headerlink" title="对象（Object）"></a>对象（Object）</h3><p>对象如同一个存放相关信息的档案袋，每个信息项由「属性名+值」（键值对）组成。例如学生档案可以包含姓名、成绩、选修课程等相互关联的信息。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> student = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    <span class="attr">score</span>: <span class="number">95</span>,</span><br><span class="line">    <span class="attr">course</span>: [<span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;物理&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h3><p><strong>智能收纳盒</strong><br>数组如同带编号的收纳格，每个格子自动获得位置编号（索引），从 0 开始计数。这种设计让批量管理相似数据变得高效。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;红&#x27;</span>, <span class="string">&#x27;绿&#x27;</span>, <span class="string">&#x27;蓝&#x27;</span>]</span><br><span class="line">colors[<span class="number">1</span>] = <span class="string">&#x27;黄&#x27;</span>  <span class="comment">// 修改第二个元素</span></span><br></pre></td></tr></table></figure></div>

<h3 id="函数（Function）"><a href="#函数（Function）" class="headerlink" title="函数（Function）"></a>函数（Function）</h3><p><strong>可复用的工具包</strong><br>函数是一组打包的操作指令，通过输入参数执行特定任务并返回结果。其特殊之处在于既能存储代码逻辑，又能像普通对象一样添加属性。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="类型检测"><a href="#类型检测" class="headerlink" title="类型检测"></a>类型检测</h3><p><strong>typeof 基础检测</strong></p>
<ul>
<li>快速识别基础类型：<br><code>typeof &quot;text&quot; → &quot;string&quot;</code><br><code>typeof 42 → &quot;number&quot;</code><br><code>typeof null → &quot;object&quot;</code>（特殊记忆点）</li>
</ul>
<p><strong>精准类型判断</strong></p>
<ul>
<li>数组检测：<code>Array.isArray([1,2])</code></li>
<li>对象类型：<code>&#123;&#125; instanceof Object</code></li>
<li>NaN 识别：<code>Number.isNaN(NaN)</code></li>
</ul>
<p><strong>NaN 的处理</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唯一不等于自身的值</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> → <span class="literal">false</span></span><br><span class="line"><span class="comment">// 正确检测方式</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">0</span>/<span class="number">0</span>) → <span class="literal">true</span> <span class="comment">// 只有这种NaN参与的运算为true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h3><p><strong>数字转换</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;123&quot;</span>) → <span class="number">123</span>      <span class="comment">// 纯数字字符串</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;12px&quot;</span>) → <span class="title class_">NaN</span>     <span class="comment">// 含非数字字符</span></span><br><span class="line">+<span class="string">&quot;3.14&quot;</span> → <span class="number">3.14</span>           <span class="comment">// 快捷写法</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;100cm&quot;</span>) → <span class="number">100</span>  <span class="comment">// 提取整数部分</span></span><br></pre></td></tr></table></figure></div>

<p>想要从<code>&quot;12px&quot;</code>中提取纯数字：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="built_in">parseInt</span>(<span class="string">&quot;100px&quot;</span>, <span class="number">10</span>)  <span class="comment">// → 100（自动忽略非数字部分）</span></span><br><span class="line"><span class="keyword">let</span> price = <span class="built_in">parseFloat</span>(<span class="string">&quot;￥3.14&quot;</span>)  <span class="comment">// → 3.14</span></span><br></pre></td></tr></table></figure></div>

<p><strong>字符串转换</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">String</span>(<span class="number">2024</span>) → <span class="string">&quot;2024&quot;</span>    <span class="comment">// 显式转换</span></span><br><span class="line"><span class="number">123</span> + <span class="string">&quot;&quot;</span> → <span class="string">&quot;123&quot;</span>         <span class="comment">// 隐式快捷写法</span></span><br><span class="line"><span class="string">`价格：<span class="subst">$&#123;<span class="number">99</span>&#125;</span>元`</span> → <span class="string">&quot;价格：99元&quot;</span> <span class="comment">// 模板字符串</span></span><br></pre></td></tr></table></figure></div>

<p><strong>布尔转换</strong></p>
<ul>
<li>六种假值：<code>0</code>、<code>&quot;&quot;</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code>、<code>false</code></li>
<li>对象永远为真：<code>Boolean([]) → true</code></li>
</ul>
<h3 id="隐式转换陷阱"><a href="#隐式转换陷阱" class="headerlink" title="隐式转换陷阱"></a>隐式转换陷阱</h3><p><strong>算术运算</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;5&quot;</span> - <span class="number">2</span> → <span class="number">3</span>      <span class="comment">// 自动转数字</span></span><br><span class="line"><span class="literal">true</span> + <span class="number">1</span> → <span class="number">2</span>     <span class="comment">// true转1</span></span><br><span class="line"><span class="literal">null</span> * <span class="number">10</span> → <span class="number">0</span>    <span class="comment">// null转0</span></span><br></pre></td></tr></table></figure></div>

<p>比较时，使用严格等 <code>===</code> 来避免意外转换：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;5&quot;</span> === <span class="number">5</span> → <span class="literal">false</span> <span class="comment">// 若是 == 则会将两边强制转换，导致为 true</span></span><br></pre></td></tr></table></figure></div>

<p><strong>加号双面性</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="string">&quot;2&quot;</span> → <span class="string">&quot;32&quot;</span>   <span class="comment">// 优先拼接字符串</span></span><br><span class="line"><span class="number">5</span> + <span class="literal">true</span> → <span class="number">6</span>     <span class="comment">// true转1后计算</span></span><br></pre></td></tr></table></figure></div>

<p><strong>特殊等式</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">[] == <span class="number">0</span> → <span class="literal">true</span>    <span class="comment">// []→&quot;&quot;→0</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">false</span> → <span class="literal">true</span><span class="comment">// 两边都转0</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> → <span class="literal">true</span> <span class="comment">// 特殊规则</span></span><br></pre></td></tr></table></figure></div>

<p>因此还是用严格等来避免意外情况最好。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li><strong>条件语句</strong>：<code>if/else</code>、<code>switch</code></li>
<li><strong>循环语句</strong>：<code>for</code>、<code>while</code>、<code>do...while</code></li>
<li><strong>逻辑运算符</strong>：<code>&amp;&amp;</code>、<code>||</code>、<code>!</code></li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符不仅是条件判断工具，更是通过<strong>短路运算</strong>实现流程控制的关键。理解其特性可大幅提升代码简洁性：</p>
<ul>
<li><code>&amp;&amp;</code> 逻辑与</li>
</ul>
<p>当前项为真值时继续执行，否则停止。可以替代简单 if。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用户存在时执行回调</span></span><br><span class="line">user.<span class="property">isLogin</span> &amp;&amp; <span class="title function_">showUserMenu</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="keyword">if</span> (user.<span class="property">isLogin</span>) &#123;</span><br><span class="line">  <span class="title function_">showUserMenu</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>||</code>  逻辑或</li>
</ul>
<p>遇到第一个真值立即返回，常用于设置默认值（存在潜在风险）。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取配置项，不存在时用默认值</span></span><br><span class="line"><span class="keyword">const</span> timeout = settings.<span class="property">timeout</span> || <span class="number">3000</span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>??</code>  空值合并运算符</li>
</ul>
<p>仅当左侧为  <code>null/undefined</code>  时返回右侧值，常用于需要保留 0、false、空字符串等有效值。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分页配置（允许 pageSize=0）</span></span><br><span class="line"><span class="keyword">const</span> pageSize = userSetting.<span class="property">pageSize</span> ?? <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表单提交（空字符串视为有效输入）</span></span><br><span class="line"><span class="keyword">const</span> address = formData.<span class="property">address</span> ?? <span class="string">&#x27;未填写&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="switch-的严格比较"><a href="#switch-的严格比较" class="headerlink" title="switch  的严格比较"></a><code>switch</code>  的严格比较</h3><p>Javascript 中的 switch 是使用  <code>===</code>  严格比较（不会自动类型转换）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">switch</span>(num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;5&quot;</span>: <span class="comment">// 不会匹配（类型不同）</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:   <span class="comment">// 正确匹配</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="for-遍历与循环"><a href="#for-遍历与循环" class="headerlink" title="for 遍历与循环"></a><code>for</code> 遍历与循环</h3><h4 id="基础-for-循环"><a href="#基础-for-循环" class="headerlink" title="基础 for 循环"></a>基础 <code>for</code> 循环</h4><p>按数字顺序循环，比如遍历数组（通过索引）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 更新) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>完全控制循环次数（比如可以 <code>i += 2</code> 跳着遍历）。</li>
<li>可以通过 <code>break</code> 提前终止，或 <code>continue</code> 跳过某次循环。</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子：遍历数组</span></span><br><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;橙子&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; fruits.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fruits[i]); <span class="comment">// 依次输出：苹果、香蕉、橙子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="for-in-遍历对象"><a href="#for-in-遍历对象" class="headerlink" title="for...in 遍历对象"></a><code>for...in</code> 遍历对象</h4><p>遍历对象的 <strong>属性名</strong>（键名），适合处理对象。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> 对象) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>遍历数组时，<code>key</code> 是字符串类型的索引（如 <code>&quot;0&quot;</code>, <code>&quot;1&quot;</code>）。</li>
<li>会遍历对象原型链上的属性，通常用 <code>if (obj.hasOwnProperty(key))</code> 过滤。</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子：遍历对象</span></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&#x27;: &#x27;</span> + person[key]);</span><br><span class="line">  <span class="comment">// 输出：name: 小明，age: 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="for-of-直接拿到数组的值"><a href="#for-of-直接拿到数组的值" class="headerlink" title="for...of 直接拿到数组的值"></a><code>for...of</code> 直接拿到数组的值</h4><p><strong>用途</strong>：遍历 <strong>可迭代对象</strong>（如数组、字符串、Map、Set），直接拿到值。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> 可迭代对象) &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>简洁，不用写索引。</li>
<li>支持 <code>break</code> 和 <code>continue</code>。</li>
<li><strong>不能直接遍历普通对象</strong>（会报错）。</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子：遍历数组</span></span><br><span class="line"><span class="keyword">const</span> fruits = [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;橙子&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> fruit <span class="keyword">of</span> fruits) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fruit); <span class="comment">// 直接输出元素值：苹果、香蕉、橙子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子：遍历字符串</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(char); <span class="comment">// 依次输出 h, e, l, l, o</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="forEach-数组专用"><a href="#forEach-数组专用" class="headerlink" title="forEach 数组专用"></a><code>forEach</code> 数组专用</h4><p><strong>用途</strong>：对数组的每个元素执行一次函数（属于数组方法，不是 <code>for</code> 语句）。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">数组.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">元素, 索引, 原数组</span>) &#123;</span><br><span class="line">  <span class="comment">// 操作元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>无法用 <code>break</code> 或 <code>return</code> 终止循环</strong>！</li>
<li>适用于简单的遍历操作（比如修改元素）。</li>
</ul>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子：</span></span><br><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">nums.<span class="title function_">forEach</span>(<span class="function">(<span class="params">num, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(index + <span class="string">&#x27;: &#x27;</span> + num); <span class="comment">// 0:1, 1:2, 2:3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h4 id="总结：如何选择？"><a href="#总结：如何选择？" class="headerlink" title="总结：如何选择？"></a>总结：如何选择？</h4><table>
<thead>
<tr>
<th>循环类型</th>
<th>适用场景</th>
<th>是否支持 <code>break</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>for</code></td>
<td>需要索引或精确控制循环次数</td>
<td>✅</td>
</tr>
<tr>
<td><code>for...in</code></td>
<td>遍历对象的属性名</td>
<td>✅</td>
</tr>
<tr>
<td><code>for...of</code></td>
<td>遍历数组、字符串等可迭代对象</td>
<td>✅</td>
</tr>
<tr>
<td><code>forEach</code></td>
<td>数组简单遍历，无需中断</td>
<td>❌</td>
</tr>
</tbody></table>
<h3 id="循环索引小技巧"><a href="#循环索引小技巧" class="headerlink" title="循环索引小技巧"></a>循环索引小技巧</h3><p><strong>用取模运算 <code>%</code> 替代 <code>if</code> 边界判断</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心代码：天然防越界，循环切换索引</span></span><br><span class="line">index = (index + <span class="number">1</span>) % arrayLength;      <span class="comment">// 下一页</span></span><br><span class="line">index = (index - <span class="number">1</span> + arrayLength) % arrayLength; <span class="comment">// 上一页</span></span><br></pre></td></tr></table></figure></div>

<p><strong>三大优势</strong></p>
<ol>
<li><strong>代码极简</strong>：1 行替代多行<code>if</code>边界判断</li>
<li><strong>数学防越界</strong>：自动将索引限制在 <code>0 ~ arrayLength-1</code></li>
<li><strong>性能无损</strong>：现代 JS 引擎优化后，性能与<code>if</code>判断几乎无差</li>
</ol>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul>
<li>轮播图&#x2F;无缝滚动</li>
<li>循环队列、环形缓冲区</li>
<li>游戏角色地图循环移动</li>
<li>RGB 颜色渐变循环</li>
</ul>
<h3 id="真值判断"><a href="#真值判断" class="headerlink" title="真值判断"></a>真值判断</h3><p><strong>六种假值</strong>：<code>0</code>、<code>&quot;&quot;</code>、<code>null</code>、<code>undefined</code>、<code>NaN</code>、<code>false</code></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ([]) &#123; <span class="comment">// → true（空数组是真值！）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;空数组会通过判断&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (&#123;&#125;) &#123; <span class="comment">// → true（空对象也是真值）</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;空对象会通过判断&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>安全写法</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断数组/对象是否为空</span></span><br><span class="line"><span class="keyword">if</span> (arr.<span class="property">length</span> &gt; <span class="number">0</span>) &#123; <span class="comment">/* 执行 */</span> &#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span> &gt; <span class="number">0</span>) &#123; <span class="comment">/* 执行 */</span> &#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>用中括号包裹所有元素，元素间用逗号隔开。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure></div>

<p>Javascript 的数组可以动态调整索引：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// 长度变为6，索引0-4为 empty:cite[2]:cite[4]</span></span><br></pre></td></tr></table></figure></div>

<p><code>.length</code> 可以获得数组的长度，<code>.length</code> 也可以被赋值，从而手动截断数组。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="property">length</span> = <span class="number">2</span>;  <span class="comment">// 删除索引2之后的元素</span></span><br></pre></td></tr></table></figure></div>

<p>以下是对数组操作的详细拓展说明，包含方法说明、使用场景和注意事项：</p>
<h3 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h3><h4 id="增（添加元素）"><a href="#增（添加元素）" class="headerlink" title="增（添加元素）"></a>增（添加元素）</h4><ol>
<li><strong><code>push()</code></strong></li>
</ol>
<p>在数组<strong>末尾</strong>添加一个或多个元素</p>
<p>有返回值：返回新数组长度</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">3</span>); <span class="comment">// [1,2,3]</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>, <span class="number">5</span>); <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">push</span>(<span class="number">6</span>)); <span class="comment">// 返回数组总长度 6 [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong><code>unshift()</code></strong></li>
</ol>
<p>在数组<strong>开头</strong>添加一个或多个元素</p>
<p>有返回值：返回新数组长度<br>注意：大数据量时性能较低（需向后移动所有元素）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="number">3</span>); <span class="comment">// [2,3,4]</span></span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [0,1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">push</span>(<span class="number">0</span>)); <span class="comment">// 返回数组总长度 6 [0,1,2,3,4,5]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="删（移除元素）"><a href="#删（移除元素）" class="headerlink" title="删（移除元素）"></a>删（移除元素）</h4><ol>
<li><strong><code>pop()</code></strong></li>
</ol>
<p>移除并返回数组<strong>最后一个元素</strong></p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">pop</span>(); <span class="comment">// 返回3，数组变为[1,2]</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li><strong><code>shift()</code></strong></li>
</ol>
<p>移除并返回数组<strong>第一个元素</strong><br>注意：大数据量时性能较低</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.<span class="title function_">shift</span>(); <span class="comment">// 返回1，数组变为[2,3]</span></span><br></pre></td></tr></table></figure></div>

<h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a><code>splice()</code></h4><p>会直接修改原数组，在任意位置删除、替换或插入元素。</p>
<p><code>splice(起始索引, 要删除的数量, 要添加的元素1, 元素2, ...)</code></p>
<ul>
<li><strong>参数 1</strong>：从哪里开始操作（索引从 0 开始）</li>
<li><strong>参数 2</strong>：要删除多少个元素（填 0 则不删除）</li>
<li><strong>后续参数</strong>：要插入的新元素（可选）</li>
</ul>
<p>删除时返回被删除元素的数组。<br>如果未删除任何元素，则返回空数组。</p>
<h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;西瓜&#x27;</span>, <span class="string">&#x27;橘子&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引1开始，删除2个元素</span></span><br><span class="line"><span class="keyword">let</span> removed = fruits.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits);   <span class="comment">// [&#x27;苹果&#x27;, &#x27;橘子&#x27;]（原数组被修改）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(removed);  <span class="comment">// [&#x27;香蕉&#x27;, &#x27;西瓜&#x27;]（返回被删除的元素）</span></span><br></pre></td></tr></table></figure></div>

<h5 id="替换元素（删除-插入）"><a href="#替换元素（删除-插入）" class="headerlink" title="替换元素（删除+插入）"></a>替换元素（删除+插入）</h5><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;红&#x27;</span>, <span class="string">&#x27;绿&#x27;</span>, <span class="string">&#x27;蓝&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引1开始，删除1个元素，插入2个新元素</span></span><br><span class="line">colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;黄&#x27;</span>, <span class="string">&#x27;紫&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors); <span class="comment">// [&#x27;红&#x27;, &#x27;黄&#x27;, &#x27;紫&#x27;, &#x27;蓝&#x27;]</span></span><br></pre></td></tr></table></figure></div>

<h5 id="插入元素（不删除）"><a href="#插入元素（不删除）" class="headerlink" title="插入元素（不删除）"></a>插入元素（不删除）</h5><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引2开始，删除0个元素，插入3和4</span></span><br><span class="line">numbers.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(numbers); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></div>

<h5 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a>避坑指南</h5><ol>
<li><p><strong>直接修改原数组</strong>：和 <code>slice()</code> 不同，<code>splice()</code> 会改变原数组。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [20, 30]（原数组被修改）</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>负索引</strong>：支持从末尾倒数（类似 Python）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">arr.<span class="title function_">splice</span>(-<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 删除最后一个元素 → [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>不填参数 2 时，默认删到末尾</strong>：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>); <span class="comment">// 从索引1开始删到最后 → [1]</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="改-查（修改-访问元素）"><a href="#改-查（修改-访问元素）" class="headerlink" title="改&#x2F;查（修改&#x2F;访问元素）"></a>改&#x2F;查（修改&#x2F;访问元素）</h4><p>直接索引修改</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;newValue&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p>直接索引访问</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first = arr[<span class="number">0</span>]; <span class="comment">// 首元素</span></span><br><span class="line"><span class="keyword">let</span> last = arr[arr.<span class="property">length</span>-<span class="number">1</span>]; <span class="comment">// 末元素</span></span><br></pre></td></tr></table></figure></div>

<h1 id="JavaScript-函数"><a href="#JavaScript-函数" class="headerlink" title="JavaScript 函数"></a>JavaScript 函数</h1><p>封装代码块，实现 <strong>一次定义 → 重复调用</strong></p>
<p>函数能提升代码复用率、增强代码组织性。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础结构</span></span><br><span class="line"><span class="keyword">function</span> 函数名(参数) &#123;</span><br><span class="line">    <span class="comment">// 执行逻辑</span></span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="函数定义与调用"><a href="#函数定义与调用" class="headerlink" title="函数定义与调用"></a>函数定义与调用</h2><h3 id="命名函数"><a href="#命名函数" class="headerlink" title="命名函数"></a>命名函数</h3><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明式函数（存在函数提升）</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>,<span class="number">3</span>)) <span class="comment">// 调用的函数才会被执行 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当形参与实参不对应</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b) <span class="comment">// 传入(a b) 的参数分别为(10 undefined)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="匿名函数（现代开发高频使用）"><a href="#匿名函数（现代开发高频使用）" class="headerlink" title="匿名函数（现代开发高频使用）"></a>匿名函数（现代开发高频使用）</h3><p>没有名称的函数，通过变量存储使用</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> multiply = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数（简化版）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">divide</span> = (<span class="params">a, b</span>) =&gt; a / b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行函数</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;自动执行!&#x27;</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 立即执行函数会创建独立作用域，避免变量污染</span></span><br></pre></td></tr></table></figure></div>

<p>筛选数组 filter 方法（重点）<br>filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素<br>主要使用场景：筛选数组符合条件的元素，并返回筛选之后元素的新数组<br>语法：</p>
<h1 id="JavaScript-对象"><a href="#JavaScript-对象" class="headerlink" title="JavaScript 对象"></a>JavaScript 对象</h1><p>对象是<strong>无序</strong>的键值对集合，用于存储复杂数据。</p>
<p>声明对象:</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="comment">// 对象的静态数据</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; <span class="comment">// 对象的动态行为</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<h3 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h3><ol>
<li>点号 <code>.</code></li>
</ol>
<p>属性名是合法标识符（如  <code>person.name</code>）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;John&quot;</span></span><br><span class="line">person.<span class="title function_">sayHi</span>(); <span class="comment">// 调用方法</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>方括号 <code>[]</code>（动态属性名）</li>
</ol>
<p>允许动态解析字符串形式的属性名，是遍历时的唯一选择。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[key]); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></div>

<p>可随时添加对象的属性：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">person.<span class="property">job</span> = <span class="string">&quot;Developer&quot;</span>; <span class="comment">// 若存在该属性就更改属性值, 不存在则添加属性</span></span><br></pre></td></tr></table></figure></div>

<h3 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h3><h3 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for...in 循环"></a><code>for...in</code> 循环</h3><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key) <span class="comment">// 输出为 &quot;name&quot;，而非标识符</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, person[key]); <span class="comment">// 因此必须用 [] 访问。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>内置对象是语言<strong>预定义</strong>的工具类对象，无需手动创建，可直接调用其属性和方法，用于处理常见任务（如数学计算、日期操作、数据转换等）。</p>
<h3 id="Math-数学工具"><a href="#Math-数学工具" class="headerlink" title="Math 数学工具"></a>Math 数学工具</h3><p><code>Math</code>  是内置的数学工具集，无需创建实例即可直接使用其方法。</p>
<h4 id="常用方法速查"><a href="#常用方法速查" class="headerlink" title="常用方法速查"></a>常用方法速查</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>Math.random()</code></td>
<td>生成 0~1 之间的随机小数</td>
<td><code>0.123456...</code></td>
</tr>
<tr>
<td><code>Math.floor(x)</code></td>
<td>向下取整（直接砍掉小数）</td>
<td><code>Math.floor(3.9) → 3</code></td>
</tr>
<tr>
<td><code>Math.ceil(x)</code></td>
<td>向上取整</td>
<td><code>Math.ceil(2.1) → 3</code></td>
</tr>
<tr>
<td><code>Math.round(x)</code></td>
<td>四舍五入</td>
<td><code>Math.round(3.4) → 3</code></td>
</tr>
<tr>
<td><code>Math.max(a,b,...)</code></td>
<td>返回多个数中的最大值</td>
<td><code>Math.max(5,9,3) → 9</code></td>
</tr>
<tr>
<td><code>Math.min(a,b,...)</code></td>
<td>返回多个数中的最小值</td>
<td><code>Math.min(5,9,3) → 3</code></td>
</tr>
<tr>
<td><code>Math.pow(x,y)</code></td>
<td>计算 x 的 y 次方</td>
<td><code>Math.pow(2,3) → 8</code></td>
</tr>
</tbody></table>
<h4 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h4><p><strong>生成 [0,1) 随机小数</strong><br><code>Math.random()</code> 是最基础的随机数生成器，后续所有范围扩展都基于此方法。</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="title class_">Math</span>.<span class="title function_">random</span>() <span class="comment">// 0 ≤ r &lt; 1</span></span><br></pre></td></tr></table></figure></div>

<p><strong>生成指定范围的随机整数</strong><br>公式：<code>Math.floor(Math.random() * 总数 + 起始值)</code><br>假设要生成 N 到 M 的整数（包含 N 和 M）：</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getRandom</span>(<span class="params">N, M</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (M - N + <span class="number">1</span>) + N)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：生成1-10的随机整数</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="title function_">getRandom</span>(<span class="number">1</span>, <span class="number">10</span>) <span class="comment">// 可能是1~10中的任意整数</span></span><br></pre></td></tr></table></figure></div>

<h4 id="格式化数字"><a href="#格式化数字" class="headerlink" title="格式化数字"></a>格式化数字</h4><p><strong>保留小数位</strong><br>使用  <code>.toFixed(位数)</code>  方法（返回字符串）</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> price = <span class="number">19.9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(price.<span class="title function_">toFixed</span>(<span class="number">1</span>)) <span class="comment">// &quot;19.9&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(price.<span class="title function_">toFixed</span>(<span class="number">3</span>)) <span class="comment">// &quot;19.900&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>取绝对值</strong><br><code>Math.abs(-5) →5</code></p>
<p><strong>计算平方根</strong><br><code>Math.sqrt(16) →4</code></p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>web前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC 与 MyBatis</title>
    <url>/2025/03/03/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%90%8E%E7%AB%AF/JDBC%20%E4%B8%8E%20MyBatis/</url>
    <content><![CDATA[<p>JDBC 是使用 Java 语言操作关系型数据库的一套 API</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/jdbc-%E4%B8%8E-mybatis/file-20250303170335836.jpg"
                     
                ></p>
<p>sun公司官方定义的一套操作所有关系型数据库的规范，即接口。<br>各个数据库厂商去实现这套接口，提供数据库驱动jar包。<br>我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</p>
<h3 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h3><p>需求：基于JDBc程序，执行update语句（update user set age &#x3D;25 where id &#x3D;1)</p>
<p>步骤：</p>
<ul>
<li>准备工作：创建一个Maven项目，引入依赖；并准备数据库表 user。</li>
<li>代码实现：编写JDBC程序，操作数据库。</li>
</ul>
<p>以下是一个完整的 JDBC 示例代码，用于执行 <code>UPDATE</code> 语句（例如：<code>update user set age =25 where id =1</code>）。代码中包含了 Maven 项目的依赖引入和数据库表的创建步骤。</p>
<h3 id="1-项目准备工作"><a href="#1-项目准备工作" class="headerlink" title="1. 项目准备工作"></a>1. 项目准备工作</h3><h4 id="1-1-创建-Maven-项目"><a href="#1-1-创建-Maven-项目" class="headerlink" title="1.1 创建 Maven 项目"></a>1.1 创建 Maven 项目</h4><p>在 IntelliJ IDEA 或 Eclipse 中创建一个 Maven 项目。确保项目结构如下：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   │   └── com.example</span><br><span class="line">│   │       └── Main.java</span><br><span class="line">│   └── resources</span><br><span class="line">├── pom.xml</span><br></pre></td></tr></table></figure></div>

<h4 id="1-2-引入依赖"><a href="#1-2-引入依赖" class="headerlink" title="1.2 引入依赖"></a>1.2 引入依赖</h4><p>在 <code>pom.xml</code> 中添加 MySQL JDBC 驱动依赖：</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- MySQL Connector --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.32<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="1-3-准备数据库表"><a href="#1-3-准备数据库表" class="headerlink" title="1.3 准备数据库表"></a>1.3 准备数据库表</h4><p>确保有以下数据库表 <code>user</code>：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<p>如果需要，可以在 MySQL 中运行以下命令（假设数据库名为 <code>test</code>）：</p>
<div class="code-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE test;</span><br><span class="line"></span><br><span class="line">USE test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">    age <span class="type">INT</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></div>

<h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><h4 id="2-1-编写-JDBC-程序"><a href="#2-1-编写-JDBC-程序" class="headerlink" title="2.1 编写 JDBC 程序"></a>2.1 编写 JDBC 程序</h4><p>在 <code>Main.java</code> 中编写以下代码：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库连接信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>; <span class="comment">// 替换为你的 MySQL 用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;password&quot;</span>; <span class="comment">// 替换为你的 MySQL 密码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 连接数据库并执行更新操作</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(URL, USER, PASSWORD)) &#123;</span><br><span class="line">            <span class="comment">// 创建 SQL 更新语句</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE user SET age = ? WHERE id = ?&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用 PreparedStatement 执行更新</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">                <span class="comment">// 设置参数值</span></span><br><span class="line">                pstmt.setInt(<span class="number">1</span>, <span class="number">25</span>); <span class="comment">// 设置 age =25</span></span><br><span class="line">                pstmt.setInt(<span class="number">2</span>, <span class="number">1</span>);  <span class="comment">// 设置 id=1</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 执行更新</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rowsUpdated</span> <span class="operator">=</span> pstmt.executeUpdate();</span><br><span class="line">                System.out.println(<span class="string">&quot;受影响的行数: &quot;</span> + rowsUpdated);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-代码说明"><a href="#3-代码说明" class="headerlink" title="3. 代码说明"></a>3. 代码说明</h3><ol>
<li><strong>数据库连接</strong>：使用 <code>DriverManager.getConnection</code> 方法连接到 MySQL 数据库。</li>
<li><strong>SQL 语句</strong>：使用 <code>PreparedStatement</code> 预编译 SQL 语句，防止 SQL 注入。</li>
<li><strong>参数绑定</strong>：使用 <code>setInt</code> 方法绑定 <code>age</code> 和 <code>id</code> 的值。</li>
<li><strong>执行更新</strong>：调用 <code>executeUpdate</code> 方法执行更新操作，返回受影响的行数。</li>
</ol>
<h3 id="4-运行程序"><a href="#4-运行程序" class="headerlink" title="4. 运行程序"></a>4. 运行程序</h3><ol>
<li>确保 MySQL 服务器已启动，并且有 <code>test</code> 数据库。</li>
<li>在 <code>Main.java</code> 中运行程序，控制台会输出受影响的行数。</li>
</ol>
<h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h3><ul>
<li>确保 MySQL 驱动版本与数据库版本匹配。</li>
<li>如果需要，可在 <code>pom.xml</code> 中调整 MySQL 驱动版本。</li>
<li>如果使用其他数据库（如 PostgreSQL 或 Oracle），请修改数据库连接 URL 和驱动依赖。</li>
</ul>
<p>希望这段代码对你有帮助！如果需要进一步优化或修改，请告诉我。</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>Http协议 简介</title>
    <url>/2024/12/01/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%90%8E%E7%AB%AF/Http%E5%8D%8F%E8%AE%AE%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="HTTP-概述"><a href="#HTTP-概述" class="headerlink" title="HTTP 概述"></a>HTTP 概述</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/http%E5%8D%8F%E8%AE%AE-%E7%AE%80%E4%BB%8B/file-20241202103720114.jpg"
                     
                ></p>
<p>HTTP 是一种基于请求-响应模型的无状态、文本格式的通信协议, 用于规范互联网上客户端与服务器之间的数据交换.</p>
<ul>
<li>HTTP 基于 TCP&#x2F;IP 协议: 面向连接, 安全.</li>
<li>HTTP 基于请求-响应模型: 一次请求对应一次次响应.</li>
<li>HTTP 是无状态协议: 服务器不会保存客户端的状态信息, 每一次 请求-响应 都是独立的.</li>
</ul>
<blockquote>
<p>HTTP 的无状态使访问速度快, 但多次请求无法共享数据.</p>
</blockquote>
<p>在浏览器中 按下 <code>F12</code> 打开开发者工具, 再点击 <code>Network(网络)</code> 就可清晰地查看到 http 协议的数据传输格式:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/http%E5%8D%8F%E8%AE%AE-%E7%AE%80%E4%BB%8B/file-20241202152358248.jpg"
                     
                ></p>
<p>浏览器向服务器进行请求时, 服务器按照固定的格式进行解析.<br>服务器向浏览器进行响应时, 浏览器按照固定的格式进行解析.</p>
<p>这种固定格式, 就是 HTTP 规定, 接下来将会介绍请求和响应数据的具体格式内容.</p>
<h3 id="HTTP-请求协议"><a href="#HTTP-请求协议" class="headerlink" title="HTTP 请求协议"></a>HTTP 请求协议</h3><p><strong>请求协议</strong>: 浏览器将数据以请求格式发送到服务器. 包括：<strong>请求行、请求头 、请求体</strong><br>请求方式主要有两种:</p>
<p><strong>.1) GET:</strong></p>
<p>请求参数在请求行中, 没有请求体, 安全性较低. GET 请求大小是受限的.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/http%E5%8D%8F%E8%AE%AE-%E7%AE%80%E4%BB%8B/file-20241202153136920.jpg"
                     
                ></p>
<ul>
<li>请求行: 请求数据第一行(请求方法(GET)、资源路径、协议)</li>
</ul>
<div class="code-container" data-rel="Http"><figure class="iseeu highlight http"><table><tr><td class="code"><pre><span class="line">GET(方式为GET) /brand/findAll?name=OPPO&amp;status=1(资源路径) HTTP/1.1(协议)</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>的请求参数</p>

    </div>
    <div class="notel-content">
      <p>请求行的资源路径包含了 GET 的请求参数.<br>例如图中的请求:</p>
<blockquote>
<p>请求路径：&#x2F;brand&#x2F;findAll<br>请求参数：name&#x3D;OPPO&amp;status&#x3D;1</p>
</blockquote>
<p>GET的请求参数是以 <code>key=value</code> 形式出现<br>多个请求参数之间使用<code>&amp;</code>连接<br>请求路径和请求参数之间使用<code>?</code>连接</p>

    </div>
  </div>


<ul>
<li>请求头: 第二行开始, 格式为键值对 key: value.<br>在请求头设置浏览器的一些自身信息和想要响应的形式, 这样服务器在收到信息后，就知道做什么了.</li>
</ul>
<p>常见的 HTTP 请求头有:</p>
<table>
<thead>
<tr>
<th>请求头</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>表示请求的主机名</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器版本。 例如：Chrome 浏览器的标识类似 Mozilla&#x2F;5.0 …Chrome&#x2F;79 ，IE 浏览器的标识类似 Mozilla&#x2F;5.0 (Windows NT …)like Gecko</td>
</tr>
<tr>
<td>Accept</td>
<td>表示浏览器能接收的资源类型，如 text&#x2F;*，image&#x2F;<em>或者</em>&#x2F;*表示所有；</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>表示浏览器可以支持的压缩类型，例如 gzip, deflate 等。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求主体的数据类型</td>
</tr>
<tr>
<td>Content-Length</td>
<td>数据主体的大小（单位：字节）</td>
</tr>
</tbody></table>
<ul>
<li>请求体: POST 请求时, 存放请求参数(GET 请求没有请求体, GET 请求的请求参数在请求行中).</li>
</ul>
<p><strong>.2) POST:</strong></p>
<p>请求参数在请求体中, 安全性较高. POST 请求大小不受限制.</p>
<h3 id="HTTP-响应协议"><a href="#HTTP-响应协议" class="headerlink" title="HTTP 响应协议"></a>HTTP 响应协议</h3><p>响应协议就是响应数据的格式.<br>HTTP 响应与请求类似, 由三部分组成:</p>
<ul>
<li>响应行: 响应数据第一行 (协议版本、状态码、状态描述)</li>
<li>响应头: 第二行开始, 格式为键值对 key: value.</li>
<li>响应体: 响应内容, 如 HTML 页面, 图片, 文件等.</li>
</ul>
<p>状态码大类别主要有:</p>
<ul>
<li>1xx: 响应中-临时状态码, 表示请求已被服务器接收, 继续处理.</li>
<li>2xx: 成功状态码, 表示请求已成功被服务器接收.</li>
<li>3xx: 重定向状态码, 表示请求需要进一步的操作, 如需跳转.</li>
<li>4xx: 客户端错误状态码, 如请求了不存在的页面, 服务器无法响应.</li>
<li>5xx: 服务器错误状态码, 如服务器内程序抛出异常.</li>
</ul>
<p>最常见的响应状态码有:</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>200 <code>OK</code></td>
<td>客户端请求成功.</td>
</tr>
<tr>
<td>404 <code>Not Found</code></td>
<td>服务器找不到客户端所请求的资源.</td>
</tr>
<tr>
<td>500 <code>Internal Server Error</code></td>
<td>服务器内部错误, 无法完成请求.</td>
</tr>
</tbody></table>
<h3 id="HTTP-解析"><a href="#HTTP-解析" class="headerlink" title="HTTP 解析"></a>HTTP 解析</h3><p>HTTP 解析是指把 HTTP 请求和响应数据解析成可读的格式, 方便人类阅读.<br>而 Tomcat 就是一个 HTTP 解析器, 可以把 HTTP 请求和响应数据解析成 HTML 页面, 方便浏览器显示.</p>
<h4 id="Tomcat-简介"><a href="#Tomcat-简介" class="headerlink" title="Tomcat 简介"></a>Tomcat 简介</h4><p>Web 服务器 用于托管网站内容, 也可以处理客户端的请求, 并返回相应的响应.</p>
<p>Tomcat 是一个开源的 Web 服务器软件, 由 Sun 公司开发, 是 Apache HTTP 服务器的一种替代品.<br><a class="link"   href="https://tomcat.apache.org/" >Tomcat 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>Tomcat 作为 Web 服务器, 它可以将 HTTP 请求转换为 servlet 请求, 并调用 servlet 程序处理请求, 然后将 servlet 的响应转换为 HTTP 响应返回给客户端.<br>Tomcat 还可以提供静态内容, 如 HTML, CSS, JavaScript 文件, 图片等.</p>
<blockquote>
<p>Java 语言的三大分支</p>
<ul>
<li>Java SE(Standard Edition): Java 标准版.</li>
<li>Java ME(Micro Edition): Java 微型版.</li>
<li>Java EE(Enterprise Edition): Java 企业版.<br>其中, Java EE 包含 JDBC, JSP, XML, Servlet 等 13 项规范.</li>
</ul>
</blockquote>
<p>Tomcat 支持 JavaEE 中 Servlet&#x2F;JSP 等 少量规范, 因此 Tomcat 被称为轻量级的 Web 容器, Servlet 容器.<br>Servlet 程序需要依赖于 Tomcat 才能运行.</p>
<p>在 Spring Boot 中, 内嵌了 Tomcat 作为 Web 服务器, 可以直接使用.</p>
<h1 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h1><p>BS 架构: (Browser-Server) 是一种客户端-服务器架构, 客户端只需要浏览器即可访问, 应用程序的逻辑和数据都存储在服务器端.</p>
<blockquote>
<p>CS 架构: (Client-Server) 是一种服务器-客户端架构, 需要特别的客户端才可以访问到服务器.</p>
</blockquote>
<p>在 BS 架构中, 客户端向服务器发送请求, 服务器处理请求并返回响应.</p>
<p>HTTP 协议规定了客户端和服务器之间通信的规则.<br>在 SpringBoot 中, 前端控制器 DispatcherServlet 会解析 HTTP 请求, 并将请求封装到一个请求对象中.<br>这个对象称之为 <code>HttpServletRequest</code>.</p>
<p>在 Servlet 中可以借助另一个对象 <code>HttpServletRequest</code> 来设置响应参数.</p>
<p>这里总结两个对象:</p>
<ul>
<li><code>HttpServletRequest</code>: 客户端请求对象, 封装客户端请求信息.</li>
<li><code>HttpServletResponse</code>: 服务器响应对象, 封装服务器响应信息.</li>
</ul>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>传统方式:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ageStr</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Integer.parseInt(ageStr);</span><br><span class="line">        System.out.println(name+<span class="string">&quot;:&quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>SpringBoot 方式:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/simpleParam&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simpleParam</span><span class="params">(String name,Integer age)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(name+<span class="string">&quot;:&quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这就是请求映射路径</p>
<ul>
<li><code>@RequestMapping()</code></li>
</ul>
<p>当此注解写在类上时, 就可作为路径的前缀.</p>
<ol>
<li><h3 id="HTTP-概述-1"><a href="#HTTP-概述-1" class="headerlink" title="HTTP 概述"></a>HTTP 概述</h3></li>
<li><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4></li>
</ol>
<p><strong>HTTP</strong>：Hyper Text Transfer Protocol(超文本传输协议)，规定了浏览器与服务器之间数据传输的规则。</p>
<ul>
<li>http 是互联网上应用最为广泛的一种网络协议</li>
<li>http 协议要求：浏览器在向服务器发送请求数据时，或是服务器在向浏览器发送响应数据时，都必须按照固定的格式进行数据传输</li>
</ul>
<p>如果想知道 http 协议的数据传输格式有哪些，可以打开浏览器，点击<code>F12</code>打开开发者工具，点击<code>Network(网络)</code>来查看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://heuqqdmbyk.feishu.cn/space/api/box/stream/download/asynccode/?code=ODVkNzZlY2I1ODk5MWM4N2Y5NDA4YTcyNWJmMjQwMDJfMEljNXBHSU9sQ1dweFdOQkttUFhQZ2Q1VzNxcEVCckxfVG9rZW46RTZjeGJHMjllb3V3THl4eFFiVmNRRmhHblpmXzE3MzMwNDI1Mjc6MTczMzA0NjEyN19WNA"
                     
                ></p>
<p>浏览器向服务器进行请求时，服务器按照固定的格式进行解析：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://heuqqdmbyk.feishu.cn/space/api/box/stream/download/asynccode/?code=YWNmNDEwY2U1NzUyMGQ3MDg4ZjQxODU5YmY1MjdmZTlfZVFLbjNJUUttbk9nWW1sRXdCOXNwM3d2bmo0Vk1oSW9fVG9rZW46Wlp3T2JhWGpHb0JRcjd4MkF6bWNkVG41bnJoXzE3MzMwNDI1Mjc6MTczMzA0NjEyN19WNA"
                     
                ></p>
<p>服务器向浏览器进行响应时，浏览器按照固定的格式进行解析：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://heuqqdmbyk.feishu.cn/space/api/box/stream/download/asynccode/?code=OWMwMGUzOWFhZTUyNGI0NWIxY2Y4MTNlNzM3NWIyYjdfTDRzTDk1TjNYcFo5c3RvMmVqbGVLd1JNNGdVcWRnNTlfVG9rZW46VWZZRGJxb1kwb2Z5cVl4RGRyNmM4UzFEbktmXzE3MzMwNDI1Mjc6MTczMzA0NjEyN19WNA"
                     
                ></p>
<p>而我们学习 HTTP 协议，就是来学习请求和响应数据的具体格式内容。</p>
<ol start="2">
<li><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4></li>
</ol>
<p>我们刚才初步认识了 HTTP 协议，那么我们在看看 HTTP 协议有哪些特点：</p>
<ul>
<li><strong>基于 TCP 协议:</strong> 面向连接，安全</li>
</ul>
<blockquote>
<p>TCP 是一种面向连接的(建立连接之前是需要经过三次握手)、可靠的、基于字节流的传输层通信协议，在数据传输方面更安全</p>
</blockquote>
<ul>
<li><strong>基于请求-响应模型:</strong> 一次请求对应一次响应（先请求后响应）</li>
</ul>
<blockquote>
<p>请求和响应是一一对应关系，没有请求，就没有响应</p>
</blockquote>
<ul>
<li><strong>HTTP 协议是无状态协议:</strong> 对于数据没有记忆能力。每次请求-响应都是独立的</li>
</ul>
<blockquote>
<p>无状态指的是客户端发送 HTTP 请求给服务端之后，服务端根据请求响应数据，响应完后，不会记录任何信息。</p>
<ul>
<li><p>缺点: 多次请求间不能共享数据</p>
</li>
<li><p>优点: 速度快</p>
</li>
<li><p>请求之间无法共享数据会引发的问题：</p>
<ul>
<li>如：京东购物。加入购物车和去购物车结算是两次请求</li>
<li>由于 HTTP 协议的无状态特性，加入购物车请求响应结束后，并未记录加入购物车是何商品</li>
<li>发起去购物车结算的请求后，因为无法获取哪些商品加入了购物车，会导致此次请求无法正确展示数据</li>
</ul>
</li>
<li><p>具体使用的时候，我们发现京东是可以正常展示数据的，原因是 Java 早已考虑到这个问题，并提出了使用会话技术(Cookie、Session)来解决这个问题。具体如何来做，我们后面课程中会讲到。</p>
</li>
</ul>
</blockquote>
<p>刚才提到 HTTP 协议是规定了请求和响应数据的格式，那具体的格式是什么呢? 接下来，我们就来详细剖析。</p>
<p>HTTP 协议又分为：请求协议和响应协议</p>
<ol start="2">
<li><h3 id="HTTP-请求协议-1"><a href="#HTTP-请求协议-1" class="headerlink" title="HTTP 请求协议"></a>HTTP 请求协议</h3></li>
<li><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4></li>
</ol>
<ul>
<li><p><strong>请求协议：</strong>浏览器将数据以请求格式发送到服务器。包括：<strong>请求行、请求头 、请求体</strong></p>
</li>
<li><p><strong>GET 方式的请求协议：</strong></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://heuqqdmbyk.feishu.cn/space/api/box/stream/download/asynccode/?code=MWIyNTA2MTczOGQ1OWI0ODAyYWI4NTA5NzMyYTNjMjNfdVlMSktwYWVjUTRWYzRnWDNmQWxKNUM2MDNzdDNEMHpfVG9rZW46WEpzSmJIMFBQbzFhR3V4MGwxeWNYdnlwblFkXzE3MzMwNDI1Mjc6MTczMzA0NjEyN19WNA"
                     
                ></p>
<ul>
<li><strong>请求行</strong>(以上图中红色部分) ：HTTP 请求中的第一行数据。由：<code>请求方式</code>、<code>资源路径</code>、<code>协议/版本</code>组成（之间使用空格分隔）<ul>
<li>请求方式：GET</li>
<li>资源路径：&#x2F;brand&#x2F;findAll?name&#x3D;OPPO&amp;status&#x3D;1<ul>
<li>请求路径：&#x2F;brand&#x2F;findAll</li>
<li>请求参数：name&#x3D;OPPO&amp;status&#x3D;1<ul>
<li>请求参数是以 key&#x3D;value 形式出现</li>
<li>多个请求参数之间使用<code>&amp;</code>连接</li>
</ul>
</li>
<li>请求路径和请求参数之间使用<code>?</code>连接</li>
</ul>
</li>
<li>协议&#x2F;版本：HTTP&#x2F;1.1</li>
</ul>
</li>
<li><strong>请求头</strong>(以上图中黄色部分) ：第二行开始，上图黄色部分内容就是请求头。格式为 key: value 形式<ul>
<li>http 是个无状态的协议，所以在请求头设置浏览器的一些自身信息和想要响应的形式。这样服务器在收到信息后，就可以知道是谁，想干什么了</li>
<li>常见的 HTTP 请求头有:<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>请求头</td>
<td>含义</td>
</tr>
<tr>
<td>Host</td>
<td>表示请求的主机名</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器版本。 例如：Chrome 浏览器的标识类似 Mozilla&#x2F;5.0 …Chrome&#x2F;79 ，IE 浏览器的标识类似 Mozilla&#x2F;5.0 (Windows NT …)like Gecko</td>
</tr>
<tr>
<td>Accept</td>
<td>表示浏览器能接收的资源类型，如 text&#x2F;*，image&#x2F;<em>或者</em>&#x2F;*表示所有；</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>表示浏览器可以支持的压缩类型，例如 gzip, deflate 等。</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求主体的数据类型</td>
</tr>
<tr>
<td>Content-Length</td>
<td>数据主体的大小（单位：字节）</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>举例说明：服务端可以根据请求头中的内容来获取客户端的相关信息，有了这些信息服务端就可以处理不同的业务需求。</p>
<p>比如:</p>
<ul>
<li>不同浏览器解析 HTML 和 CSS 标签的结果会有不一致，所以就会导致相同的代码在不同的浏览器会出现不同的效果</li>
<li>服务端根据客户端请求头中的数据获取到客户端的浏览器类型，就可以根据不同的浏览器设置不同的代码来达到一致的效果（这就是我们常说的浏览器兼容问题）</li>
</ul>
</blockquote>
<ul>
<li>请求体 ：存储请求参数<ul>
<li>GET 请求的请求参数在请求行中，故不需要设置请求体</li>
</ul>
</li>
</ul>
<p><strong>POST 方式的请求协议：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://heuqqdmbyk.feishu.cn/space/api/box/stream/download/asynccode/?code=YTBhZDM4MjQ3Mjg3NzViNzQ3MjQ5NjIwMTkyZWI5ZjRfYmRSWHpDNU5mY0lXN1RpN0thZXVuY2dVY3pVdkFsUk9fVG9rZW46T1J4bWJtWlJWb0szMXl4blVOb2NkNlpKbkFnXzE3MzMwNDI1Mjc6MTczMzA0NjEyN19WNA"
                     
                ></p>
<ul>
<li><strong>请求行</strong>(以上图中红色部分)：包含请求方式、资源路径、协议&#x2F;版本<ul>
<li>请求方式：POST</li>
<li>资源路径：&#x2F;brand</li>
<li>协议&#x2F;版本：HTTP&#x2F;1.1</li>
</ul>
</li>
<li><strong>请求头</strong>(以上图中黄色部分)</li>
<li><strong>请求体</strong>(以上图中绿色部分) ：存储请求参数<ul>
<li>请求体和请求头之间是有一个空行隔开（作用：用于标记请求头结束）</li>
</ul>
</li>
</ul>
<p>GET 请求和 POST 请求的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>区别方式</strong></td>
<td><strong>GET 请求</strong></td>
<td><strong>POST 请求</strong></td>
</tr>
<tr>
<td>请求参数</td>
<td>请求参数在请求行中。<br/>例：&#x2F;brand&#x2F;findAll?name&#x3D;OPPO&amp;status&#x3D;1</td>
<td>请求参数在请求体中</td>
</tr>
<tr>
<td>请求参数长度</td>
<td>请求参数长度有限制(浏览器不同限制也不同)</td>
<td>请求参数长度没有限制</td>
</tr>
<tr>
<td>安全性</td>
<td>安全性低。原因：请求参数暴露在浏览器地址栏中。</td>
<td>安全性相对高</td>
</tr>
</tbody></table>
<ol start="2">
<li><h4 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h4></li>
</ol>
<p>Web 服务器（Tomcat）对 HTTP 协议的请求数据进行解析，并进行了封装(HttpServletRequest)，并在调用 Controller 方法的时候传递给了该方法。这样，就使得程序员不必直接对协议进行操作，让 Web 开发更加便捷。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://heuqqdmbyk.feishu.cn/space/api/box/stream/download/asynccode/?code=YTIyYTBkMWZmYzM3NTFlYjIxNTVmZDJjNmMyMWE4NmZfa3VqRktYaWtFcUt0RWZoSWF3RWx6QVY2WFNXcjBwUXJfVG9rZW46SzFwdGJzMnEzb3dhZkJ4c2xKRmNGWkd2blZmXzE3MzMwNDI1Mjc6MTczMzA0NjEyN19WNA"
                     
                ></p>
<p>代码演示如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求路径 http://localhost:8080/request?name=Tom&amp;age=18</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/request&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="comment">//1.获取请求参数 name, age</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">age</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取请求路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getRequestURL().toString();</span><br><span class="line">        System.out.println(<span class="string">&quot;uri = &quot;</span> + uri);</span><br><span class="line">        System.out.println(<span class="string">&quot;url = &quot;</span> + url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取请求方式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;method = &quot;</span> + method);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取请求头</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;User-Agent&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;header = &quot;</span> + header);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;request success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>最终输出内容如下所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://heuqqdmbyk.feishu.cn/space/api/box/stream/download/asynccode/?code=NjFkYTExNzNjNjIwYTQyMDcyZjRlZDM3YjFjOTI4ZmJfMXRIVHpPUEJUZmdrTW52aXIxaFphR25ud0V3VVRiTXRfVG9rZW46TW9TamJQNnlHb0l2NWd4cGVlYmM0a3JYbkIyXzE3MzMwNDI1Mjc6MTczMzA0NjEyN19WNA"
                     
                ></p>
<ol start="3">
<li><h3 id="HTTP-响应协议-1"><a href="#HTTP-响应协议-1" class="headerlink" title="HTTP 响应协议"></a>HTTP 响应协议</h3></li>
<li><h4 id="格式介绍"><a href="#格式介绍" class="headerlink" title="格式介绍"></a>格式介绍</h4></li>
</ol>
<ul>
<li>响应协议：服务器将数据以响应格式返回给浏览器。包括：<strong>响应行 、响应头 、响应体</strong></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://heuqqdmbyk.feishu.cn/space/api/box/stream/download/asynccode/?code=OTVmZmVjNzMxNjhjNjZlZjg2YTZlN2JhYjRmNjUzZWFfTHJpYjhJQnI2TWJyOW5EaldOMHFjOXhxVXNOdHVxYkxfVG9rZW46RjRCbGJWMVA2b1V0TmR4ODVHWmNEbktabktlXzE3MzMwNDI1Mjc6MTczMzA0NjEyN19WNA"
                     
                ></p>
<ul>
<li><p>响应行(以上图中红色部分)：响应数据的第一行。响应行由<code>协议及版本</code>、<code>响应状态码</code>、<code>状态码描述</code>组成</p>
<ul>
<li>协议&#x2F;版本：HTTP&#x2F;1.1</li>
<li>响应状态码：200</li>
<li>状态码描述：OK</li>
</ul>
</li>
<li><p>响应头(以上图中黄色部分)：响应数据的第二行开始。格式为 key：value 形式</p>
<ul>
<li>http 是个无状态的协议，所以可以在请求头和响应头中设置一些信息和想要执行的动作，这样，对方在收到信息后，就可以知道你是谁，你想干什么</li>
<li>常见的 HTTP 响应头有:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Content-Type：表示该响应内容的类型，例如text/html，image/jpeg ；</span><br><span class="line"></span><br><span class="line">Content-Length：表示该响应内容的长度（字节数）；</span><br><span class="line"></span><br><span class="line">Content-Encoding：表示该响应压缩算法，例如gzip ；</span><br><span class="line"></span><br><span class="line">Cache-Control：指示客户端应如何缓存，例如max-age=<span class="number">300</span>表示可以最多缓存<span class="number">300</span>秒 ;</span><br><span class="line"></span><br><span class="line">Set-Cookie: 告诉浏览器为当前页面所在的域设置cookie ;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>响应体(以上图中绿色部分)： 响应数据的最后一部分。存储响应的数据</p>
<ul>
<li>响应体和响应头之间有一个空行隔开（作用：用于标记响应头结束）</li>
</ul>
</li>
</ul>
<ol start="2">
<li><h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4></li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>状态码分类</td>
<td>说明</td>
</tr>
<tr>
<td>1xx</td>
<td>响应中 — 临时状态码。表示请求已经接受，告诉客户端应该继续请求或者如果已经完成则忽略</td>
</tr>
<tr>
<td>2xx</td>
<td>成功 — 表示请求已经被成功接收，处理已完成</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向 — 重定向到其它地方，让客户端再发起一个请求以完成整个处理</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端错误 — 处理发生错误，责任在客户端，如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器端错误 — 处理发生错误，责任在服务端，如：服务端抛出异常，路由出错，HTTP 版本不支持等</td>
</tr>
</tbody></table>
<p>关于响应状态码，我们先主要认识三个状态码，其余的等后期用到了再去掌握：</p>
<ul>
<li><code>200 ok</code> 客户端请求成功</li>
<li><code>404 Not Found</code> 请求资源不存在</li>
<li><code>500 Internal Server Error</code> 服务端发生不可预期的错误</li>
</ul>
<ol start="3">
<li><h4 id="设置响应数据"><a href="#设置响应数据" class="headerlink" title="设置响应数据"></a>设置响应数据</h4></li>
</ol>
<p>Web 服务器对 HTTP 协议的响应数据进行了封装(HttpServletResponse)，并在调用 Controller 方法的时候传递给了该方法。这样，就使得程序员不必直接对协议进行操作，让 Web 开发更加便捷。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://heuqqdmbyk.feishu.cn/space/api/box/stream/download/asynccode/?code=YmMwMjMxNDc2ZDAyYmM3ODlkOTc1YWIxZjk3M2I0YzhfYzU3RThneUVPNVpjdWlZZDFzZzhkRmZ2V0E3S0xxWjZfVG9rZW46UU9kdGJBc210b2pSakR4UFBjQmNQQ29ZbmxiXzE3MzMwNDI1Mjc6MTczMzA0NjEyN19WNA"
                     
                ></p>
<p>代码演示：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jakarta.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/response&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.设置响应状态码</span></span><br><span class="line">        response.setStatus(<span class="number">401</span>);</span><br><span class="line">        <span class="comment">//2.设置响应头</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        <span class="comment">//3.设置响应体</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&lt;h1&gt;hello response&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/response2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title function_">response2</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity</span><br><span class="line">                .status(<span class="number">401</span>)</span><br><span class="line">                .header(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;itcast&quot;</span>)</span><br><span class="line">                .body(<span class="string">&quot;&lt;h1&gt;hello response&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>浏览器访问测试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://heuqqdmbyk.feishu.cn/space/api/box/stream/download/asynccode/?code=ODYyYzNmNDQ2NTQ5ZGE1ZjI5N2I3MGRjZWQxYjg4NGZfd0VFSk5qcUtEYjB0WVpGMDZSbzJFVlFRZDBNcmpVM3pfVG9rZW46UEFmM2J3d1pCbzNBdEt4cHBZQ2NIMWZTbnBoXzE3MzMwNDI1Mjc6MTczMzA0NjEyN19WNA"
                     
                ></p>
<p>响应状态码 和 响应头如果没有特殊要求的话，通常不手动设定。服务器会根据请求处理的逻辑，自动设置响应状态码和响应头。</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>网页之骨架-HTML</title>
    <url>/2023/09/17/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%89%8D%E7%AB%AF/%E7%BD%91%E9%A1%B5%E4%B9%8B%E9%AA%A8%E6%9E%B6-HTML/</url>
    <content><![CDATA[<h1 id="HTML-定义"><a href="#HTML-定义" class="headerlink" title="HTML 定义"></a>HTML 定义</h1><p>HTML 超文本标记语言 ———— HyperText Markup Language</p>
<blockquote>
<p>超文本: 除了文字信息, 还可以定义图片、音频、视频等内容。比普通文本更强大。<br>标记语言: 由标签 <code>&lt;标签名&gt;</code> 构成的语言。</p>
</blockquote>
<p>HTML 语法相对比较松散，即使多多少少点字符也有可能达到预期的效果。</p>
<p>不过为了严谨性，HTML 还是有一些默认的规则：</p>
<ul>
<li>HTML 标签不区分大小写，建议小写</li>
<li>HTML 标签的属性值，采用单引号、双引号都可以，一般写双引号</li>
</ul>
<h3 id="HTML-基本骨架"><a href="#HTML-基本骨架" class="headerlink" title="HTML 基本骨架"></a>HTML 基本骨架</h3><div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span> <span class="comment">&lt;!-- 文档类型(document type)的声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span> <span class="comment">&lt;!-- 整个HTML文档 --&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="comment">&lt;!-- 文档头部, 存放给浏览器看的信息 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- meta标签用来描述一个HTML文档的属性,关键词等 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 例如 `charset=&quot;UTF-8&quot;` 是指当前使用 &quot;UTF-8&quot; 编码格式.  --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span> <span class="comment">&lt;!-- 是head标签中唯一必须要包含的东西 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 好的title有利于SEO优化, 好的SEO有助于在搜索引擎中优化排名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span> <span class="comment">&lt;!-- 主体,存放给用户看的信息,例如图片、文字 --&gt;</span></span><br><span class="line">		网页主体内容</span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在 <code>VS Code</code> 中，可以按 <code>！+ Tab</code> 生成 HTML 的基本骨架.</p>
</blockquote>
<h1 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h1><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><p>HTML 标签是预定义好的, 其都有自己的含义与效果.</p>
<p>h1~h6(双标签)</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>二级标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>四级标题<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>五级标题<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>六级标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>注意不要仅仅是为了生成粗体或大号的文本而使用标题, 正确使用标题有益于 SEO.</p>
<h3 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h3><table>
<thead>
<tr>
<th>格式</th>
<th>常规</th>
<th>缩写</th>
</tr>
</thead>
<tbody><tr>
<td><strong>加粗</strong></td>
<td><code>&lt;strong&gt;</code></td>
<td><code>&lt;b&gt;</code></td>
</tr>
<tr>
<td><em>倾斜</em></td>
<td><code>&lt;em&gt;</code></td>
<td><code>&lt;i&gt;</code></td>
</tr>
<tr>
<td><u>下划线<u></td>
<td><code>&lt;ins&gt;</code></td>
<td><code>&lt;u&gt;</code></td>
</tr>
<tr>
<td><del>删除线</del></td>
<td><code>&lt;del&gt; </code></td>
<td><code>&lt;s&gt;</code></td>
</tr>
</tbody></table>
<h3 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h3><p>能在网页中显示预留字符</p>
<table>
<thead>
<tr>
<th>显示结果</th>
<th>描述</th>
<th>实体名称</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>空格</td>
<td><code>&amp;nbsp;</code></td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td><code>&amp;lt;</code></td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td><code>&amp;gt;</code></td>
</tr>
</tbody></table>
<h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><h4 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h4><p>p 标签用于定义段落：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="换行标签"><a href="#换行标签" class="headerlink" title="换行标签"></a>换行标签</h4><p>br 标签用于在不产生新段落的情况下进行换行：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">这是第一行<span class="tag">&lt;<span class="name">br</span>/&gt;</span>这是第二行</span><br></pre></td></tr></table></figure></div>

<h4 id="水平线标签"><a href="#水平线标签" class="headerlink" title="水平线标签"></a>水平线标签</h4><p>hr 标签用于插入一条水平线，常用于分隔内容：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>上面的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>下面的内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span> <span class="attr">color</span>=<span class="string">&quot;颜色&quot;</span> <span class="attr">width</span>=<span class="string">&quot;宽度&quot;</span> <span class="attr">size</span>=<span class="string">&quot;高度&quot;</span> <span class="attr">align</span>=<span class="string">&quot;对齐方式 默认居中, 可取值left|right&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><p>超链接是双标签,格式如下</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;超链接&quot;</span>&gt;</span>显示的文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;音频路径&quot;</span> <span class="attr">controls</span> <span class="attr">loop</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;视频路径&quot;</span> <span class="attr">controls</span> &gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>图片<code>&lt;img&gt;</code>是单标签, 格式如下</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片路径&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图像的替代文本&quot;</span> <span class="attr">title</span>=<span class="string">&quot;鼠标悬停时显示的文本&quot;</span> <span class="attr">width</span>=<span class="string">&quot;宽度&quot;</span> <span class="attr">height</span>=<span class="string">&quot;高度&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>alt 属性提供了图片的替代文本，对于无障碍访问和 SEO 都很重要。</p>
<p>图片路径可以是本地也可以来自网络的 url。</p>
<h4 id="路径表示"><a href="#路径表示" class="headerlink" title="路径表示"></a>路径表示</h4><p>在引入图片、视频、音频、css 等内容时, 我们需要指定文件的路径, 而在前端开发中，路径的书写形式分为两类：</p>
<ul>
<li>绝对路径<ul>
<li>绝对磁盘路径</li>
<li>绝对网络路径
  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>URL</p>

    </div>
    <div class="notel-content">
      <p>URL（Uniform Resource Locator）是统一资源定位符的缩写，它是用于定位互联网上资源的标准化地址，能告诉浏览器在哪里可以找到特定的网页或其他在线资源。</p>

    </div>
  </div></li>
</ul>
</li>
<li>相对路径<ul>
<li><code>./</code> : 当前目录(可省略)</li>
<li><code>../</code> : 上一级目录</li>
</ul>
</li>
</ul>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol>
<li>无序列表:</li>
</ol>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><code>&lt;ul type=&quot; &quot;&gt;</code> 可选项:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>type=&quot;disc&quot;</code></td>
<td>实心圆(默认)</td>
</tr>
<tr>
<td><code>type=&quot;circle&quot;</code></td>
<td>空心圆</td>
</tr>
<tr>
<td><code>type=&quot;square&quot;</code></td>
<td>小方块</td>
</tr>
<tr>
<td><code>type=&quot;none&quot;</code></td>
<td>不显示</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&quot;list-style-type: disc;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>实心圆（默认）<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&quot;list-style-type: circle;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>空心圆<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&quot;list-style-type: square;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>小方块<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&quot;list-style-type: none;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>不显示<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">2. 有序列表:</span><br><span class="line"></span><br><span class="line">```HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一步<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二步<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><code>&lt;ol type=&quot; &quot;&gt;</code> 可选项:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>type=&quot;1&quot;</code></td>
<td>数字标号</td>
</tr>
<tr>
<td><code>type=&quot;a/A&quot;</code></td>
<td>大小写字母标号</td>
</tr>
<tr>
<td><code>type=&quot;i/I&quot;</code></td>
<td>大小写罗马数字</td>
</tr>
</tbody></table>
<blockquote>
<p>快速生成 ul+li 布局: <code>ul&gt;li*n</code> (根据需要的 li 数修改 n 的值)</p>
</blockquote>
<ol>
<li>定义列表:</li>
</ol>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>列表标题<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>列表描述1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>列表描述2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>table 标签用于创建表格：</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表头2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>行1，列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>行2，列2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>th 用于表头单元格，td 用于普通单元格。</p>
<p>使用<code>border</code>属性可以为表格添加边框线<br>跨行合并 属性值<code>rowspan</code><br>跨列合并 属性值<code>colspan</code></p>
<blockquote>
<p>快速生成表格结构: <code>table&gt;tr*行数&gt;td&#123;单元格内容&#125;</code></p>
</blockquote>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>表单在 Web 网页中用来给用户填写信息, 填写的信息最终会保存在数据库中.</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;服务器地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get|post&quot;</span> <span class="attr">name</span>=<span class="string">&quot;表单名称&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>表单标签: <code>&lt;form&gt;</code></li>
<li>表单属性:<ul>
<li><code>action</code> : 规定表单向何处发送表单数据, 表单提交的 URL.</li>
<li><code>method</code> : 规定用于发送表单数据的方式, 有以下两种.<ul>
<li><code>GET</code> : 数据是拼接在 url 后面的, 如: xx?username&#x3D;Tom&amp;age&#x3D;12，url 中能携带的表单数据大小是有限制的。</li>
<li><code>POST</code> : 表单数据是在请求体（消息体）中携带的.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>一个完整的表单包含三个基本元素:</p>
<ul>
<li>表单标签</li>
<li>表单域</li>
<li>表单按钮</li>
</ul>
<p>常见的表单示例:</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    form表单属性:</span></span><br><span class="line"><span class="comment">        action: 表单提交的url, 往何处提交数据 . 如果不指定, 默认提交到当前页面</span></span><br><span class="line"><span class="comment">        method: 表单的提交方式 .</span></span><br><span class="line"><span class="comment">            get: 在url后面拼接表单数据, 比如: ?username=Tom&amp;age=12 , url长度有限制 . 默认值</span></span><br><span class="line"><span class="comment">            post: 在消息体(请求体)中传递的, 参数大小无限制的.</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">        用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        年龄: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h3><h4 id="1-input-标签"><a href="#1-input-标签" class="headerlink" title="1. input 标签"></a>1. input 标签</h4><div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;...&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>type 属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>type = &quot;text&quot;</code></td>
<td>文本框,用于单行文本</td>
</tr>
<tr>
<td><code>type = &quot;password &quot;</code></td>
<td>密码框</td>
</tr>
<tr>
<td><code>type = &quot;radio &quot;</code></td>
<td>单选框</td>
</tr>
<tr>
<td><code>type = &quot;checkbox&quot;</code></td>
<td>多选框</td>
</tr>
<tr>
<td><code>type = &quot;file&quot;</code></td>
<td>上传文件</td>
</tr>
</tbody></table>
<ul>
<li>text 和 password<br>使用属性值 palceholder 能添加占位文本提示信息</li>
<li>radio<br>默认单选框没有单选功能<br>使用 <code>name</code> 属性值设置相同名称能达到<strong>单选</strong>效果<br>使用 <code>checked</code> 属性值默认选中 (多选也可)</li>
<li>file<br>添加 <code>multiple</code> 属性实现文件多选功能</li>
</ul>
<h4 id="2-下拉菜单"><a href="#2-下拉菜单" class="headerlink" title="2. 下拉菜单"></a>2. 下拉菜单</h4><div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>option 中使用 selected 属性值 默认选中一个 option</p>
<h4 id="3-文本域标签"><a href="#3-文本域标签" class="headerlink" title="3. 文本域标签"></a>3. 文本域标签</h4><div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span>提示文本<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>多行输入时使用文本域.</p>
<h4 id="4-label-标签"><a href="#4-label-标签" class="headerlink" title="4. label 标签"></a>4. label 标签</h4><p><strong>写法一:</strong><br>label 标签包裹内容<br>再设置 for 属性值,和表单控件的 id 属性值相同.</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;radio&quot;</span> <span class="attr">id</span> =<span class="string">&quot;man&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span> = <span class="string">&quot;man&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>写法二:</strong><br>不使用属性直接包裹文字和表单控件.</p>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;radio&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>使用 label 标签增大表单控制范围</p>
<h4 id="5-按钮"><a href="#5-按钮" class="headerlink" title="5. 按钮"></a>5. 按钮</h4><div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span>按钮名称<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>type 属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>submi</td>
<td>提交</td>
</tr>
<tr>
<td>reset</td>
<td>重置</td>
</tr>
<tr>
<td>button</td>
<td>默认无功能(配合 js 使用)</td>
</tr>
</tbody></table>
<h2 id="无语义布局标签"><a href="#无语义布局标签" class="headerlink" title="无语义布局标签"></a>无语义布局标签</h2><p>用来布局网页,划分区域,摆放内容</p>
<ul>
<li>div</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>div标签,独占一行<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>span</li>
</ul>
<div class="code-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>span标签,不换行<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>HTML5 新增标签</li>
</ul>
<p>HTML5 是 HTML 最新的修订版本, HTML5 新增了很多新的语义化标签.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%BD%91%E9%A1%B5%E4%B9%8B%E9%AA%A8%E6%9E%B6-html/file-20241124152429941.jpg"
                     
                ></p>
<table>
<thead>
<tr>
<th>标签</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;header&gt;&lt;/header&gt;</code></td>
<td>头部</td>
</tr>
<tr>
<td><code>&lt;nav&gt;&lt;/nav&gt;</code></td>
<td>导航</td>
</tr>
<tr>
<td><code>&lt;section&gt;&lt;/section&gt;</code></td>
<td>定义文档中的节, 比如章节, 页眉, 页脚</td>
</tr>
<tr>
<td><code>&lt;aside&gt;&lt;/aside&gt;</code></td>
<td>侧边栏</td>
</tr>
<tr>
<td><code>&lt;footer&gt;&lt;/footer&gt;</code></td>
<td>脚部</td>
</tr>
<tr>
<td><code>&lt;article&gt;&lt;/article&gt;</code></td>
<td>代表一个独立的, 完整的相关内容块, 例如一篇完整的论坛帖子, 一篇博客文章, 一个用户评论等</td>
</tr>
</tbody></table>
<h4 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h4><p>常见内联元素(行内元素)</p>
<blockquote>
<p>a、b、em、i、span、strong 等</p>
</blockquote>
<ul>
<li>行内元素不会独占页面中的一整行</li>
<li>设置<code>width</code>,<code>height</code>属性无效</li>
<li>一般内联元素不包含块级元素</li>
</ul>
<h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4><p>常见块级元素</p>
<blockquote>
<p>div、form、h1~h6、hr、p、table、ul、等</p>
</blockquote>
<ul>
<li>块元素会在页面中独占一行</li>
<li>可以设置<code>width</code>, <code>height</code>属性</li>
<li>⼀般块级元素可以包含行内元素和其他块级元<br>素</li>
</ul>
<h4 id="行内块级元素"><a href="#行内块级元素" class="headerlink" title="行内块级元素"></a>行内块级元素</h4><p>不换行、能够识别宽高</p>
<blockquote>
<p>button、img、input 等</p>
</blockquote>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>web前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>更改 Node.js 的默认镜像源</title>
    <url>/2024/04/29/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%90%8E%E7%AB%AF/Node-js%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Node-js-概述"><a href="#Node-js-概述" class="headerlink" title="Node.js 概述"></a>Node.js 概述</h1><p>在 Node.js 出现之前, JavaScript 主要用于网页上浏览器, 处理客户端的交互逻辑.<br>而 Node.js 使得 JavaScript 也能够用于服务器端编程, 处理如数据库操作, 网络请求等后端任务.</p>
<p>Node.js 附带了 <code>npm</code> (Node Package Manager) 中文意为“Node 包管理器”.<br>它是 JavaScript 编程语言的一个包管理器, 也这是世界上最大的开源库生态系统. 开发者可以轻松地共享和使用他人开发的包, 加速了开发过程. </p>
<blockquote>
<p>开源 (Open Source)<br>是一种软件发布模式，其中软件的源代码 (即编写程序的原始代码) 对所有人都是可用的.<br>任何人都可以查看、修改和增强源代码, 并且通常可以在遵守特定许可证的条件下自由地分享和分发软件.</p>
</blockquote>
<h1 id="下载并安装-Node-js"><a href="#下载并安装-Node-js" class="headerlink" title="下载并安装 Node.js"></a>下载并安装 Node.js</h1><p><a class="link"   href="https://nodejs.org/" >Node.js 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>LTS (Long Term Support) 代表 “长期支持”, 通常比较稳定.</p>
<p>Current 通常指的是软件的最新版本, 它可能包含最新的功能, 改进和修复.</p>
<p>点击官网的下载按钮开始下载.</p>
<p>下载完成后, 无脑下一步–&gt;下一步–&gt;安装即可.</p>
<p>安装完成后, 在cmd中输入如下指令查看安装版本.</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line"></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/cmd.jpg"
                      alt="alt text"
                ></p>
<p>如果看到正确的版本号, 即为安装成功!</p>
<h1 id="配置-Node-js"><a href="#配置-Node-js" class="headerlink" title="配置 Node.js"></a>配置 Node.js</h1><p>更改默认镜像源</p>
<p>查看当前镜像源</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm get registry</span><br></pre></td></tr></table></figure></div>

<p>修改为淘宝的镜像源  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/cmd2.jpg"
                      alt="alt text"
                ></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com/</span><br></pre></td></tr></table></figure></div>

<p>再次查看当前镜像源, 即为修改成功.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/Node.js%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/Wreckloud%2024%E5%B9%B404%E6%9C%8829%E6%97%A5%2022%E6%97%B619%E5%88%8613%E7%A7%92.jpg"
                      alt="alt text"
                ></p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>指南</tag>
        <tag>Java 后端</tag>
        <tag>后端技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JUnit-单元测试插件</title>
    <url>/2024/11/29/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%90%8E%E7%AB%AF/JUnit-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>测试是一种用来促进鉴定软件的正确性, 完整性, 安全性和质量的过程, 测试分为四个阶段.</p>
<p>1). 单元测试</p>
<ul>
<li><p>介绍：对软件的基本组成单位进行测试，最小测试单位。</p>
</li>
<li><p>目的：检验软件基本组成单位的正确性。</p>
</li>
<li><p>测试人员：开发人员</p>
<p>2). 集成测试</p>
</li>
<li><p>介绍：将已分别通过测试的单元，按设计要求组合成系统或子系统，再进行的测试。</p>
</li>
<li><p>目的：检查单元之间的协作是否正确。</p>
</li>
<li><p>测试人员：开发人员</p>
<p>3). 系统测试</p>
</li>
<li><p>介绍：对已经集成好的软件系统进行彻底的测试。</p>
</li>
<li><p>目的：验证软件系统的正确性、性能是否满足指定的要求。</p>
</li>
<li><p>测试人员：测试人员</p>
<p>4). 验收测试</p>
</li>
<li><p>介绍：交付测试，是针对用户需求、业务流程进行的正式的测试。</p>
</li>
<li><p>目的：验证软件系统是否满足验收标准。</p>
</li>
<li><p>测试人员：客户&#x2F;需求方</p>
</li>
</ul>
<h3 id="常见测试方法"><a href="#常见测试方法" class="headerlink" title="常见测试方法"></a>常见测试方法</h3><p>测试方法有以下三种: 白盒测试、黑盒测试 及 灰盒测试.</p>
<p>1). 白盒测试</p>
<p>清楚软件内部结构, 代码逻辑.<br>用于验证代码, 逻辑正确性.</p>
<p>2). 黑盒测试</p>
<p>不清楚软件内部结构, 代码逻辑.<br>用于验证软件的功能, 兼容性, 验收测试等方面.</p>
<p>3). 灰盒测试</p>
<p>结合了白盒测试和黑盒测试的特点, 既关注软件的内部结构又考虑外部表现 (功能).</p>
<h1 id="JUnit-入门"><a href="#JUnit-入门" class="headerlink" title="JUnit 入门"></a>JUnit 入门</h1><p>JUnit 是最流行的 Java 测试框架之一, 提供了一些功能, 方便程序进行单元测试.</p>
<p>之前学习 Java 的过程中, 我们都是在 main 方法中进行测试.<br>这种方式虽然可以进行测试, 但是有一些弊端:</p>
<ol>
<li>测试代码与源代码未分开，难维护。</li>
<li>一个方法测试失败，影响后面方法。</li>
<li>无法自动化测试，得到测试报告。</li>
</ol>
<p>而如果我们使用了 <strong>JUnit 单元测试</strong> 框架进行测试，将会有以下优势:</p>
<ol>
<li>测试代码与源代码分开，便于维护。</li>
<li>可根据需要进行自动化测试。</li>
<li>可自动分析测试结果，产出测试报告。</li>
</ol>
<p>要想使用 JUnit 测试程序, 方法也十分简单, 只需要在<code>pom.xml</code>中, 引入 JUnit 的依赖:</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Junit单元测试依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>接着, 在 <code>test/java</code> 目录下, 创建测试类, 并编写对应的测试方法, 并在方法上声明 <code>@Test</code> 注解.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAge</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>().getAge(<span class="string">&quot;110002200505091218&quot;</span>);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：</strong></p>
<ul>
<li>测试类的命名规范为：XxxxTest</li>
<li>测试方法的命名规定为：public void xxx(){…}</li>
</ul>
<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>单元测试运行不报错, 并不能表示代码逻辑正确.</p>
<p>JUnit 提供了一些辅助方法, 用来帮我们确定被测试的方法是否按照预期的效果正常工作, 这种方式称为<strong>断言</strong>。</p>
<table>
<thead>
<tr>
<th>断言方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>assertEquals(Object 期望值, Object 实际值, String 错误提示信息)</code></td>
<td>检查两个值是否相等，不相等就报错。</td>
</tr>
<tr>
<td><code>assertNotEquals(Object 期望值, Object 实际值, String msg)</code></td>
<td>检查两个值是否不相等，相等就报错。</td>
</tr>
<tr>
<td><code>assertNull(Object 实际值, String 错误提示信息)</code></td>
<td>检查对象是否为 null，不为 null，就报错。</td>
</tr>
<tr>
<td><code>assertNotNull(Object 实际值, String 错误提示信息)</code></td>
<td>检查对象是否不为 null，为 null，就报错。</td>
</tr>
<tr>
<td><code>assertTrue(boolean 条件, String 错误提示信息)</code></td>
<td>检查条件是否为 true，不为 true，就报错。</td>
</tr>
<tr>
<td><code>assertFalse(boolean 条件, String 错误提示信息)</code></td>
<td>检查条件是否为 false，不为 false，就报错。</td>
</tr>
<tr>
<td><code>assertSame(Object 期望值, Object 实际值, String 错误提示信息)</code></td>
<td>检查两个对象引用是否相等，不相等，就报错。</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.params.ParameterizedTest;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.params.provider.ValueSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAge2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>().getAge(<span class="string">&quot;110002200505091218&quot;</span>);</span><br><span class="line">        Assertions.assertNotEquals(<span class="number">18</span>, age, <span class="string">&quot;两个值相等&quot;</span>);</span><br><span class="line"><span class="comment">//        String s1 = new String(&quot;Hello&quot;);</span></span><br><span class="line"><span class="comment">//        String s2 = &quot;Hello&quot;;</span></span><br><span class="line"><span class="comment">//        Assertions.assertSame(s1, s2, &quot;不是同一个对象引用&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetGender2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>().getGender(<span class="string">&quot;612429198904201611&quot;</span>);</span><br><span class="line">        Assertions.assertEquals(<span class="string">&quot;男&quot;</span>, gender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>在 JUnit 中还提供了一些注解，还增强其功能，常见的注解有以下几个：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Test</code></td>
<td>测试类中的方法用它修饰才能成为测试方法，才能启动执行</td>
<td>单元测试</td>
</tr>
<tr>
<td><code>@DisplayName</code></td>
<td>指定测试类、测试方法显示的名称 （默认为类名、方法名）</td>
<td></td>
</tr>
</tbody></table>
<p>这类方法通常用于资源准备工作和释放, 以及环境清理工作.</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>@BeforeEach</code></td>
<td>用来修饰一个实例方法，该方法会在<strong>每一个</strong>测试方法执行之前执行一次。</td>
<td>初始化资源(准备工作)</td>
</tr>
<tr>
<td><code>@AfterEach</code></td>
<td>用来修饰一个实例方法，该方法会在<strong>每一个</strong>测试方法执行之后执行一次。</td>
<td>释放资源(清理工作)</td>
</tr>
<tr>
<td><code>@BeforeAll</code></td>
<td>用来修饰一个静态方法，该方法会在<strong>所有</strong>测试方法之前只执行一次。</td>
<td>初始化资源(准备工作)</td>
</tr>
<tr>
<td><code>@AfterAll</code></td>
<td>用来修饰一个静态方法，该方法会在<strong>所有</strong>测试方法之后只执行一次。</td>
<td>释放资源(清理工作)</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBefore</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAfter</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span> <span class="comment">//该方法必须被static修饰</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testBeforeAll</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before all ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span> <span class="comment">//该方法必须被static修饰</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAfterAll</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after all...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>().getAge(<span class="string">&quot;110002200505091218&quot;</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetGender</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>().getGender(<span class="string">&quot;612429198904201611&quot;</span>);</span><br><span class="line">        System.out.println(gender);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>输出结果如下:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/junit-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%92%E4%BB%B6/file-20241130151132882.jpg"
                     
                ></p>
<p>这类方法一般用作批量参数测试:</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>@ParameterizedTest</code></td>
<td>参数化测试的注解 (可以让单个测试运行多次，每次运行时仅参数不同)</td>
<td>用了该注解，就不需要@Test 注解了</td>
</tr>
<tr>
<td><code>@ValueSource</code></td>
<td>参数化测试的参数来源，赋予测试方法参数</td>
<td>与参数化测试注解配合使用</td>
</tr>
<tr>
<td>两个注解通常配合使用.</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.params.ParameterizedTest;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.params.provider.ValueSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DisplayName(&quot;测试-学生业务操作&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试-获取年龄&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>().getAge(<span class="string">&quot;110002200505091218&quot;</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试-获取性别&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetGender</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>().getGender(<span class="string">&quot;612429198904201611&quot;</span>);</span><br><span class="line">        System.out.println(gender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试-获取性别3&quot;)</span></span><br><span class="line">    <span class="meta">@ParameterizedTest</span></span><br><span class="line">    <span class="meta">@ValueSource(strings = &#123;&quot;612429198904201611&quot;,&quot;612429198904201631&quot;,&quot;612429198904201626&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetGender3</span><span class="params">(String idcard)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>().getGender(idcard);</span><br><span class="line">         System.out.println(gender);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>测试结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/junit-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%92%E4%BB%B6/file-20241130152449637.jpg"
                     
                ></p>
<h1 id="企业开发规范"><a href="#企业开发规范" class="headerlink" title="企业开发规范"></a>企业开发规范</h1><p>编写测试方法时, 除了常规需要测试, 还要尽可能的覆盖业务方法中所有可能的情况 (尤其是边界值).</p>
<p>例如:</p>
<ul>
<li>null值</li>
<li>空值</li>
<li>非法值<br>等.</li>
</ul>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC 入门</title>
    <url>/2024/09/25/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%90%8E%E7%AB%AF/SpringMVC%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h1><p><a class="link"   href="https://spring.io/" >spring官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>SpringMVC 是 Spring 框架的一部分, 是一种基于 Java 实现的 MVC 轻量级Web框架, 可以用于Web开发.<br>相比于 Servlet , 使用更加简单便捷.</p>
<p>当浏览器发出一个请求给后端服务器以后, servlet 容器就会收到请求.<br>但 servlet 并不能进行真正的数据处理, 它主要负责接收请求, 调用业务逻辑层进行数据处理, 并将处理结果组织成页面, 返回给客户端.  </p>
<p>这种架构称为 <strong>“三层架构”</strong>.  </p>
<ul>
<li><strong>表现层(web):</strong>     负责页面数据收集和产生页面.</li>
<li><strong>业务层(service):</strong>   进行业务逻辑处理.</li>
<li><strong>持久层(dao):</strong>     进行数据持久化, 比如说数据的库操作.</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringMVC/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84.png"
                      alt="alt text"
                ></p>
<p>但是, 一个 servlet 只能处理一个请求, 这就轮到新技术 SpringMVC 出场了.  </p>
<p>SpringMVC 将 servlet 细分成三块.<br>当浏览器发出一个请求后, <strong>控制器(controller)</strong> 会接受到请求, 并调用<strong>业务层(service)</strong> 进行业务处理.<br><strong>业务层</strong>会调用<strong>持久层(dao)</strong> 进行数据处理, 并将处理结果组织成 <strong>数据模型(model&#x2F;Java对象)</strong>, 并与 <strong>视图层(view)</strong> 共同作用, 产生页面.  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringMVC/MVC.png"
                      alt="alt text"
                ></p>
<p>这种基于控制器的模式下, 一个 servlet 就能做请求的分发了, 从而实现了请求的并发处理.  </p>
<p>顺便提一句, 老一代的技术中, view 一般是 <code>.jsp</code>.<br>而目前流行的技术中, view 采用 <strong>异步调用</strong>(HTML+CSS+VUE+ElementUI)的形式.  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringMVC/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8.png"
                      alt="alt text"
                ></p>
<p>要注意的是, 返回的 model&#x2F;Java对象 无法直接在 view 中使用, 不过将其转换为 JSON 格式后, 再由前端把数据从 JSON 中抽取出来 就可以组织成页面, 反馈给浏览器了.  </p>
<p>在这个过程中, SpringMVC 就主要做以下两件事:</p>
<ol>
<li>把 model&#x2F;Java对象 转换为 view 所需的 JSON 格式.</li>
<li>负责 controller 对应的开发.</li>
</ol>
<h1 id="SpringMVC-入门案例"><a href="#SpringMVC-入门案例" class="headerlink" title="SpringMVC 入门案例"></a>SpringMVC 入门案例</h1><h3 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h3><p>需求: 实现一个简单的 SpringMVC 项目, 实现一个简单的 Hello World 页面.</p>
<h4 id="创建-Maven-项目"><a href="#创建-Maven-项目" class="headerlink" title="创建 Maven 项目"></a>创建 Maven 项目</h4><p>新建项目, 选择 Maven Archetype 类型, 并选择 webapp 模板.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringMVC/%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE.png"
                      alt="alt text"
                ></p>
<p>进入项目后, 需等待 Maven 下载依赖包.<br>如果项目目录久久没有变化, 可以检查一下 Maven 的配置是否正确.  </p>
<h4 id="1-引入-SpringMVC-依赖"><a href="#1-引入-SpringMVC-依赖" class="headerlink" title="1. 引入 SpringMVC 依赖"></a>1. 引入 SpringMVC 依赖</h4><p>对于 项目的 <code>pom.xml</code> 文件, 配置如下:</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.wreckloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>SpringMVC Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--  servlet 依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 确保版本与你的Tomcat版本相匹配 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--  SpringMVC 依赖  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--   配置tomcat插件   --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>注意: 确保版本与你的Tomcat版本相匹配.</p>
</blockquote>
<p>接下来补全必要的包和类, 如图, 补全后项目目录如下:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringMVC/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png"
                      alt="alt text"
                ></p>
<p>接下来详细说明这些包和类:</p>
<h4 id="2-创建-SpringMVC-配置文件"><a href="#2-创建-SpringMVC-配置文件" class="headerlink" title="2. 创建 SpringMVC 配置文件"></a>2. 创建 SpringMVC 配置文件</h4><p>在 controller 包下, 新建编写一个简单的 controller 控制器, 用于处理请求.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>  <span class="comment">// 专门用作表现层的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span>  <span class="comment">// 关联了下面的方法. 当执行 &quot;/save&quot; 路径时, 拦截到下面的方法中.</span></span><br><span class="line">    <span class="meta">@ResponseBody</span> <span class="comment">// 告诉 SpringMVC 此方法不是页面, 作为响应体返回</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;info&#x27;:&#x27;Hello World!&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-初始化-SpringMVC-环境"><a href="#3-初始化-SpringMVC-环境" class="headerlink" title="3. 初始化 SpringMVC 环境"></a>3. 初始化 SpringMVC 环境</h4><p>在 config 包下, 新建一个配置类, 用于初始化 SpringMVC 环境.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 代替传统的 xml 配置文件, 告诉Spring这是一个配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.wreckloud.controller&quot;)</span> <span class="comment">// 扫描, 加载对应的 bean(注解为 @Controller), 使其能够加载控制器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringmvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-初始化容器配置类"><a href="#4-初始化容器配置类" class="headerlink" title="4. 初始化容器配置类"></a>4. 初始化容器配置类</h4><p><code>AbstractDispatcherServletInitializer</code> 类是 SpringMVC 提供的快速初始化 web 3.0 容器的抽象类.  </p>
<p>它提供三个接口方法供用户实现:</p>
<ul>
<li><code>createServletApplicationContext()</code>: 创建 Servlet 容器时, 加载 SpringMVC 对应的bean, 并放入 <code>WebApplicationContext</code> 对象范围中.</li>
<li><code>getServletMappings()</code>: 配置由 tomcat 处理还是 springmvc 处理.</li>
<li><code>createRootApplicationContext()</code>: 创建 <code>WebApplicationContext</code> 对象, 用于加载 Spring 配置文件.</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.context.WebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.context.support.AnnotationConfigWebApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();  <span class="comment">// 初始化容器对象</span></span><br><span class="line">        context.register(SpringmvcConfig.class);  <span class="comment">// 注册容器配置类, 加载具体配置</span></span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125; <span class="comment">// 一旦 Tomcat 启动, 就会加载对应的容器对象.</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;  <span class="comment">// 配置由 tomcat 处理还是 springmvc 处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;; <span class="comment">// 设置为 &quot;/&quot; 表示拦截所有请求, 都由 SpringMVC 来处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123; <span class="comment">// 加载springMVC之外的其他bean配置对应的容器对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 这个案例中不需要加载其他bean配置, 所以返回null.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="5-启动-访问页面"><a href="#5-启动-访问页面" class="headerlink" title="5. 启动, 访问页面"></a>5. 启动, 访问页面</h4><p>启动项目, 访问 <code>http://localhost:8080/save</code>, 即可看到 “Hello World” 页面.</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>Controller 加载控制与业务 bean 加载控制</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/SpringMVC/Spring%E7%BB%93%E6%9E%84.png"
                      alt="alt text"
                ></p>
<ul>
<li>SpringMvc相关bean（表现层bean）</li>
<li>Spring控制的bean<ul>
<li>业务bean (Service)</li>
<li>功能bean（DataSource等）</li>
</ul>
</li>
</ul>
<p>为了避免加载到错误的 bean, 我们需要对 bean 的加载进行控制.</p>
<h4 id="方式一：设定排除范围"><a href="#方式一：设定排除范围" class="headerlink" title="方式一：设定排除范围"></a>方式一：设定排除范围</h4><p>在 config 包下, 修改 SpringMVC 的配置类:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.wreckloud&quot;, // 扫描全部的包</span></span><br><span class="line"><span class="meta">    excludeFilters = @ComponentScan.Filter( // 按注解过滤</span></span><br><span class="line"><span class="meta">            type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">            classes = &#123; Controller.class &#125; //排除注解为Controller的bean</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringmvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>@ComponentScan</code> 有以下两个属性:</p>
<ul>
<li><code>excludeFilters</code>: 排除指定注解的bean.</li>
<li><code>includeFilters</code>: 包含指定注解的bean.</li>
</ul>
<h4 id="方式二：设定精准的扫描范围"><a href="#方式二：设定精准的扫描范围" class="headerlink" title="方式二：设定精准的扫描范围"></a>方式二：设定精准的扫描范围</h4><p>在 config 包下, 修改 SpringMVC 的配置类:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.wreckloud.service&quot;,&quot;com.wreckloud.dao&quot;&#125;)</span> <span class="comment">// 可以通过大括号和逗号分隔多个包名, 精准的扫描范围.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringmvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="简化开发"><a href="#简化开发" class="headerlink" title="简化开发"></a>简化开发</h3><p>容器配置类可以用以下更简洁的写法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletconfigClasses()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringmvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> String[]getServletMappings()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Springconfig.class&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java 后端</tag>
        <tag>后端技术</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL安装</title>
    <url>/2024/09/27/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="从官网获取安装程序"><a href="#从官网获取安装程序" class="headerlink" title="从官网获取安装程序"></a>从官网获取安装程序</h1><p>访问 MySQL 官网, 点击 DOWNLOADS 选择下载 MySQL Community Server(社区版), 下载最新版本的 MySQL 安装程序.</p>
<p><a class="link"   href="https://www.mysql.com/" >MySQL 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/mysql%E5%AE%89%E8%A3%85/file-20250302214930984.jpg"
                     
                ></p>
<p>或者直接点击这里 -&gt; <a class="link"   href="https://dev.mysql.com/downloads/installer/" >MySQL 下载地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>也可直接前往下载页面:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/mysql%E5%AE%89%E8%A3%85/file-20250302215615795.jpg"
                     
                ></p>
<p>前往下载页后, 推荐选择第二个下载项.<br>然后点击这里直接下载.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/mysql%E5%AE%89%E8%A3%85/file-20250302221026277.jpg"
                     
                ></p>
<h1 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h1><p>下载完安装程序后, 双击运行安装程序.</p>
<p>如果安装方式直接选择 <code>Full</code> , 虽然会自动选择核心组件, 但是无法指定安装路径(默认为 C 盘).<br>直接选择 <code>Custom</code> 就能指定安装路径, 但是直接选择后不会自动选择核心组件, 需要手动勾选组件(有点麻烦).</p>
<p>于是, 我们先选择 <code>Full</code> 安装方式, 先让安装程序为我们自动勾选核心组件.然后点击 <code>&lt;back</code> 按钮, 选择 <code>Custom</code> 来自定义安装路径.</p>
<blockquote>
<p>如果不在乎安装路径, 直接选择 <code>Full</code> 就行.</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/mysql%E5%AE%89%E8%A3%85/file-20250302215838609.jpg"
                     
                ></p>
<p>更改安装路径, 将安装路径从默认的<br><code>C:\Program Files\MySQL\...</code><br>设置为<br><code>任意路径\MySQL\...</code><br>(根据自己的实际情况更改).</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/mysql%E5%AE%89%E8%A3%85/file-20250302215903827.jpg"
                     
                ></p>
<p>每一个组件都需要修改路径, 修改完成后点击 <code>Next&gt;</code> 按钮.<br>接着无脑下一步, 等待组件安装.</p>
<p>直到设置密码的界面, 推荐使用<strong>简单密码</strong>, 因为到头来还是防自己的(</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/mysql%E5%AE%89%E8%A3%85/file-20250302215917764.jpg"
                     
                ></p>
<p>接着无脑下一步, 这个界面得注意一下:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/mysql%E5%AE%89%E8%A3%85/file-20250302215933466.jpg"
                     
                ></p>
<p>不过还是保持默认比较好.<br>MySQL 本身也不太占内存, 每次手动启动还是有点麻烦.<br>因此, 保持 <code>Start the MySQL Server at System Startup</code> 为勾选状态即可.</p>
<p>注意 Windows Service Name 项配置的名称, 启动需要此名称.<br>这里默认是 <code>MySQL80</code> , 如果变更记得在后面的步骤中替换.</p>
<h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>介绍一下<a href="/2024/12/21/猎识印记-领域/计算机通识/环境变量/">环境变量</a></p>
<p>配置环境变量的过程都是通用的.</p>
<h1 id="常用-MySQL-指令"><a href="#常用-MySQL-指令" class="headerlink" title="常用 MySQL 指令"></a>常用 MySQL 指令</h1><ul>
<li>启动</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net start mysql80</span><br></pre></td></tr></table></figure></div>

<ul>
<li>停止</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">net stop mysql80</span><br></pre></td></tr></table></figure></div>

<p>要注意的是 cmd 必须以管理员身份运行才能正常启动, 否则会提示拒绝访问.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/mysql%E5%AE%89%E8%A3%85/file-20250302215956671.jpg"
                     
                ></p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>指南</tag>
        <tag>Java 后端</tag>
        <tag>后端基础</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBootWeb-企业级框架</title>
    <url>/2024/12/01/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%90%8E%E7%AB%AF/SpringBootWeb-%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="SpringBootWeb-简介"><a href="#SpringBootWeb-简介" class="headerlink" title="SpringBootWeb 简介"></a>SpringBootWeb 简介</h1><p>那么, 什么是 Spring?<br>官网写着: Spring makes Java simple.</p>
<p>Spring 官网: <a class="link"   href="https://spring.io/" >https://spring.io<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>Spring 的官方提供很多开源的项目, 发展到今天, 已经形成了一种开发生态圈.<br>Spring 提供了若干个子项目, 每个项目用于完成特定的功能. 而我们在项目开发时, 一般会偏向于选择这一套 spring 家族的技术, 来解决对应领域的问题.<br>我们称这一套技术为<strong>spring 全家桶</strong>.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/springbootweb-%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%A1%86%E6%9E%B6/file-20241201163032365.jpg"
                     
                ></p>
<p>SpringFramework 就是 Spring 家族旗下这么多的技术，最基础、最核心的技术. 其他的 spring 家族的技术, 都是基于 SpringFramework 的.</p>
<p>那这东西这么好, 为什么不用 SpringFramework 而是使用 <strong>springboot</strong> ?<br>主要是因为:</p>
<ul>
<li>配置繁琐</li>
<li>入门难度大</li>
</ul>
<p>spring 官方推荐我们从另外一个项目开始学习，那就是目前最火爆的 SpringBoot。 通过 springboot 就可以快速的帮我们构建应用程序.</p>
<p>接下来, 用一个简单的入门案例来试试吧!</p>
<h1 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h1><p>需求: 基于 SpringBoot 的方式开发一个 web 应用，浏览器发起请求 <code>/hello</code> 后，给浏览器返回字符串 “Hello xxx ~”.</p>
<h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><p>第 1 步：创建 SpringBoot 工程，并勾选 Web 开发相关依赖<br>第 2 步：定义 HelloController 类，添加方法 hello，并添加注解</p>
<p><strong>1). 创建 SpringBoot 工程（需要联网）</strong></p>
<p>基于 Spring 官方骨架，创建 SpringBoot 工程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/springbootweb-%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%A1%86%E6%9E%B6/file-20241202143143930.jpg"
                     
                ></p>
<p>基本信息描述完毕之后, 勾选 web 开发相关依赖.<br>点击 Create 之后, 就会联网创建这个 SpringBoot 工程, 创建好之后, 结构如下:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/springbootweb-%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%A1%86%E6%9E%B6/file-20241202145203301.jpg"
                     
                ></p>
<p><strong>注意：在联网创建过程中，会下载相关资源(请耐心等待)</strong></p>
<p>由于spring官网并不在国内, 如果遇到下载失败等网络问题, 可以尝试更换为阿里云镜像.<br>(一般来说不会遇到, 因此不需要配置.)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/springbootweb-%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%A1%86%E6%9E%B6/file-20241202145824794.jpg"
                     
                ></p>
<p>使用阿里云提供的脚手架, 将网址：<a class="link"   href="https://start.aliyun.com/" >https://start.aliyun.com<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 填入其中.<br>接着正常创建即可.</p>
<p><strong>2). 定义 HelloController 类，添加方法 hello，并添加注解</strong></p>
<p>在 <code>src\main\java\com.example.xxx\</code> 下新建一个类：<code>HelloController</code></p>
<p>HelloController 中的内容，具体如下：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">//标识当前类是一个请求处理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span> <span class="comment">//标识请求路径</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloController ... hello: &quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3). 运行测试</strong></p>
<p>运行 SpringBoot 自动生成的引导类 (标识有<code>@SpringBootApplication</code>注解的类)<br>打开浏览器，输入 &#96;<a class="link"   href="http://localhost:8080/hello?name=Wreckloud" >http://localhost:8080/hello?name=Wreckloud<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/springbootweb-%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%A1%86%E6%9E%B6/file-20241202145642753.jpg"
                     
                ></p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>SpringBoot 如此方便, 这全靠我们刚刚勾选下载的 Spring web <strong>起步依赖</strong> .<br>在右侧的 Maven 面板中, 就能清晰地看见这些依赖:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/springbootweb-%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%A1%86%E6%9E%B6/file-20241202151204936.jpg"
                     
                ></p>
<p>web 开发的 <strong>起步依赖</strong> 是 <code>spring-boot-starter-web</code>.<br>而<code>spring-boot-starter-web</code>依赖, 又依赖了<code>spring-boot-starter-tomcat</code>.<br>由于 maven 的依赖传递特性, 那么在我们创建的 springboot 项目中也就已经有了 tomcat 的依赖, 也就是内嵌的 tomcat.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/springbootweb-%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%A1%86%E6%9E%B6/file-20241202151032203.jpg"
                     
                ></p>
<p>而我们运行引导类中的 main 方法, 其实启动的就是 springboot 中内嵌的 Tomcat 服务器.  而我们所开发的项目, 也会自动的部署在该 tomcat 服务器中, 并占用 8080 端口号 .</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>后端</category>
      </categories>
  </entry>
  <entry>
    <title>从入门到删库：MySQL笔记</title>
    <url>/2025/03/01/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%93%EF%BC%9AMySQL%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ul>
<li>数据库 DataBase(DB), 是存储和管理数据的仓库.</li>
<li>数据库管理系统 DataBase Management System(DBMS), 操纵和管理数据库的大型软件.</li>
<li>SQL (Structured Query Language), 操作关系型数据库的编程语言, 定义了一套操作关系型数据库统一标准.</li>
</ul>
<h1 id="MySQL-概述"><a href="#MySQL-概述" class="headerlink" title="MySQL 概述"></a>MySQL 概述</h1><p><a href="/2024/09/27/猎识印记-领域/软件工程/数据库/MySQL安装/">安装MySQL</a></p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>Maven-项目构建工具</title>
    <url>/2024/09/24/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%90%8E%E7%AB%AF/Maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="Maven-简介"><a href="#Maven-简介" class="headerlink" title="Maven 简介"></a>Maven 简介</h1><p>Maven 是 <a class="link"   href="https://www.apache.org/" >apache 软件基金会<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 推出的一个开源的 <strong>管理和构建 java 项目的工具</strong>.</p>
<blockquote>
<p><a class="link"   href="https://www.apache.org/index.html#projects-list" >apache 所有的开源项目<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<p>Maven 基于项目对象模型 (project object model, POM) 的概念, 通过一小段描述信息 (pom.xml), 来自动 <strong>管理</strong> 和 <strong>构建</strong> java 项目.</p>
<p>Maven 模型由以下三大块组成:</p>
<ul>
<li>项目对象模型 (Project Object Model)</li>
<li>依赖管理模型(Dependency)</li>
<li>构建生命周期&#x2F;阶段(Build lifecycle &amp; phases)<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128123533288.jpg"
                     
                ></li>
</ul>
<h3 id="Maven-的作用"><a href="#Maven-的作用" class="headerlink" title="Maven 的作用"></a>Maven 的作用</h3><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><p>自动下载项目依赖, 并管理这些依赖的版本.</p>
<p>若是没有 Maven 帮助, 我们项目中要想使用某一个 jar 包, 就需要把这个 jar 包从官方网站下载下来, 然后再导入到项目中.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129131953198.jpg"
                     
                ></p>
<p>一旦涉及的 jar 包数量增多, 弊端可想而知.</p>
<p>当使用 Maven 来构建时, 我们只需要在 Maven 项目的 <code>pom.xml</code> 文件中, 添加一段如下图所示的配置即可实现.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129132031070.jpg"
                     
                ></p>
<p>Maven 会根据配置信息的描述, 自动的去下载对应的依赖. 就可以直接在项目中使用了.</p>
<h4 id="标准项目构建"><a href="#标准项目构建" class="headerlink" title="标准项目构建"></a>标准项目构建</h4><p>Maven 还提供了标准化的跨平台的自动化构建方式, 自动编译, 测试, 打包, 发布项目.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129132200393.jpg"
                     
                ></p>
<p>通过 Maven 中的命令，就可以很方便的完成项目所需步骤.</p>
<h4 id="统一项目结构"><a href="#统一项目结构" class="headerlink" title="统一项目结构"></a>统一项目结构</h4><p>项目结构的标准化, 使得项目更加清晰.</p>
<p>早期, 不同的 java 开发工具创建出的项目结构存在差异, 要想从一个开发工具转到另一个, 不是件容易的事情.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128123525254.jpg"
                     
                ></p>
<p>而 Maven 提供了如图所示的一套标准 java 项目目录.</p>
<h1 id="Maven-安装"><a href="#Maven-安装" class="headerlink" title="Maven 安装"></a>Maven 安装</h1><h3 id="下载并解压-Maven"><a href="#下载并解压-Maven" class="headerlink" title="下载并解压 Maven:"></a>下载并解压 Maven:</h3><p>下载 maven 官方提供的 <code>Binary zip archive</code> 压缩包<br><a class="link"   href="https://maven.apache.org/download.cgi" >下载地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<p>在官网下滑找到 Files 下载.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128131506942.jpg"
                     
                ></p>
<p>下载后解压到一个方便管理的目录.<br>由于一些兼容性和安全性问题, 路径尽量不要包含 <strong>中文</strong> 或 <strong>空格</strong>.</p>
<p>接下来, 以我的路径为例:</p>
<blockquote>
<p><code>D:\Code\apache\apache-maven-3.9.9</code></p>
</blockquote>
<p>进行配置.</p>
<h3 id="配置仓库"><a href="#配置仓库" class="headerlink" title="配置仓库:"></a>配置仓库:</h3><p>仓库 (repository) 用于存储 Maven 下载的资源, 管理各种 jar 包.</p>
<p>我们新建一个文件夹作为 本地仓库,<br>我的 本地仓库 路径设置为:</p>
<blockquote>
<p><code>D:\Code\apache\maven_repo</code></p>
</blockquote>
<p>然后, 要让 Maven 知道这个本地仓库的位置.</p>
<h4 id="配置-本地仓库"><a href="#配置-本地仓库" class="headerlink" title="配置 本地仓库"></a>配置 本地仓库</h4><p>来到刚刚解压的 Maven 文件夹, 进入 <code>conf</code> 目录, 打开 <code>settings.xml</code> 文件.<br>在 <code>conf/settings.xml</code> 文件中找到 <code>&lt;localRepository&gt;</code> 标签, 在注释外添加本地仓库路径.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128131925038.jpg"
                     
                ></p>
<blockquote>
<p>VScode 中 ctrl+f 搜索 <code>localRepository</code> 可快速定位到该标签.</p>
</blockquote>
<p>我的配置如下:</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\Code\apache\maven_repo<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>这样, Maven 下载的依赖就会放到这个文件夹下.</p>
<h4 id="配置-远程仓库"><a href="#配置-远程仓库" class="headerlink" title="配置 远程仓库"></a>配置 远程仓库</h4><p>Maven 有 由 Maven 团队 维护的全球唯一的 中央仓库<br><strong>(<a class="link"   href="https://repo1.maven.org/maven2/" >仓库地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>)</strong>.<br>不过由于其在海外, 大陆访问速度较慢, 所以我们可以配置国内的 阿里云镜像 仓库, 以提升下载速度.</p>
<blockquote>
<p>本地仓库 优先级高于 远程仓库.</p>
</blockquote>
<p>配置阿里云私服, 也是在 <code>conf/settings.xml</code> 文件中配置 <code>&lt;mirrors&gt;</code> 标签下配置镜像仓库.</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128132250848.jpg"
                     
                ></p>
<p><a class="link"   href="https://developer.aliyun.com/mvn/guide" >阿里云镜像仓库官方说明文档<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量:"></a>配置环境变量:</h3><p><a href="/2024/12/21/猎识印记-领域/计算机通识/环境变量/">关于环境变量</a></p>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>注意!</p>

    </div>
    <div class="notel-content">
      <p>错误地编辑注册表可能会损坏系统!<br>编辑更改注册表前请确保你知道你在做什么.</p>

    </div>
  </div>

<p>为了能在任意目录下使用 Maven, 可以将 Maven 的 bin 目录添加到环境变量中.</p>
<p>打开设置, 在 关于 系统 -&gt; 系统高级设置 中点击 <code>环境变量</code>.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128132357292.jpg"
                     
                ></p>
<p>接着, 在 <code>系统变量</code> 里 点击 新建, 变量名为 <code>Maven_Home</code>, 变量值为刚刚解压后的 Maven 目录.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128132401362.jpg"
                     
                ></p>
<p>完成后, 点击 <code>确定</code>.</p>
<p>然后在 <code>系统变量</code> 里 找到<code>Path</code>, 点击编辑.<br>新建一个变量, 变量值为</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">%Maven_Home%\bin</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128132406728.jpg"
                     
                ></p>
<p>然后依次点击 以下三个窗口的 <code>确定</code></p>
<ul>
<li>编辑环境变量</li>
<li>环境变量</li>
<li>系统属性</li>
</ul>
<p>来保存配置.</p>
<blockquote>
<p>注意这里的 变量值 <code>%Maven_Home%</code> 和 刚刚设置的 变量名 <code>Maven_Home</code> 要一致.<br>例如 你把变量名设置为 <code>MAVEN</code> , 那么变量值就应该设置为 <code>%MAVEN%\bin</code> .</p>
</blockquote>
<h3 id="测试-Maven-是否安装成功"><a href="#测试-Maven-是否安装成功" class="headerlink" title="测试 Maven 是否安装成功:"></a>测试 Maven 是否安装成功:</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure></div>

<p>返回以下内容, 表示环境变量配置成功.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128132420814.jpg"
                     
                ></p>
<h1 id="在-IDEA-集成-Maven"><a href="#在-IDEA-集成-Maven" class="headerlink" title="在 IDEA 集成 Maven"></a>在 IDEA 集成 Maven</h1><h3 id="配置-Maven-环境"><a href="#配置-Maven-环境" class="headerlink" title="配置 Maven 环境"></a>配置 Maven 环境</h3><p>我们并不会一直在命令行中使用 Maven, 绝大部分时候我们都会在 IDEA 中集成 Maven.</p>
<p>可以针对当前项目配置 Maven , 不过那样每次新项目都要配置, 比较繁琐.<br>直接略过, 我们来配置全局 Maven 路径.</p>
<h4 id="关联-IDEA-环境"><a href="#关联-IDEA-环境" class="headerlink" title="关联 IDEA 环境"></a>关联 IDEA 环境</h4><p>如果你的 IDEA 还在项目界面, 请先关闭项目返回开始界面.<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128133035355.jpg"
                     
                ></p>
<p>然后在开始界面 到 <code>Customize</code> 选项卡下, 点击 <code>All settings...</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128133049461.jpg"
                     
                ></p>
<p>在左侧选项卡中选择 <code>Build, Execution, Deployment</code><br>接着找到 <code>Build Tools</code> -&gt; <code>Maven</code> 来配置 Maven 的全局路径等信息.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128133053489.jpg"
                     
                ></p>
<p>配置完成后点击 <code>Apply</code> 应用.</p>
<h4 id="配置-Java-版本"><a href="#配置-Java-版本" class="headerlink" title="配置 Java 版本"></a>配置 Java 版本</h4><p>接着指定这两个地方的 java 版本.</p>
<p>一个是运行的 JRE 版本 <code>Runner</code> , 一个是编译器的版本 <code>Java Compiler</code><br>如果你的 Maven 也是 3.9.9 , 那么推荐使用 <strong>Java 17</strong>.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241128133927775.jpg"
                     
                ></p>
<p>别忘记点击 <code>Apply</code> 应用.</p>
<h3 id="创建-Maven-项目"><a href="#创建-Maven-项目" class="headerlink" title="创建 Maven 项目"></a>创建 Maven 项目</h3><p>新建项目</p>
<p>然后选择 Java 项目, 在 Build tool 中选择 Maven, 然后点击下一步.</p>
<blockquote>
<p>(注意: 不同版本的 IDEA 可能会有些许差异, 我这个是 2024 版本的 IDEA)</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129130103782.jpg"
                     
                ></p>
<p>初次创建时, Maven 会自动下载依赖包, 请耐心等待.<br>创建好后, Maven 的项目结构如下所示.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129133910216.jpg"
                     
                ></p>
<h3 id="导入已有-Maven-项目"><a href="#导入已有-Maven-项目" class="headerlink" title="导入已有 Maven 项目"></a>导入已有 Maven 项目</h3><p>有时候如果已经有了一个 Maven 项目, 可以直接在 IDEA 中导入并打开它.<br>导入项目的关键是找到 <code>pom.xml</code> 文件.</p>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>在 IDEA 项目右侧, 找到 Maven 图标, 点击加号, 找到已有 Maven 项目的 <code>pom.xml</code> 文件, 双击即可开始导入.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129130509338.jpg"
                     
                ></p>
<p>如果没看见右侧工具栏, 可以在 <code>View</code> -&gt; <code>Appearance</code> -&gt; <code>Tool windows bar</code> 中打开.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129130524373.jpg"
                     
                ></p>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>也可以在 IDEA 的菜单栏中选择 <code>File</code> -&gt; <code>project Structure</code> 打开项目, 然后选择 <code>pom.xml</code> 文件.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129130559414.jpg"
                     
                ></p>
<h2 id="依赖管理-1"><a href="#依赖管理-1" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>Maven 依赖管理是 Maven 最重要的功能之一.<br>修改 <code>pom.xml</code> 文件, 加入依赖包的坐标, 即可轻松管理依赖包.</p>
<p>依赖有三个重要的属性, 称之为 <strong>坐标</strong>:</p>
<ul>
<li>groupId: 组织名(通常以域名反写组成)</li>
<li>artifactId: 模块名</li>
<li>version: 版本号<ul>
<li>SNAPSHOT: 快照版本</li>
<li>RELEASE: 发行版本</li>
</ul>
</li>
</ul>
<p>坐标是 jar 资源 的唯一标识, 通过该坐标可以唯一定位资源位置.</p>
<p>在项目下找到 <code>pom.xml</code> 文件, 双击打开.</p>
<p>在 <code>&lt;project&gt;</code> 内, 声明 <code>&lt;dependencies&gt;</code> 标签, 然后在 <code>&lt;dependencies&gt;</code> 标签内加入依赖包的坐标.</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="comment">&lt;!-- 组织名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="comment">&lt;!-- 模块名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>IDEA 会自动补全内容, 这里以 <code>logback-classic</code> 依赖为例：<br>在 <code>&lt;groupId&gt;</code> 标签内输入 <code>ch.qos.logback</code>, IDEA 便会自动补全信息.</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>如果 IDEA 不能自动补全, 则可以手动搜索坐标导入依赖包.</p>
<p><a class="link"   href="https://mvnrepository.com/" >依赖包搜索地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>在搜索框中搜索 <code>logback-classic</code>, 找到 <code>logback-classic</code> 依赖包的坐标, 复制并粘贴到 <code>&lt;dependencies&gt;</code> 标签内.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129134315755.jpg"
                     
                ></p>
<p>接着点击 重新加载依赖 按钮.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129134325595.jpg"
                     
                ></p>
<p>等待 IDEA 自动下载依赖包,<br>就能在右侧的 Maven 依赖树中看到 <code>logback-classic</code> 依赖了.</p>
<h3 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h3><p>依赖具有传递性.</p>
<p>例如刚刚我们添加了 <code>logback-classic</code> 依赖, 它依赖了 <code>logback-core</code> 依赖.<br><code>logback-core</code> 依赖了 <code>slf4j-api</code> 依赖.</p>
<p>所以 Maven 会自动下载 <code>logback-core</code> 和 <code>slf4j-api</code> 依赖.<br>不信你就打开刚刚的文件夹看看:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129134339955.jpg"
                     
                ></p>
<p>还可以在 <code>pom.xml</code> 文件窗口的右键菜单中查看依赖树.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129134349450.jpg"
                     
                ></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Maven 生命周期是为了自动化构建项目, 并提供一系列的插件来完成构建过程.</p>
<p>Maven 中有三套 相互独立 的生命周期:</p>
<ol>
<li>clean: 清理项目</li>
<li>default: 默认构建</li>
<li>site: 生成项目报告</li>
</ol>
<p>每套生命周期都有一系列的插件, 这些插件可以完成构建的各个阶段.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129134729383.jpg"
                     
                ></p>
<p>我们只需要关注以下五个阶段:</p>
<ul>
<li><strong>clean: 清理项目</strong><ul>
<li>clean：移除上一次构建生成的文件</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>default: 默认构建</strong></p>
<ul>
<li>compile：编译项目源代码</li>
<li>test: 使用合适的单元测试框架运行测试（junit）</li>
<li>package：将编译后的文件打包，如：jar、war 等</li>
</ul>
</li>
<li><p><strong>site: 生成项目报告</strong></p>
<ul>
<li>install：安装项目到本地仓库</li>
</ul>
</li>
</ul>
<p>在 IDEA 中, 已经集成了 Maven 的生命周期.<br>需要注意的是:</p>
<blockquote>
<p>在<strong>同一套生命周期</strong>中, 当运行后面的阶段时, 前面的阶段都会运行.</p>
</blockquote>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>JavaScript</p>

    </div>
    <div class="notel-content">
      <p>例如:<br>当运行 package 时, 同一套生命周期的 compile, test 都会运行;<br>而另一套生命周期的 instal 或 clean 不会运行.</p>

    </div>
  </div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/maven-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/file-20241129135036689.jpg"
                     
                ></p>
<p>在此处双击 需要运行的阶段, 即可运行该阶段.</p>
<h3 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h3><p>有时候我们只需要用到 <code>logback-classic</code> 依赖中的某些类, 而不需要 <code>logback-core</code> 依赖中的所有类.<br>这时就可以在 <code>&lt;dependency&gt;</code> 标签中加入 <code>&lt;exclusions&gt;</code> 标签, 排除不需要的依赖.</p>
<div class="code-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span> <span class="comment">&lt;!-- 排除不需要的依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>每次改变 pom.xml 文件, 别忘记点击按钮重新加载.</p>
<h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>Maven 依赖默认情况下是 <code>compile</code> 范围, 即在任何(主程序, 测试程序, 打包)时候都生效.</p>
<p>我们可以通过 <code>&lt;dependency&gt;</code> 标签的 <code>&lt;scope&gt;</code> 标签来修改依赖范围.<br><code>&lt;scope&gt;</code> 标签的值有以下几种:</p>
<table>
<thead>
<tr>
<th>scope 值</th>
<th>主程序</th>
<th>测试程序</th>
<th>打包(运行)</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>依赖范围默认值, 即在任何时候都生效</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>√</td>
<td>-</td>
<td>仅在测试程序中生效, 如 Junit</td>
</tr>
<tr>
<td>provided</td>
<td>√</td>
<td>√</td>
<td>-</td>
<td>仅在编译和测试程序中生效, 如 servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td>-</td>
<td>√</td>
<td>√</td>
<td>仅在运行时生效, 如 JDBC 驱动程序</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>指南</tag>
        <tag>后端</tag>
        <tag>构建工具</tag>
      </tags>
  </entry>
</search>
