<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hello websites</title>
    <url>/2023/09/17/%E5%95%B8%E6%9C%88%E5%97%B7%E5%A3%B0-%E6%88%90%E9%95%BF/%E5%8D%9A%E5%AE%A2-hello-websites/</url>
    <content><![CDATA[<h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><h2 id="安装-git-和-node-js"><a href="#安装-git-和-node-js" class="headerlink" title="安装 git 和 node.js"></a>安装 git 和 node.js</h2><p>由于 Hexo 是基于 Node.js 驱动的一款博客框架, 所以安装 NodeJS.</p>
<p><a class="link"   href="https://nodejs.org/en/" >下载 node.js<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>为了能把 hexo 部署到 github 仓库, 还需要安装 git.</p>
<p><a class="link"   href="https://git-scm.com/downloads" >下载 git<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>安装之后可以输入以下命令查看是否安装成功:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">git --version</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>npm（Node Package Manager, Node 包管理器）是 Node.js 的默认包管理工具.</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/hello-websites/file-20241225135656753.jpg"
                     
                ></p>
<h2 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h2><p>环境准备好了就可使用 npm 开始安装 Hexo 了, 在命令行输入执行如下命令:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></div>

<p>可能会出现下载缓慢的情况, 可以尝试使用国内镜像源.<br><a href="../../_posts/Node-js%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE.md">如何更改 npm 源?</a></p>
<p>待到安装完成后, 在一处新建文件夹作为博客的根目录.<br> 然后进入这个文件夹并右键空白处, 选择 “Open git bash here” 打开 git 命令行, 接着依次输入以下命令:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init Blog <span class="comment"># 创建新的 Hexo 博客项目, 文件夹名为 Blog.</span></span><br><span class="line"><span class="built_in">cd</span> Blog <span class="comment"># 进入博客目录.</span></span><br><span class="line">npm install <span class="comment"># 安装 Hexo 所需的依赖包.</span></span><br></pre></td></tr></table></figure></div>

<p>这样就完成了 Hexo 的安装, 并创建了一个新的博客项目.<br>运行以下命令启动本地服务器:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure></div>

<p>启动本地服务器后, 就可访问 <a class="link"   href="http://localhost:4000/" >http://localhost:4000<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 看到博客效果.</p>
<h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>Hexo 官方主题站点: <a class="link"   href="https://hexo.io/themes/" >https://hexo.io/themes/<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br>(可能需要科学上网)</p>
<p>这里推荐我使用的主题 Redefine, 它很简洁, 功能也很强大.</p>
<p><a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine" >Redefine 官方 GitHub 页<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://redefine-docs.ohevan.com/" >Redefine 主题配置指南<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>将下载的主题文件夹放到<strong>博客根目录</strong>下的 <code>themes</code> 文件夹下, 并修改<strong>根目录</strong>下博客配置文件 <code>_config.yml</code> 中的 <code>theme</code> 选项为 <code>主题文件夹名称</code>.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/hello-websites/file-20241225135707412.jpg"
                     
                ></p>
<p>此外, 在 <code>_config.yml</code> 还有许多其他配置选项, 如网站标题, 网站描述等.<br>都可以根据自己的喜好进行修改.</p>
<p>可以随时运行以下命令来在本地服务器 (<a class="link"   href="http://localhost:4000/" >http://localhost:4000<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>) 预览博客效果:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></div>

<h1 id="部署到-GitHub-Pages"><a href="#部署到-GitHub-Pages" class="headerlink" title="部署到 GitHub Pages"></a>部署到 GitHub Pages</h1><h2 id="创建-GitHub-仓库"><a href="#创建-GitHub-仓库" class="headerlink" title="创建 GitHub 仓库"></a>创建 GitHub 仓库</h2><p>首先, 你需要有一个 GitHub 账号, 并创建一个新的仓库.</p>
<p>点击 Start project 或者下面的 new repository 建立一个新的仓库，注意 Github 仅能使用一个同<br>名仓库的代码托管一个静态站点，这里注意仓库名一定要是：<br>用户名.github.io</p>
<h2 id="配置-SSH-密钥"><a href="#配置-SSH-密钥" class="headerlink" title="配置 SSH 密钥"></a>配置 SSH 密钥</h2><p>为了能将本地仓库推送到 GitHub 仓库, 需要使用 git 配置 SSH 密钥.<br>继续在 git bash 中输入以下命令:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置 Git 的全局用户名和邮箱.</span></span><br><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;邮箱地址&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 SSH 密钥对, 用于连接 GitHub 仓库.</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&#x27;上面的邮箱&#x27;</span></span><br></pre></td></tr></table></figure></div>

<p>接着按照提示, 按三次回车便可在指定的目录下生成 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件.</p>
<p>也可以使用 cat 命令查看密钥对内容:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></div>

<p>验证 SSH 密钥是否成功配置:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></div>

<p>如果出现 <code>Hi username! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code> 字样, 则说明 SSH 密钥配置成功.</p>
<p>将内容复制到 GitHub 仓库的 SSH and GPG keys 页面,<br>依次点击:</p>
<blockquote>
<p>头像&gt;Settings&gt;SSH and GPG keys&gt;New SSH key</p>
</blockquote>
<p>将刚刚的密钥粘贴到 Key 文本框中, 随后点击 Add SSH key 按钮.</p>
<h2 id="推送本地仓库到-GitHub"><a href="#推送本地仓库到-GitHub" class="headerlink" title="推送本地仓库到 GitHub"></a>推送本地仓库到 GitHub</h2><p>接着回到 博客根目录下的 <code>_config.yml</code> 配置文件配置参数.<br>拉到文件末尾, 填上以下配置.</p>
<div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com:用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></div>

<p>例如, 我的 Github 用户名是 Wreckloud, 则配置如下:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/hello-websites/file-20241225135716745.jpg"
                     
                ></p>
<p>最后,需要安装 <code>hexo-deployer-git</code> 插件, 运行以下命令:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></div>

<p>然后, 运行以下命令将本地仓库推送到 GitHub 仓库:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g    <span class="comment"># 先生成</span></span><br><span class="line">hexo d    <span class="comment"># 接着部署到Github上</span></span><br></pre></td></tr></table></figure></div>

<p>等待部署完成后, 就可以在浏览器中访问 <code>https://用户名.github.io</code> 访问你的博客了.</p>
<h1 id="写文章并上传"><a href="#写文章并上传" class="headerlink" title="写文章并上传"></a>写文章并上传</h1><p>新建文章:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>生成的文件会在 <code>source/_posts</code> 文件夹下.</p>
<p>文章是 Markdown 格式的, 编辑器推荐使用 Visual Studio Code, 它有丰富的插件支持 Markdown 语法高亮和自动补全.</p>
<p><a class="link"   href="https://markdown.com.cn/basic-syntax/" >markdown 语法<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://code.visualstudio.com/download" >Visual Studio Code 官网<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>文章保存后, 生成并部署到 Github 上, 我比较常用的命令是:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g -d <span class="comment"># 生成并部署到Github上</span></span><br></pre></td></tr></table></figure></div>

<h1 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h1><h2 id="文章属性自定义"><a href="#文章属性自定义" class="headerlink" title="文章属性自定义"></a>文章属性自定义</h2><p>Hexo 官方文档中有关于文章属性的详细介绍, 这里只介绍一些常用的属性:</p>
<div class="code-container" data-rel="Yml"><figure class="iseeu highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span> <span class="string">文章标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2023-09-17 13:50:59</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;标签1&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;标签2&quot;</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">&quot;分类&quot;</span></span><br><span class="line"><span class="attr">excerpt:</span> <span class="string">&quot;文章摘要&quot;</span></span><br><span class="line"><span class="attr">thumbnail:</span> <span class="string">&quot;文章缩略图&quot;</span></span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>文章属性自定义</p>

    </div>
    <div class="notel-content">
      <p><strong>文章时效性</strong><br>expires: 2023-08-31 23:59:59<br><strong>置顶文章:</strong><br>sticky: 值 (值越大,顶置文章越靠前)<br><strong>首页摘要:</strong><br>excerpt: “这是文章摘要”<br><strong>文章缩略图:</strong><br>thumbnail: “图片链接”<br><strong>文章头图:</strong><br>banner: “图片链接”<br>cover: “图片链接”</p>

    </div>
  </div>

<h3 id="文章模块"><a href="#文章模块" class="headerlink" title="文章模块"></a>文章模块</h3><p>此外,主题作者还加入了一些方便的模块让笔记更好看</p>
<p>例如 提示块, 选项卡等.<br>具体查看官网说明: <a class="link"   href="https://redefine-docs.ohevan.com/zh/modules/notes" >redefine 写作模块<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>方便自己随取随用的版本: [[常用物件存放处]]</p>
<h2 id="hexo-快速指令"><a href="#hexo-快速指令" class="headerlink" title="hexo 快速指令"></a>hexo 快速指令</h2><ol>
<li>创建一篇文章</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>运行网页</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line"><span class="comment"># 可以简写为</span></span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li>修改网页内容后重新生成网页</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li>部署到 github 的仓库</li>
</ol>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://hexo.io/" >关于 hexo 的更多信息<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br> <a class="link"   href="https://moren5483.github.io/2022/07/17/github/" >关于 hexo+github 仓库搭建博客<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<blockquote>
<p>希望能在这里留下一些有意思的东西!</p>
</blockquote>
]]></content>
      <categories>
        <category>啸月嗷声-成长</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>攻略</tag>
        <tag>网站</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>未命名小说</title>
    <url>/2025/04/19/%E9%A3%8E%E7%B5%AE%E8%8C%B8%E6%9D%82-%E6%94%B6%E9%9B%86/%E5%B0%8F%E8%AF%B4-%E6%9C%AA%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<p>今日破晓时分的寂静难得令人愉悦，我舒展着肩颈推开卧室门——</p>
<p>直到餐桌上的”艺术品”刺入眼帘。</p>
<hr>
<p>我盯着那根斜插的胫骨，晨光正沿着骨缝里干涸的血丝爬行。这匹狼甚至贴心地在骨腔里插了束野蔷薇——用他昨晚捕猎时撕裂的亚麻衬衫碎片扎成蝴蝶结，沾着露水的花瓣正往外滴落某种暗红色液体。</p>
<p>我捏着骨头的指尖开始发烫，已经数不清收到骸云”礼物”的次数。从沼泽巨蜥的毒牙到嵌着碎晶的岩龟壳，现在他居然学会给战利品做造型了。<br>那簇野蔷薇的根部还粘着可疑的暗红碎肉，让整个房间弥漫着铁锈与腐甜的死亡气息。<br>罪魁祸首就蜷在壁炉边，蓬松尾巴盖着鼻尖随呼吸起伏。</p>
<p>我揪住他后颈绒毛的瞬间，那对毛茸茸的耳朵立即软绵绵耷拉成投降姿势。</p>
<p>“早安气味。”<br>他喉咙里滚动出咕噜声，”木屑、铁锈和…愤怒的柠檬香？”</p>
<p>“说过多少次——“<br>我抄起作为礼物的腿骨抵住他抽动的鼻翼。<br>“没有人类会喜欢尸体当装饰品，”<br>“上个月你送给隔壁领主的礼物…”<br>我掰着他的下巴，好让这匹笨狼能够清醒些，”血淋淋的魔熊心脏？”</p>
<p>“是最珍贵的部位，嗷。”骸云挣扎着甩头，”人类不是用红色代表爱吗？”<br>他全然不知那张通缉令正贴在隔壁城镇的公会告示栏——那潦草的炭笔把他画得像头直立的山猪。</p>
<p>我握腿骨的手背暴起青筋，<br>面前这只灰狼貌似清醒了些，看见我手中握着的东西是朝着自己来的，弓着背往后缩。</p>
<p>“这是恐爪兽的胫骨！”他喉咙里挤出讨好的呼噜声，”能磨成三十支箭镞，或者…”<br>我猛地用骨头敲向他的脑门，清脆的”咚”声像打在包铁橡木盾上——这家伙头盖骨硬得能当砧板。<br>他发出幼犬被踩尾般的哀嚎，整具躯体蜷成一团滚到壁炉，哀嚎一声。</p>
<p>“装疼倒是越来越熟练了。”我大步靠近灰狼，一把揪住他的右耳说道。<br>“上次被石化蜥蜴撞飞三米都没见你哼一声。”<br>我抄起’礼物’戳向他真正脆弱的腰侧。<br>这匹比我还高的巨狼瞬间蜷成毛球，爆发的呜咽声震得壁炉灰簌簌下落。</p>
<p>…</p>
<hr>
<p>骸云被早起的突然袭击打败在地，委屈地趴在一旁。<br>烟雨抽出小刀削掉骨头上多余的肉，刀柄上磨损的狼牙硌着掌心。这是骸云用乳牙期脱落的犬齿打磨的礼物，当时这只笨蛋满脸是血叼着它出现，还以为自己要死于换牙了。<br>想到这里，烟雨还是决定原谅他。</p>
<p>“下次直接送花吧。”我扯了扯他垂落的尾巴尖，揪着他的耳朵说到，”人类更喜欢不会蠕动的东西。”</p>
<p>“好！”<br>骸云突然弹起来扑向我，耳朵突然竖成锥形，獠牙精准叼住我束发的皮绳。温热的舌头在离我脸颊半寸处急刹车，改成用鼻尖蹭我的下巴。<br>我确实警告过他管好自己沾满口水的舌头，看来他还记得。</p>
<p>“鼻子离我远点！”<br>我用手肘抵住他胸口，他趁机把毛茸茸的脑袋拱进我颈窝。<br>晨光在我们交叠的影子上织出金线，而餐桌上那支带牙印的野蔷薇，在胫骨里开得比任何魔法造物都鲜活。</p>
]]></content>
      <categories>
        <category>风絮茸杂-收集</category>
        <category>小说</category>
      </categories>
  </entry>
  <entry>
    <title>常用物件存放处</title>
    <url>/2024/12/25/%E5%95%B8%E6%9C%88%E5%97%B7%E5%A3%B0-%E6%88%90%E9%95%BF/%E5%8D%9A%E5%AE%A2-%E5%B8%B8%E7%94%A8%E7%89%A9%E4%BB%B6%E5%AD%98%E6%94%BE%E5%A4%84/</url>
    <content><![CDATA[<p>只是为了我使用方便和限制篇幅, 这里只展示例子, 详细使用方式请参考:<br><a class="link"   href="https://redefine-docs.ohevan.com/zh/modules/notes" >redefine 写作模块<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="提示块"><a href="#提示块" class="headerlink" title="提示块"></a>提示块</h1><h3 id="大号提示块"><a href="#大号提示块" class="headerlink" title="大号提示块"></a>大号提示块</h3><p>我常用的几个例子:</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>信息</p>

    </div>
    <div class="notel-content">
      <p>换行测试<br>换行测试<br>换行测试</p>

    </div>
  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% notel default fa-info 信息 %&#125;</span><br><span class="line">换行测试</span><br><span class="line">换行测试</span><br><span class="line">换行测试</span><br><span class="line">&#123;% endnotel %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large blue">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>提示</p>

    </div>
    <div class="notel-content">
      <p>换行测试<br>换行测试<br>换行测试</p>

    </div>
  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% notel blue 提示 %&#125;</span><br><span class="line">换行测试</span><br><span class="line">换行测试</span><br><span class="line">换行测试</span><br><span class="line">&#123;% endnotel %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>自定义标题</p>

    </div>
    <div class="notel-content">
      <p>换行测试<br>换行测试<br>换行测试</p>

    </div>
  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% notel red 自定义标题 %&#125;</span><br><span class="line">换行测试</span><br><span class="line">换行测试</span><br><span class="line">换行测试</span><br><span class="line">&#123;% endnotel %&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="小号提示块"><a href="#小号提示块" class="headerlink" title="小号提示块"></a>小号提示块</h3><p>我常用的几个例子:</p>

  <div class="note p-4 mb-4 rounded-small default">
    <p>default 提示块标签</p>

  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125; default 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small success">
    <p>success 提示块标签 </p>

  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% note success %&#125; success 提示块标签 &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small info">
    <p>info 提示块标签 </p>

  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% note info %&#125; info 提示块标签 &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small warning">
    <p>warning 提示块标签 </p>

  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% note warning %&#125; warning 提示块标签 &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small danger">
    <p>danger 提示块标签 </p>

  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% note danger %&#125; danger 提示块标签 &#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small red icon-padding">
    <i class="note-icon fa-solid fa-bolt"></i><p>自定义提示块标签 </p>

  </div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% note red fa-bolt%&#125; 自定义提示块标签 &#123;%endnote %&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h1><a class="button  [可选大小]" href='[url]' title='[名称]'><i class='[可选图标]'></i> [名称]</a>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% btn [可选大小]::[名称]::[url]::[可选图标] %&#125;</span><br></pre></td></tr></table></figure></div>

<p>不设置任何参数的 <a class="button " href='/' title='按钮'>按钮</a> 适合融入段落中。</p>
<p>regular 按钮适合独立于段落之外：</p>
<a class="button  regular" href='https://www.ohevan.com' title='示例博客'><i class='fa-solid fa-play-circle'></i> 示例博客</a>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% btn regular::示例博客::https://www.ohevan.com::fa-solid fa-play-circle %&#125;</span><br></pre></td></tr></table></figure></div>

<a class="button  regular" href='https://www.ohevan.com' title='示例博客'><i class='fa-solid fa-play-circle'></i> 示例博客</a>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% btn regular::示例博客::https://www.ohevan.com::fa-solid fa-play-circle %&#125;</span><br></pre></td></tr></table></figure></div>

<p>large 按钮更具有强调作用，建议搭配 center 使用：</p>
<a class="button  center large" href='https://redefine-docs.ohevan.com' title='开始使用'><i class='fa-solid fa-download'></i> 开始使用</a>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% btn center large::开始使用::https://redefine-docs.ohevan.com::fa-solid fa-download %&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="分栏选项卡"><a href="#分栏选项卡" class="headerlink" title="分栏选项卡"></a>分栏选项卡</h1><div class="tabs" id="tab-first-unique-name"><ul class="nav-tabs"><li class="tab active"><a class="#first-unique-name-1">First Tab</a></li><li class="tab"><a class="#first-unique-name-2">Second Tab</a></li><li class="tab"><a class="#first-unique-name-3">Third Tab</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-name-1"><p><strong>This is Tab 1.</strong></p></div><div class="tab-pane" id="first-unique-name-2"><p><strong>This is Tab 2.</strong></p>
<p>This is Tab 2.</p></div><div class="tab-pane" id="first-unique-name-3"><p><strong>This is Tab 3.</strong></p>
<p>This is Tab 3.</p>
<p>This is Tab 3.</p></div></div></div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% tabs First unique name %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab First Tab--&gt;</span><br><span class="line"></span><br><span class="line">**This is Tab 1.**</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab Second Tab--&gt;</span><br><span class="line"></span><br><span class="line">**This is Tab 2.**</span><br><span class="line"></span><br><span class="line">This is Tab 2.</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab Third Tab--&gt;</span><br><span class="line"></span><br><span class="line">**This is Tab 3.**</span><br><span class="line"></span><br><span class="line">This is Tab 3.</span><br><span class="line"></span><br><span class="line">This is Tab 3.</span><br><span class="line"></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中，<code>页面内不重复的ID</code>  为你为这个选项卡创建的唯一标识符，可以随便取。</p>
<p>每个栏目内容使用  <code>&lt;!-- tab 栏目名称 --&gt;</code>  和  <code>&lt;!-- endtab --&gt;</code>  来定义。</p>
]]></content>
      <categories>
        <category>啸月嗷声-成长</category>
        <category>博客</category>
      </categories>
  </entry>
  <entry>
    <title>远古卷轴</title>
    <url>/2024/04/16/%E9%A3%8E%E7%B5%AE%E8%8C%B8%E6%9D%82-%E6%94%B6%E9%9B%86/%E5%B0%8F%E8%AF%B4-%E8%BF%9C%E5%8F%A4%E5%8D%B7%E8%BD%B4/</url>
    <content><![CDATA[<h1 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h1><p>月光从树冠的獠牙间漏下来，在烟雨垂落的黑发上碎成细小的光斑。她单手拎着羊皮卷轴抖了抖：<br>「能看穿幻象的宝石，应该比你那火蜥蜴尾巴值钱些？」</p>
<p>一旁的狼人正蜷着后腿蹲坐在树根处，尾巴有一搭没一搭地拍打地面。他弓着脊背调试弓弦的姿态，总让人想到铁匠铺里歪斜的招牌。<br>「至少够赔尝上个月烧穿的旅店屋顶。。」</p>
<p>少女突然气愤地把卷轴怼到狼人鼻尖，陈旧的鞣制气味混着他皮毛间的松脂味扑面而来。狼人云的左耳猛地后折成投降的弧度，陈年羊皮的气味让他打了个喷嚏。<br>「那是谁非要叼着活火蜥蜴乱蹦的？」</p>
<p>狼人从喉咙里滚出委屈的呜咽，看样子是拒绝回答这个问题。</p>
<p>她不耐烦地抖了抖羊皮卷轴边缘<br>「还有这地图，你确定这鬼画符指的是东南方？」</p>
<p>「这可是用三张雪貂皮换的……」<br>「瘴气在东北角——大小姐，你地图拿反了。」</p>
<p>“”</p>
<p>为了寻找卷轴中所提到的那颗宝石, 一人一狼按照卷轴所指示的那样, 在这个满月之夜来到了迷雾森林.</p>
<p>「 就是这了, 云, 祭坛就在这迷雾深处. 」<br>少女对着身后的狼说道, 声音中带着一丝不易察觉的期待.<br>「 据卷轴记载, 掌管迷雾之力的宝石就在森林深处的祭坛之上. 」</p>
<p>「 听起来那宝石能值不少金币呢. 」<br>狼轻晃尾巴.<br>「没想到, 白天看起来平淡无奇的森林, 到了夜晚竟然是这个样子.」<br>「说起来这应该是我和烟雨头一次真正意义上的探险吧, 之前都只是接接冒险者工会的委托而已.」</p>
<p>「 哼, 就工会那点委托, 根本不足以让本小姐出汗的. 」</p>
<p>「 行了行了, 大小姐, 知道你很强了. 要是没有那些委托, 我俩早就流落街头了… 」<br>狼调侃道, 一边用指爪清点着箭袋中的羽毛箭矢.</p>
<p>「 流落街头吗… 」<br>少女眼中闪出一只落魄流浪狗的形象, 她想象着眼前这只狼那双原本锐利的野兽眼睛如今变得泛着水光. 可怜巴巴地缩在街边角落, 祈求着过往行人, 希望能得到一点点食物与怜悯.<br>而那只总是自信满满的狼兽人, 此刻只能低着失落的尾巴, 用湿漉漉的鼻头去嗅探着地上每一块面包屑.</p>
<p>「 哦, 一只落魄的流浪狗, 也不赖嘛! 」<br>少女嘴角上扬, 她知道这只会是一个幻想, 因为自打第一次见面, 她就决定与眼前这只狼患难与共了.</p>
<p>「 得了吧, 大小姐. 我可不会沦落到那种地步呢! 」<br>狼一脸苦笑着摇摇头.<br>挂好了箭袋, 随后他用长长的吻轻指面前的迷雾.</p>
<p>「 走吧. 」<br>少女回应到.</p>
<p>就这样, 少女与狼并肩踏入了迷雾之中, 踏上了寻找神秘宝石的冒险之旅, 他们的身影渐渐消失在迷雾中.</p>
<h1 id="PLOT-1"><a href="#PLOT-1" class="headerlink" title="PLOT 1"></a>PLOT 1</h1><p>随着少女烟雨和狼兽人云的脚步深入迷雾森林, 周围的景色越发朦胧, 仿佛整个世界都被一层轻纱所笼罩.<br>月光透过树梢, 洒在蜿蜒的道路上, 为他们指引着方向.<br>两人的心跳在这寂静的夜晚中回响, 伴随着他们前进的脚步, 一种难以言喻的紧张感在空气中弥漫开来.</p>
<p>两人走过一片灌木丛生的地带, 对于经验丰富的冒险者来说, 这里的每一个阴影都可能隐藏着危险.<br>烟雨和云都深知这一点.</p>
<p>就在这时, 一只史莱姆悄无声息地从灌木丛中现身.</p>
<p>少女只需与狼一个对视, 无需多言.</p>
<p>一记准确狼爪挥击, 甚至不需动用弓箭.</p>
<p>然而, 预料之外的是史莱姆并没有像往常那样一招毙命.<br>不过少女长刀在手, 她的身影快速优雅. 银色月华倾洒, 长刀如同划破夜空的流星，一闪即逝.<br>史莱姆利落地溶解在地面上, 轻烟归于迷雾, 只留下地面上闪着微光的粘液.</p>
<p>「 真是轻松. 」<br>暂时解除了危险, 她的身体放松, 倚靠在一旁长满苔藓的岩石上, 长发如墨般流淌.</p>
<p>「 月光强化了它们, 要多加小心了. 」<br>狼舔了舔爪子, 敏锐地辨别出了处境的异样.<br>随即他从背包中掏出小瓶子, 俯下身, 小心翼翼地将那特别的史莱姆粘液收集起来.<br>「 不过这貌似是特别的怪物素材, 要是卖给素材商的话, 不知道这能比一般的凝胶贵多少金币呢? 」<br>狼自言自语道.</p>
<p>「 月又提到金币了啊. 」<br>少女看着云, 心中难免感到不解.</p>
<p>烟雨从小与师傅在深山中长大, 习惯了自力更生的生活, 金币对她来说可有可无.<br>她也明白金币的价值.<br>毕竟自从她独自一人后, 少女也学着与他人交易和收集情报.</p>
<p>在她的认知中, 狼多以凶残狡诈描述, 很难与他们将 「贸易」 这个词相关联.<br>真的不会吓跑交易对象吗?</p>
<p>少女随意的目光落在狼身上, 那只专心致志地收集着粘液的狼.</p>
<p>这只来自寒冷北方的灰狼兽人, 励志成为一只能独当一面的吟游诗人而远飘到这里, 因此远离了自己的族群.<br>虽说在族群中他只是一只年轻的狼崽, 但要论体型, 还是比少女略大一些.</p>
<p>在烟雨看来, 云不过是一只看上去还算不太好惹的狗狗罢了. 对了, 还会自己打理自己的狗.<br>他那灰白的毛发在满月下泛着银色的光泽, 尾巴随意摆动, 看上去稍微有点高兴的样子.</p>
<p>看来 「 人不可貌相 」 确实有道理.<br>或者说, 「 <strong>狼</strong> 」不可貌相?<br>烟雨心中暗想.</p>
<p>此时, 少女心生一计, 目光似笑非笑地盯着狼.<br>随后轻手轻脚地走向云, 尽可能地不发出任何声响.<br>她的手悄无声息地接近云的尾巴, 然后突然一把抓住.</p>
<p>云先是吃惊, 然后猛地一跳, 本能地想摆脱束缚, 手中的瓶子也因此翻倒在地.<br>恶作剧得逞的少女嘴角勾起一抹得意的弧度, 肩膀因偷笑轻轻颤抖着.</p>
<p>「 你知道吗? 你的尾巴真的很好抓! 」<br>她的声音轻快而充满戏虐.</p>
<p>得知是中了烟雨的计谋后, 狼嘴里发出低沉的抗议声.<br>「 放开我, 粘液全撒啦! 」<br>狼不满地吼道.</p>
<p>少女却毫无征兆地松手, 失去重心的灰狼一头扑倒在地.<br>「 这可真是’狼’狈啊, 骸云. 」<br>她走向倒地的灰狼身边, 如往常那般, 戏虐灰狼.</p>
<p>灰狼抱怨着低吼, 明显是不满少女刚刚的举措.<br>重获自由的狼要给少女一个教训, 立刻转身扑向少女.</p>
<p>而少女根本扛不住扑面而来的狼, 跌倒在泥土与草地中, 但她一点也不介意, 反手揉搓着面前这只灰狼的毛茸茸的脸.<br>粗糙的皮毛下隐藏着温暖, 野兽的眼中全是对少女不满.</p>
<p>尽管迷雾森林中仍然涌动着危险, 两人依旧打闹着.<br>不久, 两人收拾好心情, 向着迷雾的深处继续前行.</p>
<h1 id="PLOT-2"><a href="#PLOT-2" class="headerlink" title="PLOT 2"></a>PLOT 2</h1><p>深入迷雾的心脏地带, 烟雨和云的步伐变得更加谨慎.<br>森林深处的小径崎岖不平, 树木的轮廓在月光下若隐若现. 一人一狼小心地穿行在迷雾与灌木中, 树叶在夜风中沙沙作响.</p>
<p>烟雨感受着每一丝风的变化, 她黑色的长发随风飘动, 如同夜色中的流苏. 云的耳朵不时转动, 金黄的眼在黑暗中闪烁着狼的光芒.<br>随着他们深入, 魔物的威胁也愈来棘手.<br>好在烟雨还有余力应付战斗, 她的身姿灵活, 手中的长刀在月光下闪烁着寒光. 云也默契地配合着少女的战斗, 不时使用弓箭辅佑着少女.</p>
<p>经过一番跋涉, 他们最终顺利地来到了远古卷轴所指示的地点 ———— 一个由古老石碑围成的圆形空地.<br>祭坛中的每个石碑刻满了复杂的纹路, 结构古老而庄严.<br>而在中央的石质台座上, 正是迷雾森林所隐藏的宝石, 宝石散发出充满魔力的光辉, 周围空气扭曲着, 显然是一块拥有强大力量的宝石.</p>
<p>「 看! 烟雨, 那块宝石就是我们的战利品了! 」<br>云兴奋地说道, 他手脚并用, 迫不及待地奔向那诱人的宝物.</p>
<p>「 小心, 没那么简单! 」 烟雨警觉地观察四周, 周围的空气湿润而寒冷, 她注意到一股不详的气流从背后袭来.<br>只见一只幽灵狼蓄势待发, 它的眼睛是两团蓝色的火焰, 透露着饥渴和狡猾.</p>
<p>烟雨紧握长刀, 她敏锐的直觉告诉自己, 眼前这只生物并不如之前在迷雾中所遇到的那样简单, 不过现在也无退路可言, 只能走一步看一步了.</p>
<p>「 看来你的亲戚来迎接我们了! 」 危急时刻, 少女都不忘调侃一下狼.</p>
<p>「 哼, 我与这种野蛮的家伙可没什么关系! 」<br>狼紧拉弓弦, 发出低沉的咆哮, 蓄势待发.</p>
<p>「 那么, 有教养的狼先生, 我们能尝试和它沟通吗? 」 烟雨戏谑地问道.</p>
<p>幽灵狼四肢紧贴地面, 肌肉紧绷. 意识到自身行动已经败露, 便发出一声愤怒的咆哮, 向两人扑来.</p>
<p>看来「谈判」破裂了, 战斗一触即发.</p>
<p>幽灵狼的攻击迅猛无比, 云的箭矢很难在迷雾中击中目标. 烟雨不甘示弱, 少女的身影月下穿梭, 她的长刀与幽灵狼的爪牙交错.<br>刀锋一次次触及幽灵狼的身体, 少女的长刀虽然准确锋利, 但对这些半实体的生物来说, 似乎只能造成暂时的伤害.</p>
<p>「 挥砍对它毫无作用! 」 烟雨心中一紧.</p>
<p>狼吹奏长笛, 悦耳的笛声冲破迷雾, 淡蓝色的微光包裹了烟雨的长刀, 为烟雨的攻击附加魔力.<br>「 那试试这样呢! 」</p>
<p>少女将剑舞动, 剑间划过幽灵狼. 瞬时, 一道光芒烙印留在了幽灵狼的腰部, 使其发出痛苦的嚎叫.<br>「 起作用了! 」</p>
<p>少女接着发动一系列攻击, 节节败退的幽灵狼向后撤步, 随之对着月亮发出嚎叫.<br>「 不好! 它这是在召集同伴! 烟雨, 快阻止它! 」 云很清楚, 他明白这声嚎叫的意义.<br>少女迅速的一击挥砍, 将嚎叫的幽灵狼斩断, 使其归于迷雾之中.</p>
<p>「 结束了. 」<br>两人喘息着.</p>
<h1 id="PLOT-3"><a href="#PLOT-3" class="headerlink" title="PLOT 3"></a>PLOT 3</h1><p>「 … 」</p>
<p>结束了…吗?<br>由黑暗所编织的幻影生物如同梦魇般涌现, 它们那双可怖的眼在迷雾中散发出的邪恶蓝色火光.</p>
<p>狼压低身体, 后颈毛发悚立, 耳朵后撇, 发出低吼声警告着危险.<br>「 更多的幽灵来了! 」</p>
<p>一道黑影快速接近少女, 没有丝毫犹豫地, 长刀破空的呼啸声伴随着锐利的笛声, 淡蓝的弧光, 暗影散化迷雾, 融入森林中.</p>
<p>「 现身吧! 」<br>她的声音回荡在森林之中, 紧接着暗影生物如同潮水般汹涌而至, 长刀少女的眼神中没有丝毫恐惧.<br>「 放马过来吧! 无论你们有多少, 我永远不会退缩! 」<br>她挥舞着长刀, 干净利落, 刀光如银蛇般划过, 准备将暗影生物一一斩断.</p>
<p>一人一狼并肩站立, 准备迎接即将到来的挑战.</p>
<p>「 … 」</p>
<p>战斗持续了一段时间, 激烈的程度超出了烟雨和云的预期.<br>幽灵狼的数量似乎无穷无尽, 烟雨可以感觉到长刀上来自云的魔力正在逐渐减弱, 自己的额头上也布满了汗珠, 每一次呼吸都变得沉重.<br>她后退了几步, 将长刀插入地面.</p>
<p>「 这样僵持下去, 不是办法… 」<br>少女咬紧牙关, 如果不能找到突破口, 两人也许会沦陷于此.</p>
<p>刚准备再次迎战的少女, 忽然注意到手中长刀的异样.</p>
<p>长刀认出了迷雾, 刀刃映照着雾气, 闪烁着淡淡的月光.<br>「 这是… 」<br>烟雨心中涌起一股莫名的感觉, 仿佛长刀本身就是迷雾的一部分, 与这片森林息息相关.</p>
<p>迷雾如同有生命一般, 开始涌动, 缭绕在少女周围, 然后猛地冲向少女.</p>
<p>少女的意识被某种强大的力量吞噬, 身体失去了平衡, 摇摇欲坠.</p>
<p>「 烟雨! 」<br>云的呼喊划破了夜空, 他动作比思考的要快, 迅速冲上前去, 烟雨稳稳地落入狼的双臂中.</p>
<p>「 你怎么了! 」<br>云焦急询问少女情况, 但少女没有回应. 他的心中涌起一股前所未有的恐慌.<br>狼知道, 单凭自己根本敌不过这群暗影生物.</p>
<p>冷静, 冷静…<br>云深吸一口气, 试图平复自己急促的呼吸.<br>在这危急时刻, 他的心中涌现出一丝决绝, 开始念动咒语.<br>现在能做的就只有拖延时间.</p>
<p><strong>「 银月之光, 汇聚于此 – Luminous Veil 光之护盾术! 」</strong></p>
<p>稀薄的魔力开始聚集, 一道光明结界将两人包裹.</p>
<p>幽灵狼先是感受到威胁, 它们开始围绕结界, 警惕地在寻找突破的方式.<br>当第一只领头幽灵狼开始攻击结界时, 其他的幽灵狼也纷纷加入攻击.</p>
<p>光芒结界裂开些微缝隙.</p>
<p>这样下去撑不了多久! 只能使出那一招了, 狼心想, 将少女平稳地放在地上.<br>又做了几次深呼吸, 狼的眼神变得专注, 唇边轻启, 吹响长笛.<br>随着笛声的响起, 魔力汇聚速度加快, 但幽灵狼随之也发起了愈加猛烈的攻击.</p>
<p>「 烟雨! 快醒醒! 」<br>云焦急地呼唤着烟雨.<br>「 可恶, 现在可不是开玩笑的时候! 」</p>
<h1 id="PLOT-4"><a href="#PLOT-4" class="headerlink" title="PLOT 4"></a>PLOT 4</h1><p>「 … 」</p>
<p>「 这是… 」</p>
<p>这是年幼的烟雨.<br>树木茂密, 这里是少女最久远的那部分记忆.<br>年幼的她身处同样的森林, 同样的夜晚. 迷雾依旧不散, 她很难过, 踌躇不安.</p>
<p>一阵悠扬的笛声在记忆的森林中逐渐清晰, 烟雨便顺着那引导的旋律, 一步步走向前.</p>
<p>「 真美… 」</p>
<p>随着笛声越来越清晰，那些久远的回忆也逐渐清晰…</p>
<p>这片森林是烟雨曾经被遗弃的森林, 是谁将她遗弃? 为何将她遗弃?<br>少女唯一明白的就是仍深深烙印在她的心中的那份痛苦和绝望.</p>
<p>「 … 」</p>
<p>千钧一发之际, 烟雨的手指微微动了动, 她的意识开始逐渐回归.</p>
<p>回过神来, 眼前是奋力施展结界抵抗敌人的灰狼.<br>狼的力量即将耗尽, 步伐沉重. 但他依旧弓起身体, 试图让自己看起来更加庞大, 强装着威慑.</p>
<p>抬手间, 长刀便回归少女手中, 新的力量在长刀中涌动.</p>
<p>「 你.. 烟雨, 你没事吧. 」 狼已经接近极限.</p>
<p>「 没事了, 已经没事了… 」</p>
<p>少女望着眼前数不尽的敌人, 只是轻蔑地一笑, 她已迫不及待地想尝试自己的新力量了.<br>她感觉到了手中长刀的变化, 那把名为「静寂之风」的武器似乎与这片迷雾森林产生了某种神秘的联系, 它渴望着释放出自己的力量.</p>
<p>就在这时, 光芒结界终究还是支撑不住幽灵狼的猛烈攻击, 一声清脆的碎裂声.<br>云的魔力枯竭, 陷入昏迷状态.</p>
<p>「 吾之长剑, 天命所归, 此刻, 就让我烟雨来终结这片混沌! 」</p>
<h1 id="FINAL"><a href="#FINAL" class="headerlink" title="FINAL"></a>FINAL</h1><p>少女站起身来, 身姿优美而凌厉, 步伐稳健, 灵活而迅猛.<br>击破结界的幽灵狼一拥而上, 她没有丝毫的畏惧. 长刀如同划破夜空的流星, 每一次挥舞都带着风与月光的印记, 将一只又一只的幽灵狼斩于刀下.</p>
<p>直奔少女喉咙的利齿, 被她侧身一闪, 顺势劈中其后颈, 风烙印于伤口上, 一击致命;<br>另一只妄图近身扑咬, 但少女敏锐转身, 一记横劈, 将它的身体从头到尾切成两半, 不留一丝让其复原的机会.</p>
<p>一只又一只的幽灵狼哀嚎着倒地, 烟雨似乎还没尽兴.<br>最后一只幽灵狼嘶吼着扑来, 但少女不退反进.</p>
<p>「 哼, 真是自不量力. 」</p>
<p>她将长刀直插入幽灵狼的胸膛, 光芒贯穿幽灵狼的身体, 随着其发出最后的嘶吼, 最后一只幽灵狼也归于烟尘.</p>
<p>「 结束了! 」<br>少女伸伸懒腰, 长刀归鞘, 将祭坛上失去光泽的蓝色宝石放入背包中.<br>「 话说, 迷雾宝石怎么看着跟一般宝石没区别呢? 」</p>
<p>看来, 宝石之能, 已悄然潜入长刀深处, 如宿命之轨轻启, 静待时光之轮缓缓旋转.</p>
<p>黑暗中的恶灵被击退, 森林的迷雾也随之退散. 满月西沉, 树木的轮廓渐渐清晰, 草地上的露珠闪烁, 如同坠到地上的星晨.</p>
<p>少女双手靠近刚刚搭建起的简易篝火, 稍事休息.<br>她望向一旁熟睡的狼, 心中一丝慰藉.<br>狼静静地蜷缩着, 他的呼吸平稳规律, 伴随着胸腔轻轻的起伏.</p>
<p>「 真是辛苦你了, 好好休息吧, 好梦. 」<br>烟雨轻轻地凑近骸云的耳边.<br>「 我的狼. 」</p>
<p>篝火舒缓的噼啪声在夜空中回荡, 空气中弥漫着令人安心的泥土芬芳和木烟燃烧.<br>黎明即将到来, 东方的天空渐渐泛起一丝淡淡的红色, 夜晚的黑暗渐渐被驱散.</p>
<pre class="mermaid">stateDiagram-v2
    [*] --> 未参加
    未参加 --> 已报名 : 提交报名
    已报名 --> 训练中 : 开始训练
    训练中 --> 请假中 : 申请请假
    请假中 --> 训练中 : 结束请假
    训练中 --> 受伤暂停 : 受伤报告
    受伤暂停 --> 训练中 : 恢复训练
    训练中 --> 已完成 : 完成训练
    已完成 --> [*]</pre>]]></content>
      <categories>
        <category>风絮茸杂-收集</category>
        <category>小说</category>
      </categories>
      <tags>
        <tag>烟雨与云</tag>
        <tag>原创角色</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机原理与应用</title>
    <url>/2024/09/30/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E5%B5%8C%E5%85%A5%E5%BC%8F-51%E5%8D%95%E7%89%87%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="51单片机介绍"><a href="#51单片机介绍" class="headerlink" title="51单片机介绍"></a>51单片机介绍</h1><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先需要安装几个软件</p>
<a class="button  center large" href='https://www.123684.com/s/bCMjVv-z6ot' title='开始使用'><i class='fa-solid fa-download'></i> 开始使用</a>
<h4 id="安装-Keil-集成开发环境"><a href="#安装-Keil-集成开发环境" class="headerlink" title="安装 Keil 集成开发环境"></a>安装 Keil 集成开发环境</h4><p>Keil 是用来写 C 语言程序的, 它还可以将程序编译成单片机可以识别的指令集.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E4%B8%8B%E8%BD%BDkeil.png"
                      alt="alt text"
                ></p>
<h4 id="STC-ISP-安装"><a href="#STC-ISP-安装" class="headerlink" title="STC-ISP 安装"></a>STC-ISP 安装</h4><p>STC-ISP 可以将编译好的程序下载到单片机中, 以让程序能在单片机运行.</p>
<h4 id="USB驱动"><a href="#USB驱动" class="headerlink" title="USB驱动"></a>USB驱动</h4><p>安装了串口驱动后 STC-ISP 才能识别单片机.</p>
<blockquote>
<p>由于我已经安装的时候没有截图写教程, 所以先就不写详细的安装步骤了(</p>
</blockquote>
<h3 id="51-单片机简介"><a href="#51-单片机简介" class="headerlink" title="51 单片机简介"></a>51 单片机简介</h3><p>单片机(MicrocontrollerUnit, MCU)算一种袖珍版计算机, 一个芯片就能构成完整的计算机系统.<br>单片机成本低, 体积小, 结构简单. 在学习使用单片机的过程中, 可以快速了解计算机原理与其结构.  </p>
<p>Intel 公司推出了 8051 单片机内核, 因此这种类似于 8051 内核的单片机, 我们都统称为 51 单片机.  </p>
<p>51 单片机的<br>位数: 8位.<br>RAM: 512字节.<br>ROM: 8K (Flash).<br>工作频率: 12Mhz.  </p>
<blockquote>
<p>RAM: 随机存取存储器, 用于存储程序和数据(会丢失数据, 相当于工作台).<br>ROM: 只读存储器, 用于存储程序(长期存储, 相当于仓库).  </p>
</blockquote>
<h3 id="单片机内部结构图"><a href="#单片机内部结构图" class="headerlink" title="单片机内部结构图"></a>单片机内部结构图</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/51%E5%8D%95%E7%89%87%E6%9C%BA.png"
                      alt="alt text"
                ></p>
<blockquote>
<p>乱七八糟的我也不爱看</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E5%8D%95%E7%89%87%E6%9C%BA.png"
                      alt="alt text"
                ></p>
<h1 id="LED-灯控制"><a href="#LED-灯控制" class="headerlink" title="LED 灯控制"></a>LED 灯控制</h1><h3 id="新建一个-Keil-工程"><a href="#新建一个-Keil-工程" class="headerlink" title="新建一个 Keil 工程"></a>新建一个 Keil 工程</h3><p>为了方便导入和管理代码:</p>
<p>首先, 在电脑中新建一个文件夹, 作为所有 Keil 工程的存放位置.<br>然后, 打开 Keil 软件, 新建第一个工程文件夹.  </p>
<p>如果不这么做, 文件就会散成一团(</p>
<p>接着, 如图所示.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE.png"
                      alt="alt text"
                ></p>
<p>然后在跳出的对话框中选中 Atmel 下的 AT89C52.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E9%80%89%E6%8B%A9%E6%A0%B8%E5%BF%83.png"
                      alt="alt text"
                ></p>
<p>会有一个对话框询问是否自动创建开始文件.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E5%AF%B9%E8%AF%9D%E6%A1%86.png"
                      alt="alt text"
                ></p>
<p>推荐选 <code>否</code> ,选了是影响也不大.</p>
<p>接着, 我们要在项目中添加一个 .c 的文件, 作为程序的入口.<br>由于这个版本的 keil 不能直接新建, 所以我们得先在 <strong>系统的文件管理器</strong> 中新建文件.</p>
<p>在文件管理器中找到项目文件夹, 右键新建一个文件, 命名为 <code>main.c</code>.</p>
<p>然后在 keil 中将这个 <code>main.c</code> 文件添加到工程中.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%B7%BB%E5%8A%A0%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6.png"
                      alt="alt text"
                ></p>
<p>这样, 工程就新建完成了!  </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%88%90%E5%8A%9F.png"
                      alt="alt text"
                ></p>
<p>接下来就可以开始编写代码了.</p>
<p>为了能在程序编译好后能直接得到 .hex 文件, 我们还得在 Keil 中设置一下编译选项.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E7%BC%96%E8%AF%91%E8%AE%BE%E7%BD%AE.png"
                      alt="alt text"
                ></p>
<p>在 <code>Output</code> 选项卡中, 勾选 <code>Create HEX file</code>.</p>
<h3 id="LED-灯控制-1"><a href="#LED-灯控制-1" class="headerlink" title="LED 灯控制"></a>LED 灯控制</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/LED.png"
                      alt="alt text"
                ></p>
<p>LED 灯是指发光二极管, 它只允许电流从一个方向通过.</p>
<blockquote>
<p>当我们把电池的正极接到P型材料这一端, 负极接到N型材料这一端时, 电流就可以顺利通过LED.<br>因为电子和空穴可以分别从N型和P型材料流向对方, 然后在中间的PN结区域相遇并复合, 发出光来.<br>反之, 电子和空穴都被推向相反的方向, 就无法发光了.</p>
</blockquote>
<p>在开发板中, LED模块连接如图所示:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/LED%E6%8E%A5%E7%BA%BF.png"
                      alt="alt text"
                ></p>
<p>如图所示, LED 模块有八个 LED 灯. 右边接在 VCC ,也就是电源的正极, 左边与单片机的 P2(P2.0~P2.7) 引脚相连.</p>
<p>在 LED 与 电源正极 之间 有两个 1K 的电阻, 起到限流的作用, 防止 LED 灯发光过强而烧毁.</p>
<h4 id="如何点亮-LED-灯"><a href="#如何点亮-LED-灯" class="headerlink" title="如何点亮 LED 灯?"></a>如何点亮 LED 灯?</h4><p>为了让 LED 灯点亮, 需要在 LED 的阳极和阴极之间形成电流的通路.<br>已知 LED 灯的一侧接通的是电源正极, 我们只要能控制另一端引脚的电压即可.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    P2 = <span class="number">0xFE</span>; <span class="comment">// 1111 1110 16进制为0xFE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但程序并不认识 <code>P2</code> 这个寄存器, 这时只需要导入头文件即可.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regx52.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    P2 = <span class="number">0xFE</span>; <span class="comment">// 1111 1110 16进制为0xFE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个头文件中就有 <code>P2</code> 这个寄存器的定义.</p>
<p>接着, 将写好的程序编译成 .hex 文件, 下载到单片机中.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9F.png"
                      alt="alt text"
                ></p>
<h4 id="LED-流水灯"><a href="#LED-流水灯" class="headerlink" title="LED 流水灯"></a>LED 流水灯</h4><p>让 8 个 LED 灯依次点亮, 然后再依次熄灭.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REG52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>		</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(xms)</span><br><span class="line">	&#123;</span><br><span class="line">	i = <span class="number">500</span>;</span><br><span class="line">	<span class="keyword">while</span> (--i);</span><br><span class="line">	xms--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P2 = <span class="number">0xFE</span>; </span><br><span class="line">        Delay(<span class="number">800</span>);</span><br><span class="line">        P2 = <span class="number">0xFD</span>; </span><br><span class="line">        Delay(<span class="number">400</span>);</span><br><span class="line">        P2 = <span class="number">0xFB</span>; </span><br><span class="line">        Delay(<span class="number">200</span>);</span><br><span class="line">        P2 = <span class="number">0xF7</span>; </span><br><span class="line">        Delay(<span class="number">100</span>);</span><br><span class="line">        P2 = <span class="number">0xEF</span>; </span><br><span class="line">        Delay(<span class="number">100</span>);</span><br><span class="line">        P2 = <span class="number">0xDF</span>; </span><br><span class="line">        Delay(<span class="number">200</span>);</span><br><span class="line">        P2 = <span class="number">0xBF</span>; </span><br><span class="line">        Delay(<span class="number">400</span>);</span><br><span class="line">        P2 = <span class="number">0x7F</span>; </span><br><span class="line">        Delay(<span class="number">800</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<h4 id="单独操作位寄存器"><a href="#单独操作位寄存器" class="headerlink" title="单独操作位寄存器"></a>单独操作位寄存器</h4><p>在头文件 <code>regx52.h</code> 中, 我们可以看到寄存器的定义.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">sbit P2_0 = <span class="number">0xA0</span>;</span><br><span class="line">sbit P2_1 = <span class="number">0xA1</span>;</span><br><span class="line">...</span><br><span class="line">sbit P2_7 = <span class="number">0xA7</span>;</span><br></pre></td></tr></table></figure></div>

<p>我们可以直接操作这些寄存器.</p>
<blockquote>
<p>注意在 <code>reg52.h</code> 中并没有定义, 需要自己声明.</p>
</blockquote>
<h1 id="独立按键"><a href="#独立按键" class="headerlink" title="独立按键"></a>独立按键</h1><p>按钮在单片机中的接线如图所示:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%8C%89%E9%92%AE.png"
                      alt="alt text"
                ></p>
<p>按钮一端接地(电源负极), 另一端接接在单片机的 IO 口上. 当单片机接电时, IO 口为高电平, 按钮按下, 电路导通, IO 口变为低电平.</p>
<blockquote>
<p>即 按钮按下, IO 口为 ‘0’.<br>按钮松开, IO 口为 ‘1’.</p>
</blockquote>
<h3 id="按键的抖动"><a href="#按键的抖动" class="headerlink" title="按键的抖动"></a>按键的抖动</h3><p>对于机械开关,当机械触点断开, 闭合时,由于机械触点的弹性作用, 一个开关在闭合时不会马上稳定地接通, 在断开时也不会立马完全断开, 所以在开关闭合及断开的瞬间会伴随一连串的抖动.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%8C%89%E9%92%AE%E6%8A%96%E5%8A%A8.png"
                      alt="alt text"
                ></p>
<p>最方便的解决方法就是检测到按下时让程序延时一段时间即可.</p>
<p>用按钮控制 LED 灯亮灭:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REG52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个延时函数, 抹除抖动的影响.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>		</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(xms)</span><br><span class="line">	&#123;</span><br><span class="line">	i = <span class="number">500</span>;</span><br><span class="line">	<span class="keyword">while</span> (--i);</span><br><span class="line">	xms--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P2 = <span class="number">0xFE</span>; <span class="comment">// 点亮全部 LED 灯</span></span><br><span class="line">        <span class="keyword">if</span>(P2_0 == <span class="number">0</span>)&#123; <span class="comment">// 按下按钮</span></span><br><span class="line">            P2 = <span class="number">0x00</span>; <span class="comment">// 熄灭全部 LED 灯</span></span><br><span class="line">        &#125;</span><br><span class="line">        Delay(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div>

<h1 id="定时器-计数器"><a href="#定时器-计数器" class="headerlink" title="定时器&#x2F;计数器"></a>定时器&#x2F;计数器</h1><p>在之前, 我们使用的是 <code>Delay()</code> 函数来延时, 但这种方式很不精确, 而且会占用主程序, 无法在 <code>Delay()</code> 函数执行时执行其他任务.</p>
<p>定时器就能用来实现精确的延时, 其电路的连接和运转均在单片机内部完成.</p>
<p>在 STC89C52 中, 有 T0, T1, T2 这三个定时器.<br>T0 和 T1 与传统的 51单片机 兼容, T2 则是此型号单片机增加的资源.</p>
<p>除了用作定时, 它也可用作计数器.</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>定时器在单片机内部就像一个小闹钟. 根据时钟的输出信号, 每隔 <code>一个时间段</code>, 计数单元的数值就会增加一.<br>当计数单元数值增加到 <code>设定的提醒时间</code> 时, 计数单元就会向 <code>中断系统</code> 发出中断申请, 使程序跳转到中断服务函数中执行.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E6%9D%A5.png"
                      alt="alt text"
                ></p>
<blockquote>
<p><code>中断系统</code> 类似于 <code>定时器</code>, 也是单片机内部的资源.</p>
</blockquote>
<p>STC89C52 的 <code>定时器/计数器</code> T0, T1 都有如下几种工作模式:</p>
<ul>
<li>模式0: 13 位定时器&#x2F;计数器</li>
<li>模式1: 16 位定时器&#x2F;计数器 (常用)</li>
<li>模式2: 8 位自动重装模式</li>
<li>模式3: 两个 8 位计数器</li>
</ul>
<p>工作模式 1 的框图:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%A1%86%E5%9B%BE.png"
                      alt="alt text"
                ></p>
<h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><p>如图, 在计数器里有</p>
<ul>
<li>TL(Timer Low) : 低字节</li>
<li>TH(Timer High): 高字节</li>
</ul>
<p>两个字节, 它们总共可以存储 65536 个不同的数值.</p>
<p><code>时钟模块</code> 稳定地给 <code>计数器</code> 脉冲. 每来一次脉冲, 计数器就会增加 1.<br>直到 计数数到 65536 , 计数器溢出, 置一个标志位, 并向 <code>中断系统</code> 发出中断申请.</p>
<h4 id="定时器时钟"><a href="#定时器时钟" class="headerlink" title="定时器时钟"></a>定时器时钟</h4><p>系统时钟, 即晶振周期.</p>
<h4 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h4><p>中断系统是为使 CPU 具有对外界紧急事件的实时处理能力而设置的.  </p>
<p>请示 CPU 中断的请求称为中断源, 中断源的轻重缓急称之为中断优先级.<br>高优先级的中断可以打断低优先级的中断.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F%E5%85%AD%E6%88%90.png"
                      alt="alt text"
                ></p>
<p>不同型号的单片机拥有不同的中断资源.<br>在 STC89C52 中, 中断源共有 8 个.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F.png"
                      alt="alt text"
                ></p>
<p>不使用定时器依然可以实现延时, 可以通过查询 TF0 标志位.<br>就像你一直需要检查你的钟一样.</p>
<p>中断号:</p>
<table>
<thead>
<tr>
<th>中断源</th>
<th>中断服务函数</th>
<th>中断号</th>
</tr>
</thead>
<tbody><tr>
<td>外部中断0</td>
<td>Int0_Routine(void)</td>
<td>interrupt 0;</td>
</tr>
<tr>
<td>定时器0</td>
<td>Timer0_Routine(void)</td>
<td>interrupt 1;</td>
</tr>
<tr>
<td>外部中断1</td>
<td>Int1_Routine(void)</td>
<td>interrupt 2;</td>
</tr>
<tr>
<td>定时器1</td>
<td>Timer1_Routine(void)</td>
<td>interrupt 3;</td>
</tr>
<tr>
<td>串口中断</td>
<td>UART_Routine(void)</td>
<td>interrupt 4;</td>
</tr>
<tr>
<td>定时器2</td>
<td>Timer2_Routine(void)</td>
<td>interrupt 5;</td>
</tr>
<tr>
<td>外部中断2</td>
<td>Int2_Routine(void)</td>
<td>interrupt 6;</td>
</tr>
<tr>
<td>外部中断3</td>
<td>Int3_Routine(void)</td>
<td>interrupt 7;</td>
</tr>
</tbody></table>
<h2 id="定时器相关的寄存器"><a href="#定时器相关的寄存器" class="headerlink" title="定时器相关的寄存器"></a>定时器相关的寄存器</h2><p>寄存器是连接软硬件的桥梁, 相当于一个复杂机器的操作按钮.</p>
<p>在单片机中寄存器就是一段特殊的 RAM 存储器.<br>一方面, 寄存器可以存储和读取数据,<br>另一方面, 每一个寄存器背后都连接了一根导线, 控制着电路的连接方式.</p>
<h3 id="TCON-定时器控制寄存器"><a href="#TCON-定时器控制寄存器" class="headerlink" title="TCON 定时器控制寄存器"></a>TCON 定时器控制寄存器</h3><p>TCON(Timer Control) 为定时器&#x2F;计数器 T0, T1 的<strong>控制寄存器</strong>, 同时也锁存 T0, T1 溢出中断源和外部请求中断源等.<br>TF1, IE1, IT1等, 控制<code>定时器 T1</code>;IE0, TF0, IT0等 控制<code>定时器 T0</code>.  </p>
<blockquote>
<p>TCON 可位寻址, 因此能单独操作 TCON 寄存器的各个位.</p>
</blockquote>
<p>TCON 格式如下:</p>
<table>
<thead>
<tr>
<th>SFR name</th>
<th>Address</th>
<th>bit</th>
<th>B7</th>
<th>B6</th>
</tr>
</thead>
<tbody><tr>
<td>TCON</td>
<td>88H</td>
<td>name</td>
<td>TF1</td>
<td>TR1</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>B5</th>
<th>B4</th>
<th>B3</th>
<th>B2</th>
<th>B1</th>
<th>B0</th>
</tr>
</thead>
<tbody><tr>
<td>TF0</td>
<td>TR0</td>
<td>IE1</td>
<td>IT1</td>
<td>IE0</td>
<td>IT0</td>
</tr>
</tbody></table>
<ul>
<li>TF(Timer Flag): <code>定时器/计数器 </code> <strong>溢出标志</strong>. 当 <code>定时器</code> 的最高位高位产生溢出时, 会由硬件将 TF 置为 1 ,然后向 CPU 请求中断. 直到 CPU 响应 此中断后, 才由硬件将 TF1 复位为 0.</li>
<li>TR(Timer Run): <code>定时器/计数器 </code> 的<strong>运行控制位</strong>, 该位由软件置位和清零. 0 时停止计数, 1 时开始计数.</li>
<li>IE(Interrupt Enable): <code>定时器/计数器 </code> 的 <strong>中断使能位</strong>. IE1 &#x3D; 1 时外部中断向 CPU 请求中断, 当 CPU 响应该中断时, 由硬件清 0.</li>
<li>IT(Interrupt Type): <code>定时器/计数器 </code> 的 <strong>中断类型位</strong>. 0 时为边沿触发, 1 时为电平触发.</li>
</ul>
<h3 id="TMOD-定时器工作模式寄存器"><a href="#TMOD-定时器工作模式寄存器" class="headerlink" title="TMOD 定时器工作模式寄存器"></a>TMOD 定时器工作模式寄存器</h3><p>定时和计数功能由特<strong>殊功能寄存器</strong> TMOD(Timer Mode) , 控制着 C&#x2F;~T 进行选择.</p>
<blockquote>
<p>TMOD 不可位寻址, 只能整体赋值.</p>
</blockquote>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>GATE</td>
<td>C&#x2F;~T</td>
<td>M1</td>
<td>M0</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>GATE</td>
<td>C&#x2F;~T</td>
<td>M1</td>
<td>M0</td>
</tr>
</tbody></table>
<p>其中, 0<del>3 是定时器0的工作模式, 4</del>7 是定时器1的工作模式.</p>
<p>可以看出, 两个定时器各有四种操作模式, 分别是:</p>
<table>
<thead>
<tr>
<th>位</th>
<th>符号</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>TMOD.7&#x2F;<br>TMOD.3&#x2F;</td>
<td>GATE</td>
<td>控制定时器 T1, 当 GATE&#x3D;1 , 需 INT1脚 为高 且 TR1&#x3D;1 时, 才可打开 定时器T1.<br>控制定时器 T0, 当 GATE&#x3D;1 , 需 INT0脚 为高 且 TR0&#x3D;1 时, 才可打开 定时器T0.</td>
</tr>
<tr>
<td>TMOD.6&#x2F;<br>TMOD.2&#x2F;</td>
<td>C&#x2F;~T</td>
<td>控制模式为 <strong>定时(&#x3D; 0)</strong> 还是 <strong>计数(&#x3D; 1)</strong>.</td>
</tr>
<tr>
<td>TMOD.5 &amp; TMOD.4</td>
<td>M1 &amp; M0</td>
<td>控制定时器 T1 的工作模式.</td>
</tr>
<tr>
<td>TMOD.1 &amp; TMOD.0</td>
<td>M1 &amp; M0</td>
<td>控制定时器 T0 的工作模式.</td>
</tr>
</tbody></table>
<p>M1, M0 共两位, 能用来选择定时器的工作模式.<br>具体的工作模式如下:</p>
<table>
<thead>
<tr>
<th>M1</th>
<th>M0</th>
<th>工作模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>模式0:<br>13位定时器&#x2F;计数器</td>
<td>兼容 8084 定时模式, TL只用低 5 位参与分频, TH1 整个 8 位全用.</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>模式1:<br>16位定时器&#x2F;计数器</td>
<td>TL,TH 整个 16 位全用.</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>模式2:<br>8位自动重装模式</td>
<td>当溢出时将 TH1 存放的值自动装入 TL1.</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>模式3:<br>无效</td>
<td>停止计数.</td>
</tr>
</tbody></table>
<h3 id="使用定时器实现-LED-闪烁"><a href="#使用定时器实现-LED-闪烁" class="headerlink" title="使用定时器实现 LED 闪烁"></a>使用定时器实现 LED 闪烁</h3><p>接下来实践一下, 用定时器实现每隔 <strong>一秒</strong> 闪烁一次 LED 灯.</p>
<p>已知 计时器最大只能为 65535 ,我们先让计时器计数 1000 次时就溢出, 也就是先计 1微秒.<br>将计时器的初值设置为 64535 即可.</p>
<p>然后将这个 1微秒 的计时器重复 1000 次, 就是一个一秒的计时器了.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Init</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 设置 TMOD定时器工作模式(不能寻址, 只能整体赋值)</span></span><br><span class="line">	TMOD = <span class="number">0x01</span>; <span class="comment">// 0000 0001 将模式设置为模式1, 使用整个TL0和TH0..</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置 TCON定时器控制寄存器(能寻址, 可以单独赋值)</span></span><br><span class="line">	TF0 = <span class="number">0</span>; </span><br><span class="line">	TR0 = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将 64535 赋值给定时器0, 先把64535分成高8位和低8位, 然后分别赋值给TH0和TL0.</span></span><br><span class="line">	TH0 = <span class="number">64535</span>/<span class="number">256</span>;</span><br><span class="line">	TL0 = <span class="number">64535</span>%<span class="number">256</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 打开中断系统</span></span><br><span class="line">	ET0 = <span class="number">1</span>;</span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">	PT0 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Timer0_Init; <span class="comment">// 启动配置好的定时器0</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> T0Counter = <span class="number">0</span>; <span class="comment">// 定义一个计算定时器执行了多少次的变量, 以让1毫秒的计时器重复1000次.</span></span><br><span class="line"><span class="comment">// 定时器0中断服务程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Routine</span><span class="params">()</span> interrupt 1 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新校对计时器, 保证下一次计时也是 1毫秒</span></span><br><span class="line">    TH0 = <span class="number">64535</span>/<span class="number">256</span>;</span><br><span class="line">	TL0 = <span class="number">64535</span>%<span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    T0Counter++; </span><br><span class="line">    <span class="keyword">if</span> (T0Counter &gt;= <span class="number">1000</span>)&#123;</span><br><span class="line">        T0Counter = <span class="number">0</span>;</span><br><span class="line">        P2_0 = ~P2_0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="TMOD-缺陷"><a href="#TMOD-缺陷" class="headerlink" title="TMOD 缺陷"></a>TMOD 缺陷</h3><p>当需要使用两个定时器时, 又由于 TMOD 只能整体赋值, 所以当给其中一个定时器赋值时, 会对另一个定时器造成影响.  </p>
<p>因此, 我们这样修改代码:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旧代码: TMOD = 0x01; 0000 0001, 会影响 T1 的工作模式.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新思路: 只操作 T0 的工作模式.</span></span><br><span class="line">TMOD = TMOD &amp; <span class="number">0x0F</span>; <span class="comment">// 0000 1111 , 把 TMOD 低四位清零, 保留 T1 的工作模式.</span></span><br><span class="line">TMOD = TMOD | <span class="number">0x01</span>; <span class="comment">// 0000 0001 , 给 TMOD 低四位赋值, 使 T0 的工作模式为模式1.</span></span><br></pre></td></tr></table></figure></div>

<p>在数字电路中, 任何数 &amp; 1,都等于自身, 任何树 &amp; 0, 都等于 0.<br>利用这个特征, 我们可以只操作需要赋值的定时器.</p>
<p>让其只操作需要赋值的定时器即可.</p>
<p>在 STC-ISP 软件, 可以很方便地配置定时器: </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E8%87%AA%E5%8A%A8%E8%AE%A1%E7%AE%97%E5%AE%9A%E6%97%B6%E5%99%A8.png"
                      alt="alt text"
                ></p>
<ul>
<li>89C52 是没有 16位自动重载的. 只有 16位 或 8位自动重载.</li>
<li>定时器时钟选中 12T</li>
<li>生成的代码没有配置中断系统, 记得加上:</li>
<li>生成的代码针对新系列单片机, 会有 <code>AUXR</code> 寄存器, 但是我们在学习的单片机没有, 因此记得删除.</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">EA = <span class="number">1</span>; <span class="comment">// 打开总中断</span></span><br><span class="line">ET0 = <span class="number">1</span>; <span class="comment">// 打开定时器0中断</span></span><br><span class="line">PT0 = <span class="number">0</span>; <span class="comment">// 设置优先级为0</span></span><br></pre></td></tr></table></figure></div>

<h1 id="数码管"><a href="#数码管" class="headerlink" title="数码管"></a>数码管</h1><p>LED 数码管是一种简单, 廉价的显示器, 是由多个发光二极管封装在一起组成 “8” 自型的器件.</p>
<p>LED 连接方式有两种</p>
<ul>
<li>共阴极</li>
<li>共阳极</li>
</ul>
<p>也就只是一种连接方式而已, 了解即可.</p>
<p>想要使单个 数码管 显示数字, 根据其接线口, 可以很轻易推出显示数字的值.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%95%B0%E7%A0%81%E7%AE%A1.png"
                      alt="alt text"
                ></p>
<p>例如想要显示数字 1, 则将 b, c 赋值为1.<br>赋值时注意 高位是从 DP 开始. 例如 1 就该赋值为 0000 0110.</p>
<p>其他的数字同理:</p>
<table>
<thead>
<tr>
<th>显示数字</th>
<th>二进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0011 1111</td>
<td>0x3F</td>
</tr>
<tr>
<td>1</td>
<td>0000 0110</td>
<td>0x06</td>
</tr>
<tr>
<td>2</td>
<td>0101 1011</td>
<td>0x5B</td>
</tr>
<tr>
<td>3</td>
<td>0100 1111</td>
<td>0x4F</td>
</tr>
<tr>
<td>4</td>
<td>0110 0110</td>
<td>0x66</td>
</tr>
<tr>
<td>5</td>
<td>0110 1101</td>
<td>0x6D</td>
</tr>
<tr>
<td>6</td>
<td>0111 1101</td>
<td>0x7D</td>
</tr>
<tr>
<td>7</td>
<td>0000 0111</td>
<td>0x07</td>
</tr>
<tr>
<td>8</td>
<td>0111 1111</td>
<td>0x7F</td>
</tr>
<tr>
<td>9</td>
<td>0110 1111</td>
<td>0x6F</td>
</tr>
<tr>
<td>A</td>
<td>0111 1011</td>
<td>0x77</td>
</tr>
<tr>
<td>B</td>
<td>0111 1110</td>
<td>0x7C</td>
</tr>
<tr>
<td>C</td>
<td>0011 1001</td>
<td>0x39</td>
</tr>
<tr>
<td>D</td>
<td>0101 1110</td>
<td>0x5E</td>
</tr>
<tr>
<td>E</td>
<td>0111 1001</td>
<td>0x79</td>
</tr>
<tr>
<td>F</td>
<td>0111 1111</td>
<td>0x71</td>
</tr>
<tr>
<td>空</td>
<td>1111 1111</td>
<td>0x00</td>
</tr>
</tbody></table>
<p>四位一体数码管在单片机上接线如图所示:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/LED%E6%98%BE%E7%A4%BA%E5%99%A8%E6%8E%A5%E7%BA%BF.png"
                      alt="alt text"
                ></p>
<p>如图, 数码管的一端连接着 74HC254 , 能进行数据缓冲.  </p>
<p>由于高电平的驱动能力有限, 因此信号传输都用低电平完成. 但是直接用低电平点亮LED, 效果并不理想.<br>因此, 这个数据缓冲就是用来提高驱动能力的.<br>我们用低电平发送信号, 然后由这个数据缓冲器把信号提高到高电平来驱动 LED.</p>
<p>数码管的另一边接的就是 138 译码器, 是一种3线-8线译码器: </p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/138%E8%AF%91%E7%A0%81%E5%99%A8.png"
                      alt="alt text"
                ></p>
<p>138 译码器 只用三个 IO 端(A&#x2F;P2_2, B&#x2F;P2_3, C&#x2F;P2_4) , 就可以控制八个输出端.</p>
<p>它的工作原理是:</p>
<table>
<thead>
<tr>
<th>A, B, C</th>
<th>输出</th>
</tr>
</thead>
<tbody><tr>
<td>000</td>
<td>0 (LED 8)</td>
</tr>
<tr>
<td>001</td>
<td>1 (LED 7)</td>
</tr>
<tr>
<td>010</td>
<td>2 (LED 6)</td>
</tr>
<tr>
<td>011</td>
<td>3 (LED 5)</td>
</tr>
<tr>
<td>100</td>
<td>4 (LED 4)</td>
</tr>
<tr>
<td>101</td>
<td>5 (LED 3)</td>
</tr>
<tr>
<td>110</td>
<td>6 (LED 2)</td>
</tr>
<tr>
<td>111</td>
<td>7 (LED 1)</td>
</tr>
</tbody></table>
<p>选中的输出端, 就会输出0.</p>
<h3 id="点亮一个-LED-数码管"><a href="#点亮一个-LED-数码管" class="headerlink" title="点亮一个 LED 数码管"></a>点亮一个 LED 数码管</h3><p>那么一个 LED 数码管, 究竟是怎么样被点亮的呢?</p>
<p>第一步就是通过 138 译码器, 通过这三个口, 使某一位输出为 0 ,选中要显示的LED.<br>接下来通过缓冲送来的信号, 驱动 LED 点亮.</p>
<p>例如, 点亮 LED6, 使其显示数字 6, :<br>代码实现:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 选中 LED6 -&gt; </span></span><br><span class="line">	P2_4=<span class="number">1</span>;</span><br><span class="line">	P2_3=<span class="number">0</span>;</span><br><span class="line">	P2_2=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设定显示的数字</span></span><br><span class="line">	P0=<span class="number">0x7D</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>设计一个数码管显示数字的函数:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设计一个数组存储每个数字对应的二进制数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> numToHex[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>,<span class="number">0x77</span>,<span class="number">0x7C</span>,<span class="number">0x39</span>,<span class="number">0x5E</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"><span class="comment">// 设定显示在哪一个数码管上, 以及要显示的数字</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location, num)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(Location)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: <span class="comment">// 数码管8 -&gt; 000</span></span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: </span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: </span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: </span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    P0=numToHex[num]; <span class="comment">// 设定显示的数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="多位数码管动态显示"><a href="#多位数码管动态显示" class="headerlink" title="多位数码管动态显示"></a>多位数码管动态显示</h3><p>由于其设计, 数码管无法做到同时显示多个数字.<br>但是我们可以快速切换显示的数字, 只要切换的足够迅速, 利用人眼的视觉暂留效应, 就可以看到”同时”显示多个数字.</p>
<p>不过如果我们直接这样写</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用刚刚设计的函数 displayNum()</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        displayNum(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 在第一个数码管显示数字 1</span></span><br><span class="line">        displayNum(<span class="number">2</span>, <span class="number">2</span>); </span><br><span class="line">        displayNum(<span class="number">3</span>, <span class="number">3</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>会出现 数码管的残影:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%95%B0%E7%A0%81%E7%AE%A1%E6%AE%8B%E5%BD%B1.jpg"
                      alt="alt text"
                ></p>
<p>影响数字辨认.</p>
<p>这是由于数码管显示数字时, 会先选位选(选择要在哪个数码管上显示), 然后再段选(选择要显示的数字).  </p>
<blockquote>
<p>位选 –&gt; 段选 –&gt; 位选 –&gt; 段选 –&gt; …</p>
</blockquote>
<p>由于这个过程十分迅速, 就会导致数码管串位显示, 数字显示在了错误的位置上.</p>
<p>为了解决这个问题, 可以这样做: </p>
<blockquote>
<p>位选 –&gt; 段选 –&gt; 清零 –&gt; 位选 –&gt; 段选 –&gt; 清零 –&gt; …</p>
</blockquote>
<p>代码层面, 我们可以优化一下 displayNum() 函数:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> numToHex[]=&#123;<span class="number">0x3F</span>,<span class="number">0x06</span>,<span class="number">0x5B</span>,<span class="number">0x4F</span>,<span class="number">0x66</span>,<span class="number">0x6D</span>,<span class="number">0x7D</span>,<span class="number">0x7F</span>,<span class="number">0x6F</span>,<span class="number">0x77</span>,<span class="number">0x7C</span>,<span class="number">0x39</span>,<span class="number">0x5E</span>,<span class="number">0x79</span>,<span class="number">0x71</span>,<span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>		</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(xms)</span><br><span class="line">	&#123;</span><br><span class="line">	i = <span class="number">500</span>;</span><br><span class="line">	<span class="keyword">while</span> (--i);</span><br><span class="line">	xms--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">displayNum</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Location, num)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(Location)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: </span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: </span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: </span><br><span class="line">            P2_4=<span class="number">0</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">0</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">            P2_4=<span class="number">1</span>;P2_3=<span class="number">1</span>;P2_2=<span class="number">1</span>;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    P0=numToHex[num]; </span><br><span class="line">	Delay(<span class="number">5</span>);</span><br><span class="line">    P0=numToHex[<span class="number">0</span>]; <span class="comment">// 清零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		displayNum(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		displayNum(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">		displayNum(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h3><p>众所周知, 程序员最不喜欢一直做重复的事. 像之前提到的 Delay(), 我们可以把它封装成一个函数, 然后在其他地方调用, 就不用每次都要写一遍.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/51%E5%8D%95%E7%89%87%E6%9C%BA/%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B.png"
                      alt="alt text"
                ></p>
<h4 id="C预编译"><a href="#C预编译" class="headerlink" title="C预编译"></a>C预编译</h4><p>C语言的预编译以 # 开头, 作用是在珍珠的编译开始之前, 对代码做一些预处理(预编译)</p>
<table>
<thead>
<tr>
<th>预编译</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>#include</td>
<td>包含头文件</td>
</tr>
<tr>
<td>#define</td>
<td>定义常量</td>
</tr>
<tr>
<td>#ifndef</td>
<td>防止头文件重复包含</td>
</tr>
<tr>
<td>#endif</td>
<td>结束头文件包含</td>
</tr>
</tbody></table>
<p>接下来, 尝试一下将之前写的 Delay() 函数模块化.</p>
<p>首先创建工程, 完成一些基本操作:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;REGX52.H&gt;</span> <span class="comment">// &lt;&gt; 表示在安装目录寻找头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span> <span class="comment">// &quot;&quot; 表示在当前工程目录寻找头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        Dlay(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后在工程目录下创建 delay.h 和 delay.c 文件:</p>
<p>delay.c 存放函数实现:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个延时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>		</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(xms)</span><br><span class="line">	&#123;</span><br><span class="line">	i = <span class="number">500</span>;</span><br><span class="line">	<span class="keyword">while</span> (--i);</span><br><span class="line">	xms--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>delay.h 存放函数声明:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __DELAY_H__ <span class="comment">// 命名一般以这样的形式定义, 全大写, 下划线分隔.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __DELAY_H__ <span class="comment">// 防止头文件重复包含,如果没有这个名字, 就创建.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> xms)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure></div>

<h1 id="矩阵键盘"><a href="#矩阵键盘" class="headerlink" title="矩阵键盘"></a>矩阵键盘</h1>]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>单片机</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>windows命令行与批处理</title>
    <url>/2024/11/30/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-windows%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8E%E6%89%B9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><h2 id="cmd-与-PowerShell"><a href="#cmd-与-PowerShell" class="headerlink" title="cmd 与 PowerShell"></a>cmd 与 PowerShell</h2><p>Windows 有两个命令行 shell：<strong>Command shell(CMD)</strong> 和  <strong>PowerShell</strong>.<br>而 shell 都是一个软件程序, 可实现一些自动化 IT 操作的环境.</p>
<p>CMD 是 Windows 中内置的第一个 shell.<br>PowerShell 旨在扩展 CMD 的功能.</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>命令行不区分大小写</li>
<li>命令行按上下键可以查看历史命令</li>
<li>Tab 键可以自动补全命令</li>
<li>使用 <code>/?</code> 或 <code>/help</code> 可以查看命令用法，用法中的<code>[]</code>代表可选</li>
</ul>
<p>以下, 将列出常用的功能以便我自己翻阅.</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>命令基本格式为:</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">命令 参数列表</span><br></pre></td></tr></table></figure></div>

<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>echo</code></td>
<td>显示</td>
<td></td>
</tr>
<tr>
<td><code>pause</code></td>
<td>暂停</td>
<td><code>pause &gt; nul</code></td>
</tr>
<tr>
<td><code>cls</code></td>
<td>清屏</td>
<td></td>
</tr>
<tr>
<td><code>exit</code></td>
<td>退出</td>
<td></td>
</tr>
</tbody></table>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>type</code></td>
<td>显示文件内容</td>
<td><code>type 1.txt</code></td>
</tr>
<tr>
<td><code>find</code></td>
<td>查找字符串</td>
<td><code>find &quot;abc&quot; 2.txt</code></td>
</tr>
<tr>
<td><code>fc</code></td>
<td>比较文件内容</td>
<td><code>fc 1.txt 2.txt</code></td>
</tr>
<tr>
<td><code>date</code></td>
<td>显示&#x2F;修改日期</td>
<td><code>date /T</code></td>
</tr>
<tr>
<td><code>time</code></td>
<td>显示&#x2F;修改时间</td>
<td><code>time /T</code></td>
</tr>
<tr>
<td><code>ping</code></td>
<td>网络连接测试</td>
<td><code>ping www.baidu.com</code></td>
</tr>
<tr>
<td><code>ipconfig</code></td>
<td>TCP&#x2F;IP 信息</td>
<td></td>
</tr>
<tr>
<td><code>set /a</code></td>
<td>计算表达式</td>
<td><code>set /a 6%4</code></td>
</tr>
<tr>
<td><code>shutdown</code></td>
<td>关机</td>
<td><code>shutdown /s /t 60</code></td>
</tr>
</tbody></table>
<h3 id="多命令"><a href="#多命令" class="headerlink" title="多命令"></a>多命令</h3><ul>
<li><code>&amp;</code> 顺序执行多条命令，不管命令是否执行成功</li>
<li><code>&amp;&amp;</code> 顺序执行多条命令，前面的命令错误则不执行后面的命令</li>
<li><code>||</code> 顺序执行多条命令，碰到执行正确的命令后将不执行后面的命令</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">abc &amp; <span class="built_in">dir</span> &amp; bcd</span><br><span class="line">abc &amp;&amp; <span class="built_in">dir</span> &amp;&amp; bcd</span><br><span class="line">abc || <span class="built_in">dir</span> || bcd</span><br></pre></td></tr></table></figure></div>

<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><ul>
<li><code>&gt;</code> 输出重定向</li>
<li><code>&gt;&gt;</code> 追加重定向</li>
<li><code>&lt;</code> 输入重定向</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">date</span> /t &gt; 1.txt</span><br><span class="line">time /t &gt;&gt; 1.txt</span><br><span class="line">find <span class="string">&quot;/&quot;</span> &lt; 1.txt</span><br></pre></td></tr></table></figure></div>

<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul>
<li><code>|</code> 前一个命令的输出作为后一个命令的输入</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span> | find <span class="string">&quot;txt&quot;</span></span><br></pre></td></tr></table></figure></div>

<h2 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h2><p><strong>路径分隔符</strong>：<code>\</code></p>
<p><strong>当前目录</strong>：<code>.</code></p>
<p><strong>上一级目录</strong>：<code>..</code></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td><code>dir</code></td>
<td>显示文件夹内容</td>
<td><code>dir /A</code></td>
</tr>
<tr>
<td><code>tree</code></td>
<td>显示文件夹树形结构</td>
<td><code>tree /F</code></td>
</tr>
<tr>
<td><code>盘符:</code></td>
<td>进入指定磁盘</td>
<td><code>c:</code> <code>d:</code></td>
</tr>
<tr>
<td><code>cd</code></td>
<td>切换目录</td>
<td><code>cd test</code> <code>cd ..</code></td>
</tr>
<tr>
<td><code>mkdir</code>或<code>md</code></td>
<td>创建目录</td>
<td><code>mkdir test</code></td>
</tr>
<tr>
<td><code>rmdir</code>或<code>rd</code></td>
<td>删除目录</td>
<td><code>rmdir test</code></td>
</tr>
<tr>
<td><code>del</code></td>
<td>删除文件</td>
<td><code>del 1.txt</code> <code>del /q/a/f *.txt</code></td>
</tr>
<tr>
<td><code>rename</code>或<code>ren</code></td>
<td>重命名</td>
<td><code>rename a.txt b.txt</code></td>
</tr>
<tr>
<td><code>copy</code></td>
<td>复制文件</td>
<td><code>copy a\1.txt b\1.txt</code></td>
</tr>
<tr>
<td><code>move</code></td>
<td>移动文件&#x2F;重命名</td>
<td><code>move a\1.txt 2.txt</code></td>
</tr>
</tbody></table>
<h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off		<span class="comment"># 关闭回显</span></span><br><span class="line">......</span><br><span class="line">pause			<span class="comment"># 暂停。或 pause &gt; nul</span></span><br></pre></td></tr></table></figure></div>

<h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><ul>
<li>双击运行</li>
<li>在 cmd 中运行（可以传参）</li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置变量</span></span><br><span class="line"><span class="built_in">set</span> 变量名=变量值</span><br><span class="line"><span class="built_in">set</span> /a 变量名=表达式</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消变量</span></span><br><span class="line"><span class="built_in">set</span> 变量名=</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印变量</span></span><br><span class="line"><span class="built_in">set</span> 变量名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出变量</span></span><br><span class="line"><span class="built_in">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用变量</span></span><br><span class="line">%变量名%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入变量值</span></span><br><span class="line"><span class="built_in">set</span> /p 变量名=提示文字</span><br></pre></td></tr></table></figure></div>

<h3 id="预定义的变量"><a href="#预定义的变量" class="headerlink" title="预定义的变量"></a>预定义的变量</h3><table>
<thead>
<tr>
<th>变量名</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td><code>%cd%</code></td>
<td>当前目录</td>
</tr>
<tr>
<td><code>%date%</code></td>
<td>当前日期</td>
</tr>
<tr>
<td><code>%time%</code></td>
<td>当前时间</td>
</tr>
<tr>
<td><code>%random%</code></td>
<td>0~32767 之间的随机数</td>
</tr>
<tr>
<td><code>%path%</code></td>
<td>环境变量</td>
</tr>
<tr>
<td><code>%errorlevel%</code></td>
<td>上一个命令的返回值，0 表示执行成功</td>
</tr>
<tr>
<td><code>%0</code>、<code>%1</code>、<code>%2</code>……</td>
<td>参数。<code>%0</code>表示命令名</td>
</tr>
</tbody></table>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">call 可执行文件 [参数列表]</span><br></pre></td></tr></table></figure></div>

<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [not] 条件 (</span><br><span class="line">	语句块</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">	语句块</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件：</span></span><br><span class="line">errorlevel number	<span class="comment"># 上一个程序的返回值大于等于number则为true</span></span><br><span class="line">string1==string2	<span class="comment"># 两个字符串匹配则为true</span></span><br><span class="line">exist filename		<span class="comment"># 文件名存在则为true</span></span><br><span class="line">[/I] string1 compare-op string2		<span class="comment"># 比较数值或字符串</span></span><br><span class="line">	<span class="comment"># /I	忽略大小写</span></span><br><span class="line">	<span class="comment"># compare-op包括：</span></span><br><span class="line">	<span class="comment">#	equ	等于</span></span><br><span class="line">	<span class="comment"># 	neq	不等于</span></span><br><span class="line">	<span class="comment">#	lss	小于</span></span><br><span class="line">	<span class="comment">#	leq	小于等于</span></span><br><span class="line">	<span class="comment">#	gtr	大于</span></span><br><span class="line">	<span class="comment">#	geq	大于等于</span></span><br><span class="line">defined variable	<span class="comment"># 如果定义了该变量则为true</span></span><br></pre></td></tr></table></figure></div>

<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">goto label		<span class="comment"># 跳转到标签所在行</span></span><br><span class="line">:label			<span class="comment"># 标签以冒号开头</span></span><br></pre></td></tr></table></figure></div>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><strong>基本语法</strong></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (<span class="built_in">set</span>) <span class="keyword">do</span> (</span><br><span class="line">	语句块</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环变量用 %% 指定，只能是单字母</span></span><br><span class="line"><span class="comment"># set表示文件集合（也可以是空文件），元素之间以逗号或空格分隔，支持通配符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (a,b,c) <span class="keyword">do</span> (<span class="built_in">echo</span> %%i)</span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (*.*) <span class="keyword">do</span> (<span class="built_in">echo</span> %%i)</span><br></pre></td></tr></table></figure></div>

<p><strong>扩展语法</strong></p>
<ul>
<li><p>只遍历文件夹</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /d %%i <span class="keyword">in</span> (<span class="built_in">set</span>) <span class="keyword">do</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>遍历指定文件夹下的所有文件，不指定则表示当前目录。如果 set 为<code>.</code>表示枚举目录树</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /r [[drive:]path] %%i <span class="keyword">in</span> (<span class="built_in">set</span>) <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> /r %%i <span class="keyword">in</span> (*) <span class="keyword">do</span> (<span class="built_in">echo</span> %%i)</span><br><span class="line"><span class="keyword">for</span> /r d:\up %%i <span class="keyword">in</span> (.) <span class="keyword">do</span> (<span class="built_in">echo</span> %%i)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>遍历数字序列</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /l %%i <span class="keyword">in</span> (start,step,end) <span class="keyword">do</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>遍历文件内容</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> /f [<span class="string">&quot;options&quot;</span>] %%i <span class="keyword">in</span> (<span class="built_in">set</span>) <span class="keyword">do</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">?		<span class="comment"># 单个字符</span></span><br><span class="line">*		<span class="comment"># 任意字符</span></span><br></pre></td></tr></table></figure></div>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>按顺序为文件夹中的文件命名。</p>
<p><a class="link"   href="https://blog.csdn.net/Dandelion_gong/article/details/78067501" >批处理中 for 循环的自增自减问题_Dandelion_gong 的博客-CSDN 博客_bat for 自增<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line"><span class="built_in">set</span> cnt=0</span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (%1) <span class="keyword">do</span> (</span><br><span class="line">    rename %%i !cnt!.txt</span><br><span class="line">    <span class="built_in">set</span> /a cnt=!cnt! + 1</span><br><span class="line">)</span><br><span class="line">pause</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础语法</title>
    <url>/2024/03/30/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Java-简介"><a href="#Java-简介" class="headerlink" title="Java 简介"></a>Java 简介</h1><p><strong>Java 是一门面向对象编程语言, 其特点是:</strong></p>
<p>面向对象三大特征: <strong>封装</strong> <strong>继承</strong> <strong>多态</strong><br>面向对象基本概念: <strong>类</strong> <strong>对象</strong> <strong>方法</strong> <strong>属性</strong></p>
<blockquote>
<p>常说的 Java 三大版本是:<br><strong>Java SE(Standard Edition)</strong> 标准版, 面向桌面应用的开发环境.<br><strong>Java EE(Enterprise Edition)</strong> 企业版, 面向企业级应用的开发环境.<br><strong>Java ME(Micro Edition)</strong> 微型版, 面向移动终端的开发环境.</p>
</blockquote>
<h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>开发 Java 程序必须先安装好 JDK, JDK 其中也包含了常见的开发工具, 以及 JRE</p>
<ul>
<li>JDK(Java Development Kit): 开发工具包, 包含开发环境, 编译器, 类库, 工具等.</li>
<li>JRE(Java Runtime Environment): 运行环境, 包含 Java 虚拟机(JVM), 类库, 工具等.</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241221131919122.jpg"
                     
                ></p>
<p>在选择版本时, 选择官方指定的长期支持版 LTS 版本(Long Term Support)</p>
<p><a class="link"   href="https://www.oracle.com/cn/java/technologies/downloads/#java21" >官方下载地址<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="集成开发环境"><a href="#集成开发环境" class="headerlink" title="集成开发环境"></a>集成开发环境</h3><p>集成开发环境(Intergrated Development Environment) IDE, 是集成了代码编写功能、分析功能、编译功能、调试功能等一体化集成环境的开发软件.</p>
<p>目前 Java 开发最知名, 最常用的 IDE 就是 Jetbrain 公司出品的<a class="link"   href="https://www.jetbrains.com/idea/" >Intellij IDEA<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>了.</p>
<p><a class="link"   href="https://www.jetbrains.com/idea/download/" >IntelliJ IDEA 下载<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a><br><a class="link"   href="https://3.jetbra.in/" >IntelliJ IDEA 激活<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p>IDEA 中有很多快捷键可以提高我们的开发效率，常见的有：</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>CTRL + D</td>
<td>复制一行</td>
</tr>
<tr>
<td>CTRL + Y</td>
<td>删除当前行</td>
</tr>
<tr>
<td>CTRL + ALT + L</td>
<td>格式化代码风格</td>
</tr>
<tr>
<td>ALT + SHIFT + ↑，ALT + SHIFT+ ↓</td>
<td>上下移动当前代码</td>
</tr>
<tr>
<td>CTRL + &#x2F;，CTRL + SHIFT + &#x2F;</td>
<td>注释选中的代码</td>
</tr>
</tbody></table>
<h3 id="Java-程序结构"><a href="#Java-程序结构" class="headerlink" title="Java 程序结构"></a>Java 程序结构</h3><p>Java 程序通常由以下几部分组成：</p>
<ul>
<li>方法（Method）: 程序<strong>最基本的功能单位</strong>, 例如计算器上的 ‘+’ 就包含一个求和的<strong>方法</strong>.</li>
<li>类（Class）: 功能相关联的<strong>方法</strong>放在一起, 就是一个 <strong>类</strong>.</li>
<li>包（Package）: 将<strong>类</strong>按照功能模块划分到一个个<strong>不同目录</strong>中, 这些目录称为<strong>包</strong>.</li>
<li>项目&#x2F;工程（Project）: 最后再把所有的<strong>包</strong>放到一个目录中管理，整个目录称之为<strong>项目</strong>或<strong>工程</strong>.</li>
</ul>
<p>特别注意程序的入口, main 方法.<br>程序启动后都会去执行 main 方法, 然后再通过 main 方法调用其它方法.</p>
<p>因此：任何程序都必须写一个<strong>main</strong>方法，而且 main 方法的写法是固定的：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="Java-程序运行原理"><a href="#Java-程序运行原理" class="headerlink" title="Java 程序运行原理"></a>Java 程序运行原理</h1><p>作为程序员编写的, 是由很多英文单词和符号组成的源代码, 是方便人类读写的.<br>计算机目前无法直接理解这种语言, 它只能识别简单的指令.</p>
<p>Java 的解决方式是将 程序员写好的 .java 文件, 使用编译器转换为 .class 文件, 让虚拟机 JVM 转换为机器码以可在计算机上运行.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241221145002966.jpg"
                     
                ></p>
<p>这种提前准备好的指令集, 一旦编译完成, 就可以在没有编译器的帮助下独立运行的语言类型, 我们称之为:</p>
<p><strong>编译型语言</strong></p>
<p>由于 Java 虚拟机的存在, Java 语言可以很轻易地运行在任意平台上.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241221145639854.jpg"
                     
                ></p>
<p>在 CMD 中, 使用</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">javac java文件.java</span><br></pre></td></tr></table></figure></div>

<p>编译 .java 文件<br>接着使用:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java java文件</span><br></pre></td></tr></table></figure></div>

<p>将刚刚编译后生成的 .class 文件运行<br>这就是不使用集成开发环境手动编译和运行的过程.</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>用于在源代码中解释代码, 不会被执行.</p>
<p>写注释是一个好习惯, 不然刚写完的代码只有自己和上帝能, 过几天就只剩上帝能看得懂了…<br>注释有三种写法:</p>
<ol>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一行单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	而这个就是多行注释,</span></span><br><span class="line"><span class="comment">	只要在这两个符号内的文字都会被认定为注释</span></span><br><span class="line"><span class="comment">	...</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这就是文档注释</span></span><br><span class="line"><span class="comment"> * 它可以用在类, 方法, 字段上 来解释其作用</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div>

<p>在 idea 中<br>快捷键 <code>ctrl</code>+<code>/</code> 可以快速单行注释选中的代码.<br>快捷键 <code>ctrl</code>+<code>shift</code>+<code>/</code> 可以快速多行注释.</p>
<h1 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h1><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>指向内存中的一片区域, 可以被读写, 修改.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个变量 数据类型 变量名 = 数据字面量;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div>

<p>由于不同的数据类型所需的空间大小不一样的, 又由于 Java 是一种<strong>强类型语言</strong>,<br>强类型语言为了精确地分配变量在内存中的空间大小, 在使用变量前需要先定义它们的类型.<br>变量按数据类型可分为:</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>与变量类似, 都是指向内存中的一片空间, 能够被读取.<br>不同的是, 常量中的数据不可以被改变.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个常量 final 数据类型 变量名 = 10;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUMBER</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 为了区分, 常量一般全大写</span></span><br></pre></td></tr></table></figure></div>

<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul>
<li>标识符: 自己定义的用来命名 变量, 方法, 类 等的字符.</li>
</ul>
<blockquote>
<p>由字母, 数字, 下划线 <code>_</code> 或美元符号 <code>$</code> 组成.<br>不能以 数字 开头, 必须以字母, 下划线 或 美元符号开头.<br>标识符不能与关键字或保留字相同.</p>
</blockquote>
<ul>
<li>关键字: 被 Java 语言赋予特殊含义的单词, 不能作为标识符.</li>
<li>保留字: 现在还未被 Java 语言使用, 但以后版本的 Java 语言可能会使用.</li>
</ul>
<h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p>为了遵循这些规则, 会有一套建议的标识符规范, 如下:</p>
<ul>
<li>包名: 全部小写, 单词之间用点分隔.</li>
<li>类, 接口名: 首字母大写, 驼峰命名法.</li>
<li>方法, 变量名: 首字母小写, 驼峰命名法.</li>
<li>常量名: 全部大写, 下划线连接.</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li>整数类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>$-128$ 到 $127$</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>$-2^{15}$ 到 $2^{15}-1$</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>$-2^{31}$ 到 $2^{31}-1$</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>$-2^{63}$ 到 $2^{63}-1$</td>
</tr>
</tbody></table>
<p>整数类型默认为 int, 如果要声明一个 long 类型的整数,<br>需要在值的末尾加上 <code>L</code> 注明其是 long 类型.</p>
<ul>
<li>浮点类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>取值范围</th>
<th>精度</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4</td>
<td>$3.4 \times 10^{-38}$ 到 $3.4 \times 10^{38}$</td>
<td>7 位</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>$2.2 \times 10^{-308}$ 到 $2.2 \times 10^{308}$</td>
<td>15 位</td>
</tr>
</tbody></table>
<p>浮点类型默认是 double, 同理声明 float 类型时需加上 <code>F</code></p>
<ul>
<li>布尔类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>1</td>
<td>true 或 false</td>
</tr>
</tbody></table>
<ul>
<li>字符类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节数</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>2</td>
<td>$0$ 到 $65535$</td>
</tr>
</tbody></table>
<p>字符类型声明赋值时, 值需要 <code>&#39; &#39;</code> (单引号) 包裹.</p>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>不是以上基本数据类型的, 都称作引用数据类型.</p>
<ul>
<li>String 类</li>
</ul>
<p><code>String</code> 不是一个基本类型.是一个真正的类 但是 java 语言对这个类有些特殊处理</p>
<p><code>String</code> 可用 null 赋值.<br><code>String</code> 类是典型的不可变类.</p>
<blockquote>
<p>容量小的数据类型在计算时会自动转换为容量大的类型.<br>byte, short, char 之间不能转换, 他们三者在计算时会自动转换为 int.</p>
</blockquote>
<p>Java 在处理 <code>字符串</code> 和 <code>基本类型</code> 时, + 号有特殊处理(方法的重载), 例如拼接字符串等.</p>
<h1 id="从键盘录入"><a href="#从键盘录入" class="headerlink" title="从键盘录入"></a>从键盘录入</h1><p>从键盘录入分为三步:</p>
<h4 id="1-导入-Scanner-类"><a href="#1-导入-Scanner-类" class="headerlink" title="1. 导入 Scanner 类"></a>1. 导入 Scanner 类</h4><p>在 Java 标准库中, 已经实现了从键盘录入的方法.<br>在 IDEA 等高级开发工具中, 当需要这个包时, 开发工具会自动添加这一行:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-创建-Scanner-对象"><a href="#2-创建-Scanner-对象" class="headerlink" title="2.创建 Scanner 对象"></a>2.创建 Scanner 对象</h4><p>创建这个对象才能使用:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure></div>

<p>后面会详细介绍对象相关.<br>这里括号内的 <code>System.in</code> 是指使用<code>System.in</code>作为输入源.</p>
<p>创建好对象后, 就可在此类中多次使用这个对象.</p>
<h4 id="3-读取不同类型的数据"><a href="#3-读取不同类型的数据" class="headerlink" title="3.读取不同类型的数据"></a>3.读取不同类型的数据</h4><p>Scanner 类中有多种方法来读取不同类型的数据:</p>
<ul>
<li><code>nextInt()</code>: 读取下一个整数</li>
<li><code>nextDouble()</code>: 读取下一个双精度浮点数</li>
<li><code>nextLine()</code>: 读取输入行的剩余部分, 包括空格</li>
</ul>
<p>例如, 如果你想读取一个整数，可以这样做:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> scanner.nextInt();</span><br></pre></td></tr></table></figure></div>

<p>注意, 当需要录入 <code>char</code> 类型时, Scanner 中并没有 <code>.nextchar( )</code> 这个方法.<br>直接:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> scanner.next();</span><br></pre></td></tr></table></figure></div>

<p>不录入 <code>char</code> 而是转为 <code>String</code> 类型 , 效果上是一样的.</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>加减乘除</td>
<td><code>+</code> <code>-</code> <code>*</code> <code>/</code></td>
<td>基本的四则运算符</td>
</tr>
<tr>
<td>取模</td>
<td><code>%</code></td>
<td>两数相除的的余数, 舍去整数部分.</td>
</tr>
<tr>
<td>自增</td>
<td><code>++</code></td>
<td>变量加 1<br>自增在前时先加 1, 再赋值.<br>自增在后时先赋值, 再加 1.</td>
</tr>
<tr>
<td>自减</td>
<td><code>--</code></td>
<td>变量减 1, 与自增同理.</td>
</tr>
</tbody></table>
<blockquote>
<p>注意:<br>除法运算 <code>/</code> 在计算 <code>int</code> 类型时, 结果也会是 <code>int</code> , 会保留整数部分, 舍去余数,<br>其与取模是对立的.<br>如果想要精确的计算, 可以用 <code>double</code> 类型进行除法运算.</p>
</blockquote>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>赋值</td>
<td><code>=</code></td>
<td>简单的赋值运算符</td>
</tr>
<tr>
<td>四则赋值(包括取余)</td>
<td><code>*=</code>, <code>/=</code>, <code>%=</code>, <code>+=</code>, <code>-=</code></td>
<td>先计算右操作数, 再赋值</td>
</tr>
</tbody></table>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>等于</td>
<td><code>==</code></td>
<td>判断两边是否相等</td>
</tr>
<tr>
<td>不等于</td>
<td><code>!=</code></td>
<td>判断两边是否不等</td>
</tr>
<tr>
<td>大于<br>小于</td>
<td><code>&gt;</code> <code>&lt;</code></td>
<td>判断左边是否大于右边<br>判断左边是否小于右边</td>
</tr>
<tr>
<td>大于等于<br>小于等于</td>
<td><code>&gt;=</code> <code>&lt;=</code></td>
<td>判断左边是否大于等于右边<br>判断左边是否小于等于右边</td>
</tr>
</tbody></table>
<p>关系运算符<strong>不能直接</strong>比较 引用数据类型 (如字符串)<br>字符串比较, 需使用 <code>.equals()</code> . 面向对象部分会详细说明.</p>
<blockquote>
<p>关系运算符的结果是 <code>boolean</code> 类型.</p>
</blockquote>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑与</td>
<td>&amp;</td>
<td>两边都为 true, 结果为 true</td>
</tr>
<tr>
<td>逻辑或</td>
<td>|</td>
<td>两边有一个为 true, 结果为 true</td>
</tr>
<tr>
<td>逻辑非</td>
<td>!</td>
<td>取反, 若操作数为 true, 结果为 false, 若操作数为 false, 结果为 true</td>
</tr>
<tr>
<td>逻辑异或</td>
<td>^</td>
<td>两边结果相同 (都为 true 或都为 false), 结果为 true</td>
</tr>
</tbody></table>
<blockquote>
<p>逻辑运算符的结果也是 boolean 类型.</p>
</blockquote>
<p>逻辑运算符还有两个更为智能的符号, 会在满足必定条件后, 忽略不必要的操作.<br>在实际开发中优先使用.</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>短路与</td>
<td>&amp;&amp;</td>
<td>左边为 false ,右边则不执行判断.</td>
</tr>
<tr>
<td>短路或</td>
<td>||</td>
<td>左边为 true, 右边则不执行判断.</td>
</tr>
</tbody></table>
<h3 id="位运算符-了解"><a href="#位运算符-了解" class="headerlink" title="位运算符(了解)"></a>位运算符(了解)</h3><p>在编程中使用较少, 但在底层有用.</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>运算符</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>按位与</td>
<td><code>&amp;</code></td>
<td>两个操作数的对应位都为 1, 结果为 1</td>
<td></td>
</tr>
<tr>
<td>按位或</td>
<td>&#96;</td>
<td>&#96;</td>
<td>两个操作数的对应位有一个为 1, 结果为 1</td>
</tr>
<tr>
<td>按位异或</td>
<td><code>^</code></td>
<td>两个操作数的对应位不同时为 1, 结果为 1</td>
<td></td>
</tr>
<tr>
<td>按位取反</td>
<td><code>~</code></td>
<td>反转操作数的每一位, 即 0 变 1, 1 变 0</td>
<td></td>
</tr>
<tr>
<td>左移</td>
<td><code>&lt;&lt;</code></td>
<td>按位左移, 左操作数的各二进位全部左移若干位, 右操作数指定了移动的位数</td>
<td></td>
</tr>
<tr>
<td>右移</td>
<td><code>&gt;&gt;</code></td>
<td>按位右移, 左操作数的各二进位全部右移若干位, 右操作数指定了移动的位数</td>
<td></td>
</tr>
<tr>
<td>无符号右移</td>
<td><code>&gt;&gt;&gt;</code></td>
<td>逻辑右移, 左操作数的各二进位全部右移若干位, 右操作数指定了移动的位数, 移动后高位丢弃, 低位补 0</td>
<td></td>
</tr>
</tbody></table>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p><strong>只能</strong>由数值<strong>范围小</strong>的类型转换赋值给数值<strong>范围大</strong>的类型, 反之不行.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>Java 的算数运算中, 参与运算的数据都会被子的类型转换为运算中最大的数据类型.</p>
<p>例如:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + <span class="number">200</span>;</span><br></pre></td></tr></table></figure></div>

<p>由于 200 是 <code>int</code> 类型, 因此 x 会被自动转换为 <code>int</code> 类型进行计算.</p>

    </div>
  </div>

<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>使用<strong>圆括号</strong> <code>()</code> 规定类型, 能将一种数据类型强制转换为另一种数据类型.<br>在内存中, 强制转换会舍弃高位, 只保留低位.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">byte</span>) x;</span><br></pre></td></tr></table></figure></div>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>注意</p>

    </div>
    <div class="notel-content">
      <p>在赋值运算符中, 存在一种强制转换:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">a += <span class="number">5</span>; <span class="comment">// a = (byte)(a + 5)</span></span><br></pre></td></tr></table></figure></div>

<p>一定要注意此类情况, 比较难以察觉.</p>

    </div>
  </div>

<h1 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h1><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) &#123;</span><br><span class="line">    执行代码</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) &#123;</span><br><span class="line">    执行代码</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当需要在条件判断下执行的代码只有一行时, 可以省略大括号.<br>需要执行多行时, 不可省略大括号, 在其他控制语句中同样适用.</p>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>当 if-else 的执行代码是<strong>赋值表达式</strong>(直接将结果赋值给变量的语句)时, 可以使用三目运算符代替.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (判断条件) ? 表达式<span class="number">1</span> : 表达式<span class="number">2</span>;</span><br></pre></td></tr></table></figure></div>

<p>当条件表达式为 <code>True</code> 执行 表达式 1, 否则执行 表达式 2.</p>
<h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h4><p>当 if-else 的判断分支较多, 而且判断条件都是比较值是否相等, 就可以用 switch 代替.<br>switch 只会将表达式的值比较一次, 相比于 if-else 效率更高.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        执行代码<span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        执行代码<span class="number">2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        执行代码<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>switch-case 存在一种简化写法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (level)&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span> -&gt; 执行代码<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span> -&gt; 执行代码<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span> -&gt; 执行代码<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">default</span> -&gt; 执行代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当两种条件所需执行的代码逻辑相同时, 可以合并 case;</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">        执行代码<span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">3</span>:</span><br><span class="line">        执行代码<span class="number">2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        执行代码<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>简化写法( JDK11 后):</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">0</span> -&gt; 执行代码<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span>, 值<span class="number">2</span> -&gt; 执行代码<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">default</span> -&gt; 执行代码<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>JDK 17 后, switch 可以直接返回结果</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">goal</span> <span class="operator">=</span> <span class="keyword">switch</span> (bodyType) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;值0&quot;</span> -&gt; <span class="string">&quot;结果1&quot;</span>;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;值1&quot;</span>, <span class="string">&quot;值2&quot;</span> -&gt; <span class="string">&quot;结果2&quot;</span>;</span><br><span class="line">	<span class="keyword">default</span> -&gt; <span class="string">&quot;结果3&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 迭代) &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure></div>

<p>Java 中提供了 break 和 continue 关键字来控制循环的执行.</p>
<ul>
<li>break: 跳出循环</li>
<li>continue: 跳过本次循环</li>
</ul>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>是程序中最基本的功能单位, 是用来实现功能的代码块, 一个程序往往有很多方法组成.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明方法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">cleanMemory</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> voud <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="comment">// 调用有返回值的方法</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用无返回值方法</span></span><br><span class="line">	clearMemory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>选中一个方法, IDEA 会自动抽取方法, 选中后快捷键为 <code>Ctrl</code> + <code>Alt</code> + <code>M</code></p>
<p>全部大写: <code>Ctrl</code> + <code>Shift</code> + <code>U</code></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是一种存储多个相同类型元素的集合, 数组的声明格式如下:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> 数据类型[数组长度];</span><br></pre></td></tr></table></figure></div>

<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>for 循环与 while 循环 功能类似, 但语法更加简洁, 紧凑, 更适合用来遍历数据:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="number">0.</span>初始化变量; <span class="number">1.</span>循环判断条件; <span class="number">2.</span>更新变量)&#123;</span><br><span class="line">	<span class="number">3.</span>执行方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i arr.length; i++)&#123;</span><br><span class="line">	System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组: 如果一个数组的元素类型是一维数组, 那么这个数组就是二维数组.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = &#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>访问时也与一维类似:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">// 索引为0的数组内, 索引为0的数 -&gt; 1</span></span><br><span class="line">arr[<span class="number">1</span>][<span class="number">1</span>]; <span class="comment">// 索引为1的数组内, 索引为1的数 -&gt; 4</span></span><br></pre></td></tr></table></figure></div>

<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>当一个方法的参数类型确定, 但是参数个数不确定时, 可以使用可变参数:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">返回值 方法名(数据类型 ... 参数名)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例如实现一个任意数求和的方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> ... nums)</span>&#123;</span><br><span class="line">具体方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> add();</span><br><span class="line"><span class="comment">// 可以传入任意数量的参数</span></span><br><span class="line">sum = add(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">sum = add(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure></div>

<p>可变参数本质时一个数组, 可以用数组的方式来获取可变参数中的每一个值.</p>

  <div class="note p-4 mb-4 rounded-small red icon-padding">
    <i class="note-icon fa-solid fa-bolt"></i><p>可变参数永远只能放在最后. </p>

  </div>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>入门基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux入门</title>
    <url>/2024/03/04/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>笔记视频来源: <a class="link"   href="https://www.bilibili.com/video/BV1n84y1i7td/?p=2&spm_id_from=pageDriver&vd_source=b19220b8f372f3a81aa8463fde694a63" >黑马程序员Linux零基础快速入门到精通<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h1><h3 id="Linux-操作系统"><a href="#Linux-操作系统" class="headerlink" title="Linux 操作系统"></a>Linux 操作系统</h3><p>操作系统是软件的一类.</p>
<p><strong>操作系统是用户和计算机硬件之间的桥梁.</strong></p>
<p>Linux 由 <strong>林纳斯 托瓦兹</strong> 在大学期间创作, 后来经过全世界网友支持, 能够兼容多种硬件, 成为最为流行的服务器操作系统之一.</p>
<p>Linux系统由 <code>Linux系统内核</code> <code>系统级应用程序</code> 两部分组成. 由于Linux内核是免费开源的, 因此任何人都可以获得并修改内核, 封装发行Linux. </p>
<p>提供了 <strong>内核+系统级程序</strong> 的完整封装的, 称之为 Linux发行版.</p>
<p>常用的 Linux发行版 有 <code>ubuntu</code> <code>CentOS</code> <code>debain</code> <code>redhat</code> 等 <a class="link"   href="https://www.cnblogs.com/linuxAndMcu/p/11112518.html#:~:text=%E4%B8%89%E3%80%81Linux%20%E7%9A%84%E5%8F%91%E8%A1%8C%E7%89%88%E4%BB%8B%E7%BB%8D%201%20Debian%3A%EF%BC%88%E4%BB%A5%E7%A4%BE%E5%8C%BA%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E4%BD%9C%EF%BC%89%20Ubuntu%3A%20%E5%9F%BA%E4%BA%8E%E7%9F%A5%E5%90%8D%E7%9A%84Debian%20Linux%E5%8F%91%E5%B1%95%E8%80%8C%E6%9D%A5%EF%BC%8C%E7%95%8C%E9%9D%A2%E5%8F%8B%E5%A5%BD%EF%BC%8C%E5%AE%B9%E6%98%93%E4%B8%8A%E6%89%8B%EF%BC%8C%E5%AF%B9%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%94%AF%E6%8C%81%E9%9D%9E%E5%B8%B8%E5%85%A8%E9%9D%A2%EF%BC%8C%E6%98%AF%E7%9B%AE%E5%89%8D%E6%9C%80%E9%80%82%E5%90%88%E5%81%9A%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E7%9A%84Linux%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%EF%BC%8C%20%E8%80%8C%E4%B8%94Ubuntu%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%E9%83%BD%E5%85%8D%E8%B4%B9%E6%8F%90%E4%BE%9B%E3%80%82,suse%3A%20%E5%9F%BA%E4%BA%8ESlackware%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E6%AC%BELinux%2C%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E5%95%86%E4%B8%9A%E6%A1%8C%E9%9D%A2%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82%20...%204%20%E5%85%B6%E4%BB%96%E5%8F%91%E8%A1%8C%E7%89%88%E6%9C%AC%20Gentoo%3A%20%E5%9F%BA%E4%BA%8Elinux%E7%9A%84%E8%87%AA%E7%94%B1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E5%AE%83%E8%83%BD%E4%B8%BA%E5%87%A0%E4%B9%8E%E4%BB%BB%E4%BD%95%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%88%96%E9%9C%80%E6%B1%82%E8%87%AA%E5%8A%A8%E5%9C%B0%E4%BD%9C%E5%87%BA%E4%BC%98%E5%8C%96%E5%92%8C%E5%AE%9A%E5%88%B6%E3%80%82%20" >了解更多发行版<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<p>本教程以 CentOS 讲解为主, ubuntu为辅, 使用虚拟机运行Linux系统.</p>
<p><a class="link"   href="https://zhuanlan.zhihu.com/p/126601630#:~:text=%E5%9C%A8VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85centOS,7%E7%B3%BB%E7%BB%9F%E5%90%8E%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%90%AF%E5%8A%A8centOS%207%E7%B3%BB%E7%BB%9F%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%BF%9B%E5%85%A5%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A1%8C%E9%9D%A2%E6%A8%A1%E5%BC%8F%EF%BC%8C%E9%82%A3%E4%B9%88%E5%BA%94%E8%AF%A5%E6%98%AF%E6%B2%A1%E6%9C%89%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85GUI%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%8C%85%E6%89%80%E8%87%B4%EF%BC%8C%E5%90%AF%E5%8A%A8%E7%B3%BB%E7%BB%9F%E4%BC%9A%E9%BB%98%E8%AE%A4%E8%BF%9B%E5%85%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%95%8C%E9%9D%A2%E3%80%82" >CentOS 7系统启动后怎么从命令行模式切换到图形界面模式<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="Linux-命令行"><a href="#Linux-命令行" class="headerlink" title="Linux 命令行"></a>Linux 命令行</h1><p>Linux在图形化界面并未重点发力, 因此在开发过程中, 一般选用效率更高, 资源占用低并且稳定的 命令行.</p>
<p><a class="link"   href="https://www.hostbuf.com/t/988.html" >FinalShell SSH工具<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>入门基础</tag>
        <tag>操作系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进阶-常用API</title>
    <url>/2025/02/09/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8API/</url>
    <content><![CDATA[<p>API(Application Programing Interface), 也就是应用程序接口, 通常是指应用程序之间交换的协议和标准.<br>有了这一套标准, 每个团队遵循这套标准各自开发对应的内容, 最后完成的项目就能正确的交互和协作.</p>
<p>在 Java 运行环境 中 包含核心类库, 这套核心类库, 就是 Java 为开发者提供的一套核心 API 了.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8api/file-20250219120725524.jpg"
                     
                ></p>
<p><a class="link"   href="https://doc.qzxdp.cn/jdk/17/zh/api/index.html" >Java® 平台、标准版和 Java 开发工具包 版本 17 API 规范<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>Java 中所有类, 都直接或间接地继承了 Object 类, 因此都可以使用 Object 中定义方法.</p>
<h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>比较两个对象是否相等, 比较对象建议用 <code>equals()</code>,<br>而不是 <code>==</code> , 双等号会比较<strong>变量里面的值</strong>, 比较对象时, 其中存储的是地址, 不能达到预期效果.</p>
<p>不过, 在 equals 方法中的默认实现如下, 仍然是用的 <code>==</code> 比较.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span>(<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在 IDEA 中, 按住 <code>Ctrl</code> 点击方法名可跳转至实现类.</p>
</blockquote>
<p>这是因为 <code>Object</code> 作为所有类的超级父类, 其作用只是提供一个基本的比较逻辑.<br>当没有重写覆盖 <code>equals()</code> 方法时, 才会调用这个默认实现.</p>
<p>而 String 类能够正常比较就是重写了 <code>equals()</code> 方法.</p>
<p>如果我们需要比较自定义的类,<br>例如一个包含 <code>name</code> 和 <code>age</code> 属性的 <code>Person</code> 类, 覆写 <code>equals()</code> 方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!(obj <span class="keyword">instanceof</span> Person))&#123; <span class="comment">// 向下强转需要判断类型, 保证健壮性</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line">	retrun <span class="built_in">this</span>.name.equals(p.name) &amp;&amp; <span class="built_in">this</span>.age == p.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>equals()</code> 方法通常配合 <code>hashCode()</code> 共同使用.</p>
<h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>根据对象信息, 计算出一个哈希值(整数), 将来会在哈希表中用到.</p>
<blockquote>
<p>哈希表可以当作一种数据结构.<br>哈希值会影响对象在哈希表中存储的位置.</p>
</blockquote>
<p><code>hashCode()</code> 方法必须满足以下条件:</p>
<ul>
<li>同一个对象, 多次调用该方法, <code>hashCode()</code> 必须始终返回相同整数.</li>
<li>如果两个对象用 <code>equals()</code> 比较:<ul>
<li>若相同, 则两个对象的 <code>hashCode()</code> 必须返回相同结果.</li>
<li>若不同, 则两个对象的 <code>hashCode()</code> 尽量返回不同结果 (不是必须).</li>
</ul>
</li>
</ul>
<p><code>hashcode()</code> 的默认算法是用一种随机数生成法生成 (Marsaglia 的 xor-shift), 使用 C 语言实现.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<p>同一个对象只会在第一次时生成一个随机数, 这个随机数会被缓存, 以保证每次调用始终返回相同值.</p>
<p>若要满足全部的条件,<br><code>hashCode()</code> 需要根据属性计算得到 , 这需要手动重写<code>hashCode()</code> 方法.<br>而刚刚提到的 <code>equals()</code> 方法同样也与属性关联.<br>我们在重写 <code>equals()</code> 方法的同时, 也应该重写 <code>hashCode()</code>.</p>
<p>IDEA 提供了自动生成 这两个方法的功能.</p>
<p>与生成 Getter 和 Setter 类似, 在代码编辑窗口右键:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8api/file-20250219134149639.jpg"
                     
                ></p>
<p>以此自动生成了两个方法.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person person)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>返回对象的字符串表示形式, 以便人们阅读并了解对象中的数据或信息.<br>当我们直接打印一个对象, 或者将对象与字符串拼接时, 默认就会调用对象的 toString 方法.</p>
<p>Objiect 中的默认实现如下:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCOde());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>getClass().getName()</code> 会展示当前类的完整名称 (包名 + 类名)<br><code>Integer.toHexString(hashCode())</code> 会先通过 hashCode 方法计算哈希值, 然后再转换为十六进制展示.</p>
<p>如果要展示自定义的对象, 肯定是想展示其属性, 这时就需要重写此方法.<br>当然, IDEA 已经内置了自动生成 tostring() 方法, 操作方式与之前类似.</p>
<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><p>是一个特殊的引用类型数据, 可以直接用字符串字面量创建对象.<br>(别的引用类型需要<code>new</code>关键字创建.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Wreckloud&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>不过 <code>String 类</code> 当然也能通过 <code>new</code> 关键字创建, 以下是常见的构造方法:</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>String(String original)</td>
<td>基于传入的字符串创建一个字符串对象副本</td>
</tr>
<tr>
<td>String(byte[] bytes)</td>
<td>用默认编码表将字节数组转换为字符串对象</td>
</tr>
<tr>
<td>String(byte[] bytes, Charset charset)</td>
<td>用指定的编码表将字节数组转为字符串对象</td>
</tr>
<tr>
<td>String(char[] value)</td>
<td>用字符数组创建出一个字符串对象</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接用字符串字面量创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用字符串字面量创建一个副本</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strCopy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用字节数组创建一个字符串</span></span><br><span class="line"><span class="type">byte</span>[] bytes = &#123;<span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">44</span>, <span class="number">32</span>, <span class="number">87</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">33</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用默认编码表将字节数组转换为字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strFromBytes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用指定的编码表将字节数组转为字符串对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strFromBytesWithCharset</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用字符数组创建出一个字符串对象</span></span><br><span class="line"><span class="type">char</span>[] chars = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;,&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;!&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">strFromChars</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br></pre></td></tr></table></figure></div>

<p>更推荐使用 直接用字符串字面量创建对象.</p>
<p>无论在哪, 只要<strong>用字面量</strong>创建字符串对象, 都会在堆内存中的字符换常量池中检查是否存在.<br><code>new()</code> 的方式都会额外在堆内存中开辟空间.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8api/file-20250220160603683.jpg"
                     
                ></p>
<h2 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h2><p>当调用时, 检查字符串常量池是否包含当前字符串相等的字符串(通过 <code>.equals()</code> 判断).<br>如果存在, 会直接返回池中字符串对象;<br>否则, 将此字符串添加到池中, 并返回此对象.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个字符串，会自动进入字符串池</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 new 创建字符串，不会自动进入字符串池</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较使用字面量创建的字符串</span></span><br><span class="line">    System.out.println(str1 == str2); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较使用 new 创建的字符串</span></span><br><span class="line">    System.out.println(str3 == str4); <span class="comment">// 输出: false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 intern 方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> str3.intern();</span><br><span class="line">    System.out.println(str5 == str1); <span class="comment">// 输出: true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比调用 intern 前后的结果</span></span><br><span class="line">    System.out.println(str3 == str5); <span class="comment">// 输出: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="判断与比较"><a href="#判断与比较" class="headerlink" title="判断与比较"></a>判断与比较</h2><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>大小写敏感</th>
</tr>
</thead>
<tbody><tr>
<td><code>equals(Object obj)</code></td>
<td>严格比较字符串内容是否<strong>完全相同</strong></td>
<td>✔️ 是</td>
</tr>
<tr>
<td><code>equalsIgnoreCase(String str)</code></td>
<td>比较字符串内容是否相同（忽略大小写）</td>
<td>❌ 否</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">System.out.println(str1.equals(<span class="string">&quot;hello&quot;</span>));        <span class="comment">// false</span></span><br><span class="line">System.out.println(str1.equalsIgnoreCase(<span class="string">&quot;HELLO&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>空白字符处理</th>
</tr>
</thead>
<tbody><tr>
<td><code>isEmpty()</code></td>
<td>检查字符串<strong>长度是否为 0</strong>（即 <code>&quot;&quot;</code>）</td>
<td>不识别空格</td>
</tr>
<tr>
<td><code>isBlank()</code></td>
<td>检查字符串是否为空<strong>或全为空白字符</strong></td>
<td>识别空格&#x2F;制表符&#x2F;换行符</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;&quot;</span>.isEmpty());        <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot;   &quot;</span>.isEmpty());     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;   &quot;</span>.isBlank());     <span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="string">&quot; \t\n&quot;</span>.isBlank());   <span class="comment">// true（含制表符、换行符）</span></span><br></pre></td></tr></table></figure></div>

<h3 id="前后缀检查"><a href="#前后缀检查" class="headerlink" title="前后缀检查"></a>前后缀检查</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>startsWith(String prefix)</code></td>
<td>判断字符串<strong>是否以指定前缀开头</strong></td>
</tr>
<tr>
<td><code>endsWith(String suffix)</code></td>
<td>判断字符串<strong>是否以指定后缀结尾</strong></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;/data/images/photo.jpg&quot;</span>;</span><br><span class="line">System.out.println(path.startsWith(<span class="string">&quot;/data&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(path.endsWith(<span class="string">&quot;.png&quot;</span>));    <span class="comment">// false</span></span><br></pre></td></tr></table></figure></div>

<h3 id="内容匹配"><a href="#内容匹配" class="headerlink" title="内容匹配"></a>内容匹配</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>匹配方式</th>
</tr>
</thead>
<tbody><tr>
<td><code>contains(CharSequence cs)</code></td>
<td>判断是否包含<strong>指定子字符串</strong></td>
<td>精确字符匹配</td>
</tr>
<tr>
<td><code>matches(String regex)</code></td>
<td>判断是否符合<strong>正则表达式规则</strong></td>
<td>正则模式匹配<br>[[正则表达式|正则表达式]]</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查是否包含子字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Java编程基础&quot;</span>;</span><br><span class="line">System.out.println(text.contains(<span class="string">&quot;编程&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则表达式验证手机号</span></span><br><span class="line">System.out.println(<span class="string">&quot;13800138000&quot;</span>.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h4 id="综合应用案例"><a href="#综合应用案例" class="headerlink" title="综合应用案例"></a>综合应用案例</h4><p><strong>场景</strong>：验证文件名合法性<br>要求：</p>
<ol>
<li>必须以 <code>report_</code> 开头</li>
<li>必须包含日期格式 <code>2023-12-31</code></li>
<li>必须以 <code>.pdf</code> 结尾</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;report_销售数据_2023-10-05.pdf&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> filename.startsWith(<span class="string">&quot;report_&quot;</span>)</span><br><span class="line">               &amp;&amp; filename.contains(<span class="string">&quot;2023-&quot;</span>)</span><br><span class="line">               &amp;&amp; filename.endsWith(<span class="string">&quot;.pdf&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(isValid); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong>：</p>
<ol>
<li><code>equals()</code> 比较的是<strong>字符串内容</strong>，不是内存地址（与 <code>==</code> 不同）</li>
<li><code>isBlank()</code> 需 Java 11+ 支持，低版本可用 <code>trim().isEmpty()</code> 替代</li>
<li><code>matches()</code> 要求<strong>完全匹配</strong>整个字符串（相当于正则表达式自动添加 <code>^...$</code>）</li>
</ol>
<p>String 类中提供的判断或比较字符串的方法, 返回值都是 boolean 类型.</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>equals(Object obj)</code><br><code>equalsIgnoreCase(String anotherString)</code></td>
<td>将当前字符串与指定对象比较<br>忽略大小写比较</td>
</tr>
<tr>
<td><code>isEmpty()</code><br><code>isBlank()</code></td>
<td>判断字符串是否为空字符串<br>判断字符串是否为空或全是空白</td>
</tr>
<tr>
<td><code>endsWith(String suffix)</code><br><code>startsWith(String prefix)</code></td>
<td>判断字符串是否以指定后缀结尾<br>判断字符串是否以指定前缀开始</td>
</tr>
<tr>
<td><code>matches(String regex)</code></td>
<td>判断字符串是否与指定的正字表达式匹配</td>
</tr>
<tr>
<td><code>contains(CharSequence cs)</code></td>
<td>判断当前字符串是否包含指定的子字符串</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. equals(): 比较两个字符串是否相等（区分大小写）</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    System.out.println(user.equals(<span class="string">&quot;alice&quot;</span>)); <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// 2. equalsIgnoreCase(): 比较两个字符串是否相等（忽略大小写）</span></span><br><span class="line">    System.out.println(user.equalsIgnoreCase(<span class="string">&quot;alice&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. isEmpty(): 判断字符串是否为空字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">empty</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    System.out.println(empty.isEmpty()); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 4. isBlank(): 判断字符串是否为空或仅包含空白字符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">blank</span> <span class="operator">=</span> <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    System.out.println(blank.isBlank()); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. startsWith(): 判断字符串是否以指定前缀开头</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;data/users.txt&quot;</span>;</span><br><span class="line">    System.out.println(path.startsWith(<span class="string">&quot;data&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// 6. endsWith(): 判断字符串是否以指定后缀结尾</span></span><br><span class="line">    System.out.println(path.endsWith(<span class="string">&quot;.txt&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. matches(): 判断字符串是否匹配指定的正则表达式</span></span><br><span class="line">    System.out.println(<span class="string">&quot;13800138000&quot;</span>.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. contains(): 判断字符串是否包含指定的子字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">article</span> <span class="operator">=</span> <span class="string">&quot;Java 是一种编程语言。&quot;</span>;</span><br><span class="line">    System.out.println(article.contains(<span class="string">&quot;Java&quot;</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><h3 id="基础属性获取"><a href="#基础属性获取" class="headerlink" title="基础属性获取"></a>基础属性获取</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>参数说明</th>
<th>返回值说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>length()</code></td>
<td>获取字符串<strong>字符数量</strong></td>
<td>无</td>
<td>字符串长度（int）</td>
</tr>
<tr>
<td><code>charAt(int index)</code></td>
<td>获取指定索引位置的字符</td>
<td>索引范围：<code>0</code> 到 <code>length()-1</code></td>
<td>对应位置的字符（char）</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串长度</span></span><br><span class="line">System.out.println(str.length());   <span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 获取索引为3的字符（索引从0开始）</span></span><br><span class="line">System.out.println(str.charAt(<span class="number">3</span>));  <span class="comment">// &#x27;l&#x27;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="切割与截取"><a href="#切割与截取" class="headerlink" title="切割与截取"></a>切割与截取</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>split(String regex)</code></td>
<td>按正则表达式规则拆分字符串</td>
<td>支持复杂分隔符（如逗号、空格等）</td>
</tr>
<tr>
<td><code>substring(int beginIndex, int endIndex)</code></td>
<td>截取指定索引范围的子字符串</td>
<td>含头不含尾（包含 begin，不包含 end）</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按空格拆分字符串</span></span><br><span class="line">String[] words = <span class="string">&quot;Java Python C++&quot;</span>.split(<span class="string">&quot;\\s+&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(words)); <span class="comment">// [Java, Python, C++]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 截取索引2到5的字符（含2不含5）</span></span><br><span class="line">System.out.println(<span class="string">&quot;ABCDEFG&quot;</span>.substring(<span class="number">2</span>,<span class="number">5</span>)); <span class="comment">// &quot;CDE&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="类型转换与查找定位"><a href="#类型转换与查找定位" class="headerlink" title="类型转换与查找定位"></a>类型转换与查找定位</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>返回值说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>toCharArray()</code></td>
<td>将字符串转为字符数组</td>
<td>包含所有字符的 char[]</td>
</tr>
<tr>
<td><code>indexOf(String str)</code></td>
<td>查找子字符串首次出现的位置</td>
<td>未找到返回 <code>-1</code></td>
</tr>
<tr>
<td><code>lastIndexOf(String str)</code></td>
<td>查找子字符串最后次出现的位置</td>
<td>未找到返回 <code>-1</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换为字符数组</span></span><br><span class="line"><span class="type">char</span>[] letters = <span class="string">&quot;Hello&quot;</span>.toCharArray();</span><br><span class="line">System.out.println(Arrays.toString(letters)); <span class="comment">// [H, e, l, l, o]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找子字符串位置</span></span><br><span class="line">System.out.println(<span class="string">&quot;apple&quot;</span>.indexOf(<span class="string">&quot;pl&quot;</span>));    <span class="comment">// 2</span></span><br><span class="line">System.out.println(<span class="string">&quot;apple&quot;</span>.indexOf(<span class="string">&quot;banana&quot;</span>));<span class="comment">// -1</span></span><br></pre></td></tr></table></figure></div>

<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><table>
<thead>
<tr>
<th>方法变体</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>substring(int beginIndex)</code></td>
<td>从指定位置截取到字符串末尾</td>
</tr>
<tr>
<td><code>indexOf(int ch)</code></td>
<td>查找字符首次出现的位置</td>
</tr>
<tr>
<td><code>indexOf(String str, int fromIndex)</code></td>
<td>从指定位置开始查找子字符串</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从索引3截取到末尾</span></span><br><span class="line">System.out.println(<span class="string">&quot;0123456789&quot;</span>.substring(<span class="number">3</span>)); <span class="comment">// &quot;3456789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找字符 &#x27;a&#x27; 的位置</span></span><br><span class="line">System.out.println(<span class="string">&quot;banana&quot;</span>.indexOf(<span class="string">&#x27;a&#x27;</span>));     <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引2开始查找 &quot;na&quot;</span></span><br><span class="line">System.out.println(<span class="string">&quot;banana&quot;</span>.indexOf(<span class="string">&quot;na&quot;</span>,<span class="number">2</span>));  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></div>

<h4 id="综合应用案例-1"><a href="#综合应用案例-1" class="headerlink" title="综合应用案例"></a>综合应用案例</h4><p><strong>场景</strong>：解析日志条目<br>日志格式：<code>[2023-10-05] [ERROR] Connection timeout</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">log</span> <span class="operator">=</span> <span class="string">&quot;[2023-10-05] [ERROR] Connection timeout&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 提取日期部分</span></span><br><span class="line"><span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> log.substring(<span class="number">1</span>, <span class="number">11</span>);  <span class="comment">// &quot;2023-10-05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 拆分日志级别和内容</span></span><br><span class="line">String[] parts = log.split(<span class="string">&quot;\\] \\[&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">level</span> <span class="operator">=</span> parts[<span class="number">1</span>].substring(<span class="number">0</span>, parts[<span class="number">1</span>].indexOf(<span class="string">&#x27;]&#x27;</span>)); <span class="comment">// &quot;ERROR&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取错误描述</span></span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> log.substring(log.lastIndexOf(<span class="string">&#x27;]&#x27;</span>)+<span class="number">2</span>); <span class="comment">// &quot;Connection timeout&quot;</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;日期：&quot;</span> + date);       <span class="comment">// 2023-10-05</span></span><br><span class="line">System.out.println(<span class="string">&quot;级别：&quot;</span> + level);      <span class="comment">// ERROR</span></span><br><span class="line">System.out.println(<span class="string">&quot;描述：&quot;</span> + message);    <span class="comment">// Connection timeout</span></span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong>：</p>
<ol>
<li><code>substring</code> 的结束索引不包含在结果中（类似 Python 切片）</li>
<li><code>split</code> 使用正则表达式时，特殊字符需转义（如 <code>.</code> 要写成 <code>\\.</code>）</li>
<li><code>charAt</code> 索引越界会抛出 <code>StringIndexOutOfBoundsException</code></li>
</ol>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="基础替换操作"><a href="#基础替换操作" class="headerlink" title="基础替换操作"></a>基础替换操作</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用说明</th>
<th>匹配方式</th>
</tr>
</thead>
<tbody><tr>
<td><code>replace(CharSequence target, CharSequence replacement)</code></td>
<td><strong>精确替换</strong>指定字符&#x2F;字符串</td>
<td>普通文本匹配</td>
</tr>
<tr>
<td><code>replaceAll(String regex, String replacement)</code></td>
<td><strong>正则替换</strong>匹配内容</td>
<td>正则表达式匹配</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 精确替换字符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">System.out.println(text.replace(<span class="string">&quot;l&quot;</span>, <span class="string">&quot;*&quot;</span>));  <span class="comment">// He**o Wor*d!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则替换数字为星号</span></span><br><span class="line"><span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="string">&quot;Room 205, ID: A123&quot;</span>;</span><br><span class="line">System.out.println(code.replaceAll(<span class="string">&quot;\\d&quot;</span>, <span class="string">&quot;*&quot;</span>));  <span class="comment">// Room ***, ID: A***</span></span><br></pre></td></tr></table></figure></div>

<h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用说明</th>
<th>语言敏感处理</th>
</tr>
</thead>
<tbody><tr>
<td><code>toLowerCase()</code></td>
<td>转换为全小写</td>
<td>✔️ 支持多语言</td>
</tr>
<tr>
<td><code>toUpperCase()</code></td>
<td>转换为全大写</td>
<td>✔️ 支持多语言</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大小写互转</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Java编程&quot;</span>;</span><br><span class="line">System.out.println(str.toUpperCase());  <span class="comment">// JAVA编程</span></span><br><span class="line">System.out.println(<span class="string">&quot;ÄÖÜ&quot;</span>.toLowerCase());  <span class="comment">// äöü（德语字符正确处理）</span></span><br></pre></td></tr></table></figure></div>

<h3 id="空格处理"><a href="#空格处理" class="headerlink" title="空格处理"></a>空格处理</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用说明</th>
<th>空白字符识别范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>strip()</code></td>
<td>删除<strong>前后</strong>所有空白字符（包括全角空格）</td>
<td>空格&#x2F;制表符&#x2F;换行符&#x2F;全角空格</td>
</tr>
<tr>
<td><code>trim()</code></td>
<td>删除前后半角空白字符（兼容旧版本）</td>
<td>仅半角空格&#x2F;制表符&#x2F;换行符</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理含全角空格的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;　 Hello　&quot;</span>;</span><br><span class="line">System.out.println(s.strip());       <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">System.out.println(s.trim());        <span class="comment">// &quot;　Hello&quot;（仍保留全角空格）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理常规空白</span></span><br><span class="line">System.out.println(<span class="string">&quot;  data\n  &quot;</span>.strip());  <span class="comment">// &quot;data&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="扩展方法与案例"><a href="#扩展方法与案例" class="headerlink" title="扩展方法与案例"></a>扩展方法与案例</h3><table>
<thead>
<tr>
<th>方法变体</th>
<th>作用说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>replaceFirst(String regex, String replacement)</code></td>
<td>仅替换<strong>第一个</strong>匹配项</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换首个数字</span></span><br><span class="line">System.out.println(<span class="string">&quot;A1B2C3&quot;</span>.replaceFirst(<span class="string">&quot;\\d&quot;</span>, <span class="string">&quot;*&quot;</span>));  <span class="comment">// A*B2C3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除字符串首尾星号</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;**重要通知**&quot;</span>;</span><br><span class="line">System.out.println(s.replaceAll(<span class="string">&quot;^\\*+|\\*+$&quot;</span>, <span class="string">&quot;&quot;</span>));  <span class="comment">// 重要通知</span></span><br></pre></td></tr></table></figure></div>

<h3 id="综合应用案例-2"><a href="#综合应用案例-2" class="headerlink" title="综合应用案例"></a>综合应用案例</h3><p><strong>场景</strong>：格式化用户输入的手机号<br>要求：</p>
<ol>
<li>去除所有空格</li>
<li>将区号中的 <code>0086</code> 统一转为 <code>+86</code></li>
<li>隐藏中间 4 位号码</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> <span class="string">&quot; 0086 138 0013 8000 &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> input</span><br><span class="line">    .strip()                          <span class="comment">// 去空格 → &quot;0086 138 0013 8000&quot;</span></span><br><span class="line">    .replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>)                  <span class="comment">// 删空格 → &quot;008613800138000&quot;</span></span><br><span class="line">    .replaceFirst(<span class="string">&quot;0086&quot;</span>, <span class="string">&quot;+86&quot;</span>)       <span class="comment">// 改区号 → &quot;+8613800138000&quot;</span></span><br><span class="line">    .replaceAll(<span class="string">&quot;(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)&quot;</span>, <span class="string">&quot;$1****$2&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(formatted);  <span class="comment">// +86138****8000</span></span><br></pre></td></tr></table></figure></div>

<p><strong>注意事项</strong>：</p>
<ol>
<li><code>replaceAll</code> 使用正则时，需对特殊符号转义（如 <code>.</code> 要写成 <code>\\.</code>）</li>
<li><code>strip()</code> 需要 Java 11+，低版本可用 <code>trim()</code> + 正则处理全角空格</li>
<li>所有转换方法均<strong>返回新字符串</strong>，原始字符串不可变（符合字符串不可变性原则）</li>
</ol>
<h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><h3 id="静态拼接方案"><a href="#静态拼接方案" class="headerlink" title="静态拼接方案"></a>静态拼接方案</h3><p><strong>核心方法</strong>：<code>String.join()</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用分隔符拼接多个元素</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> String.join(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;2023&quot;</span>, <span class="string">&quot;10&quot;</span>, <span class="string">&quot;05&quot;</span>);</span><br><span class="line">System.out.println(result); <span class="comment">// &quot;2023-10-05&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接集合元素</span></span><br><span class="line">List&lt;String&gt; colors = Arrays.asList(<span class="string">&quot;Red&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">System.out.println(String.join(<span class="string">&quot; | &quot;</span>, colors)); <span class="comment">// &quot;Red | Green | Blue&quot;</span></span><br></pre></td></tr></table></figure></div>

<p><strong>特点</strong>：</p>
<ul>
<li>适合已知元素数量的场景</li>
<li>自动处理分隔符插入</li>
<li>可接收数组&#x2F;集合作为参数</li>
</ul>
<h3 id="动态拼接工具：StringBuilder"><a href="#动态拼接工具：StringBuilder" class="headerlink" title="动态拼接工具：StringBuilder"></a>动态拼接工具：StringBuilder</h3><p><strong>核心方法</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>链式调用示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>append()</code></td>
<td>追加任意类型数据</td>
<td><code>sb.append(&quot;A&quot;).append(123)</code></td>
</tr>
<tr>
<td><code>insert(int, obj)</code></td>
<td>在指定位置插入内容</td>
<td><code>sb.insert(2, &quot;X&quot;)</code></td>
</tr>
<tr>
<td><code>reverse()</code></td>
<td>反转字符串内容</td>
<td><code>sb.reverse()</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建与基础使用</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;订单号：&quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;TX&quot;</span>)</span><br><span class="line">  .append(System.currentTimeMillis())</span><br><span class="line">  .append(<span class="string">&quot;\n商品：&quot;</span>)</span><br><span class="line">  .append(<span class="string">&quot;手机&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(sb.toString());</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 订单号：TX1633425600000</span></span><br><span class="line"><span class="comment">// 商品：手机</span></span><br></pre></td></tr></table></figure></div>

<p><strong>性能优势场景</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 低效做法（产生多个中间字符串）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">    str += i; <span class="comment">// 每次循环创建新对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效做法（单对象操作）</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="综合应用案例-3"><a href="#综合应用案例-3" class="headerlink" title="综合应用案例"></a>综合应用案例</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 SQL 语句</span></span><br><span class="line">List&lt;String&gt; conditions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">conditions.add(<span class="string">&quot;age &gt; 18&quot;</span>);</span><br><span class="line">conditions.add(<span class="string">&quot;status = 1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">query</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;SELECT * FROM users&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!conditions.isEmpty()) &#123;</span><br><span class="line">    query.append(<span class="string">&quot; WHERE &quot;</span>)</span><br><span class="line">         .append(String.join(<span class="string">&quot; AND &quot;</span>, conditions));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(query);</span><br><span class="line"><span class="comment">// 输出：SELECT * FROM users WHERE age &gt; 18 AND status = 1</span></span><br></pre></td></tr></table></figure></div>

<h4 id="差异对比"><a href="#差异对比" class="headerlink" title="差异对比"></a>差异对比</h4><table>
<thead>
<tr>
<th>场景</th>
<th><code>+</code> 操作符</th>
<th><code>StringBuilder</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>单次拼接</strong></td>
<td>直接使用（编译器优化）</td>
<td>不必要</td>
</tr>
<tr>
<td><strong>循环内拼接</strong></td>
<td>产生大量临时对象</td>
<td>单对象高效操作</td>
</tr>
<tr>
<td><strong>需要中间操作</strong></td>
<td>无法实现</td>
<td>支持插入&#x2F;删除&#x2F;替换等</td>
</tr>
</tbody></table>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><p><strong>字面量合并机制</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span> + <span class="string">&quot;B&quot;</span>;  <span class="comment">// 编译后优化为 &quot;AB&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;A&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;B&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> a + b;     <span class="comment">// 运行时创建新对象</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>类型自动转换</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StringBuilder可接受任意类型</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="number">100</span>)</span><br><span class="line">                   .append(<span class="literal">true</span>)</span><br><span class="line">                   .append(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>线程安全替代方案</strong>：</p>
<ul>
<li>多线程环境使用 <code>StringBuffer</code>（方法同步）</li>
<li>单线程优先使用 <code>StringBuilder</code>（更高效）</li>
</ul>
</li>
</ol>
<h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p>包装类 是八种基本数据类型对应的 <strong>引用类型</strong>.</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
<p>八种包装类的关系如图:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8api/file-20250226154409061.jpg"
                     
                ></p>
<p><strong>存在意义</strong>：</p>
<ol>
<li>让基本类型具备对象特性（可放入集合&#x2F;支持 null 值&#x2F;实现泛型）</li>
<li>提供类型转换、进制转换等工具方法</li>
<li>符合面向对象设计原则</li>
</ol>
<p><strong>内存差异</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;                <span class="comment">// 栈内存直接存储值</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">objNum</span> <span class="operator">=</span> <span class="number">10</span>;         <span class="comment">// 堆内存存储对象（包含方法区引用）</span></span><br></pre></td></tr></table></figure></div>

<h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h3><p>JDK5 开始 , Java 引入了自动装箱和自动拆箱机制, 实现了包装类与基本类型之间的自动转换.</p>
<p><strong>装箱</strong>：基本类型 → 包装类型（自动调用<code>valueOf()</code>）<br><strong>拆箱</strong>：包装类型 → 基本类型（自动调用<code>xxxValue()</code>）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8api/file-20250226160910528.jpg"
                     
                ></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">100</span>;        <span class="comment">// 等价于 Integer.valueOf(100)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动拆箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;              <span class="comment">// 等价于 a.intValue()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 集合中的自动装箱</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">5</span>);            <span class="comment">// 自动装箱为 Integer</span></span><br></pre></td></tr></table></figure></div>

<p><strong>风险点</strong>：</p>
<p>空指针风险（重点规避）</p>
<p><strong>典型场景</strong>：包装类对象为 <code>null</code> 时执行拆箱操作</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> getFromDB(); <span class="comment">// 可能返回 null</span></span><br><span class="line"><span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> price + <span class="number">10</span>;      <span class="comment">// 抛出 NullPointerException</span></span><br></pre></td></tr></table></figure></div>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1. 类型转换"></a>1. 类型转换</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>Integer.parseInt(&quot;123&quot;)</code></td>
<td>字符串 → 基本类型</td>
<td><code>int x = Integer.parseInt(&quot;42&quot;)</code></td>
</tr>
<tr>
<td><code>Integer.valueOf(&quot;101&quot;)</code></td>
<td>字符串 → 包装类型</td>
<td><code>Integer y = Integer.valueOf(&quot;101&quot;)</code></td>
</tr>
<tr>
<td><code>numObj.toString()</code></td>
<td>包装类型 → 字符串</td>
<td><code>&quot;Value: &quot; + Integer.valueOf(5)</code></td>
</tr>
</tbody></table>
<h4 id="2-进制转换"><a href="#2-进制转换" class="headerlink" title="2. 进制转换"></a>2. 进制转换</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二进制转换</span></span><br><span class="line">System.out.println(Integer.toBinaryString(<span class="number">10</span>));    <span class="comment">// 1010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制转换</span></span><br><span class="line">System.out.println(Integer.toHexString(<span class="number">255</span>));      <span class="comment">// ff</span></span><br></pre></td></tr></table></figure></div>

<h4 id="3-极值常量"><a href="#3-极值常量" class="headerlink" title="3. 极值常量"></a>3. 极值常量</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE;   <span class="comment">// 2147483647</span></span><br><span class="line"><span class="type">double</span> <span class="variable">min</span> <span class="operator">=</span> Double.MIN_VALUE; <span class="comment">// 4.9E-324</span></span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="对象缓存机制"><a href="#对象缓存机制" class="headerlink" title="对象缓存机制"></a>对象缓存机制</h3><p><strong>缓存范围</strong>：</p>
<ul>
<li><code>Integer</code>: -128 ~ 127</li>
<li><code>Boolean</code>: true&#x2F;false 全部缓存</li>
<li><code>Character</code>: 0 ~ 127</li>
</ul>
<p><strong>影响比较逻辑</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">System.out.println(a == b);       <span class="comment">// true（使用缓存对象）</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(c == d);       <span class="comment">// false（新建对象）</span></span><br></pre></td></tr></table></figure></div>

<p><strong>正确比较方式</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 equals() 比较内容</span></span><br><span class="line">System.out.println(c.equals(d));  <span class="comment">// true（值相同）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 compareTo() 比较大小</span></span><br><span class="line">System.out.println(c.compareTo(<span class="number">200</span>)); <span class="comment">// -72（小于返回负数）</span></span><br></pre></td></tr></table></figure></div>

<h5 id="1-优先使用基本类型场景"><a href="#1-优先使用基本类型场景" class="headerlink" title="1. 优先使用基本类型场景"></a>1. 优先使用基本类型场景</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反例：无意义的对象创建</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> i;  <span class="comment">// 产生大量临时对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正例：基本类型更高效</span></span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0L</span>;        <span class="comment">// 基本类型无对象开销</span></span><br></pre></td></tr></table></figure></div>

<h5 id="2-Null-安全处理方案"><a href="#2-Null-安全处理方案" class="headerlink" title="2. Null 安全处理方案"></a>2. Null 安全处理方案</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">price</span> <span class="operator">=</span> getFromDB();  <span class="comment">// 可能返回null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案一：默认值处理</span></span><br><span class="line"><span class="type">int</span> <span class="variable">safePrice</span> <span class="operator">=</span> (price != <span class="literal">null</span>) ? price : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方案二：Optional处理</span></span><br><span class="line"><span class="type">int</span> <span class="variable">safePrice</span> <span class="operator">=</span> Optional.ofNullable(price).orElse(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></div>

<h5 id="3-性能敏感场景优化"><a href="#3-性能敏感场景优化" class="headerlink" title="3. 性能敏感场景优化"></a>3. 性能敏感场景优化</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 低效做法（反复拆箱装箱）</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">    total += i;  <span class="comment">// 等效于 total = Integer.valueOf(total.intValue() + i)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效做法（使用基本类型）</span></span><br><span class="line"><span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100000</span>; i++) &#123;</span><br><span class="line">    total += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><ol>
<li><p><strong>数据库字段映射</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 允许字段值为null</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;  <span class="comment">// 使用包装类表示年龄可能未知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>JSON 数据解析</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理可能缺失的数值字段</span></span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> getApiResponse();</span><br><span class="line"><span class="type">Integer</span> <span class="variable">score</span> <span class="operator">=</span> data.has(<span class="string">&quot;score&quot;</span>) ? data.getInt(<span class="string">&quot;score&quot;</span>) : <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>泛型集合操作</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 基本类型不能用于泛型</span></span><br><span class="line">ids.add(<span class="number">1001</span>);</span><br><span class="line">ids.add(<span class="literal">null</span>);  <span class="comment">// 允许存储空值</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>自定义异常 就是自定义类并继承 Exception 或 Runtime Exception.</p>
<p>自定义异常有以下好处:</p>
<ul>
<li>能够针对不同业务定义不同异常</li>
<li>避免了臃肿的方法声明</li>
<li>简化异常处理逻辑</li>
<li>更清晰地展示错误信息</li>
</ul>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常就是程序执行过程中导致程序正常执行流程被中断的不确定事件.</p>
<p>Java 对异常进行了总结归类, 然后把他们封装成了不同的类, 形成了一整套的异常继承体系.<br>其中, 最顶级的父类是 <code>Throwable</code> .</p>
<pre class="mermaid">graph TD
    Throwable --> Error(系统错误<br>Error)
    Throwable --> Exception(程序异常<br>Exception)
    Error --> StackOverflowError(栈溢出错误<br>StackOverflowError)
    Error --> OutOfMemoryError(内存溢出错误<br>OutOfMemoryError)
    Exception --> RuntimeException(运行时异常<br>RuntimeException)
    Exception --> CheckedException(受检异常<br>CheckedException)</pre>

<p>Error 是程序之外的错误, 例如:</p>
<ul>
<li>StackOverflowError: 栈溢出错误.</li>
<li>OutOfMemoryFeeoe: 内存溢出错误</li>
</ul>
<p>Exception 是程序本身的异常, 可以分为</p>
<ul>
<li>运行期异常, 也叫 unchecked 异常</li>
<li>编译期异常, 也叫 checked 异常</li>
</ul>
<p><strong>高频异常类型</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 运行时异常（无需提前处理）</span></span><br><span class="line">NullPointerException <span class="comment">// 空指针</span></span><br><span class="line">ArrayIndexOutOfBoundsException <span class="comment">// 数组越界</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 受检异常（必须处理）</span></span><br><span class="line">IOException <span class="comment">// 文件操作异常</span></span><br><span class="line">SQLException <span class="comment">// 数据库操作异常</span></span><br></pre></td></tr></table></figure></div>

<h3 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h3><p>编译期异常, 也就是<strong>受检异常</strong>(checked Exception) 是需要在开发时显式处理的, 不然程序编译不会通过.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8api/file-20250228142321052.jpg"
                     
                ><br>处理方案之一就是 <code>try-carch</code> 捕获异常.</p>
<p><strong>基础模板</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能出问题的代码</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// 处理文件未找到的情况</span></span><br><span class="line">    System.out.println(<span class="string">&quot;文件不存在！&quot;</span>);</span><br><span class="line">    e.printStackTrace(); <span class="comment">// 打印错误栈</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否异常都会执行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;资源清理操作&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>多异常处理</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr[<span class="number">5</span>]); <span class="comment">// 可能数组越界</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    num.toString(); <span class="comment">// 可能空指针</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException | NullPointerException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发生运行时异常：&quot;</span> + e.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h3><p>异常除了 <code>try-catch</code> 捕获以外, 也可通过 <code>throw</code> 抛出.<br>如果抛出的是编译期异常, 还需要再抛出的方法上用 <code>throws</code> 声明抛出的异常.</p>
<p><strong>方法声明抛出</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取配置文件方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readConfig</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> Files.readString(Path.of(<span class="string">&quot;config.cfg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>手动抛出异常</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> <span class="keyword">throws</span> InsufficientFundsException &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount &gt; balance) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InsufficientFundsException</span>(<span class="string">&quot;余额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="自定义异常-1"><a href="#自定义异常-1" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>自定义异常 就是自定义类并继承 <code>Exception</code> 或 <code>Runtime Exception</code>.<br>自定义异常有以下好处:</p>
<ul>
<li>能够针对不同业务定义不同异常</li>
<li>避免了臃肿的方法声明</li>
<li>简化异常处理逻辑</li>
<li>更清晰地展示错误信息</li>
</ul>
<p><strong>创建自定义异常</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 继承RuntimeException（非受检异常）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InvalidAgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvalidAgeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承Exception（受检异常）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaymentFailedException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PaymentFailedException</span><span class="params">(String errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;支付失败，错误码：&quot;</span> + errorCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>实际使用</strong>：</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidAgeException</span>(<span class="string">&quot;年龄必须≥18岁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p><strong>不要吞掉异常</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误做法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    riskyOperation();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 空catch块隐藏问题！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>精准捕获原则</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    parseData();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;  <span class="comment">// 明确异常类型</span></span><br><span class="line">    handleNumberError();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    handleIOError();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>finally 资源释放</strong></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 读取操作...</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(br != <span class="literal">null</span>) &#123;</span><br><span class="line">        br.close(); <span class="comment">// 确保文件流关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="Date-类（旧版-API，线程不安全）"><a href="#Date-类（旧版-API，线程不安全）" class="headerlink" title="Date 类（旧版 API，线程不安全）"></a>Date 类（旧版 API，线程不安全）</h3><p><strong>作用</strong>：表示时间戳（1970-01-01 00:00:00 GMT 至今的毫秒数），适用于简单时间记录和系统间传输</p>
<h4 id="构造方法表"><a href="#构造方法表" class="headerlink" title="构造方法表"></a>构造方法表</h4><table>
<thead>
<tr>
<th>方法签名</th>
<th>示例代码</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Date()</code></td>
<td><code>Date now = new Date()</code></td>
<td>创建当前系统时间实例（含毫秒）</td>
</tr>
<tr>
<td><code>Date(long milliseconds)</code></td>
<td><code>Date date = new Date(1672531200000L)</code></td>
<td>创建指定时间戳实例（对应 2023-01-01 00:00:00 GMT）</td>
</tr>
</tbody></table>
<h4 id="常用方法表"><a href="#常用方法表" class="headerlink" title="常用方法表"></a>常用方法表</h4><table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>应用场景</th>
<th>典型返回值示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>after(Date when)</code></td>
<td>boolean</td>
<td>验证票据有效期</td>
<td><code>true</code>&#x2F;<code>false</code></td>
</tr>
<tr>
<td><code>before(Date when)</code></td>
<td>boolean</td>
<td>判断活动是否已开始</td>
<td><code>true</code>&#x2F;<code>false</code></td>
</tr>
<tr>
<td><code>compareTo(Date)</code></td>
<td>int</td>
<td>时间排序（任务调度队列）</td>
<td><code>1</code>&#x2F;<code>0</code>&#x2F;<code>-1</code></td>
</tr>
<tr>
<td><code>getTime()</code></td>
<td>long</td>
<td>生成唯一 ID（时间戳+随机数）</td>
<td><code>1690012345678</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 场景1：验证订单有效期</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">createTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1690000000000L</span>);</span><br><span class="line"><span class="type">Date</span> <span class="variable">expireTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1690000000000L</span> + <span class="number">3600_000L</span>); <span class="comment">// 1小时后过期</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isValid</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().before(expireTime); <span class="comment">// 检查当前是否在有效期内</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景2：生成唯一ID</span></span><br><span class="line">String <span class="title function_">generateOrderId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">    <span class="type">int</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> timestamp + <span class="string">&quot;-&quot;</span> + random; <span class="comment">// &quot;1690012345678-742&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 场景3：时间排序</span></span><br><span class="line">List&lt;Date&gt; dates = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1690000000000L</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1680000000000L</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1700000000000L</span>)</span><br><span class="line">);</span><br><span class="line">Collections.sort(dates); <span class="comment">// 自然顺序排序</span></span><br></pre></td></tr></table></figure></div>

<h3 id="LocalDate（日期处理）"><a href="#LocalDate（日期处理）" class="headerlink" title="LocalDate（日期处理）"></a>LocalDate（日期处理）</h3><p><strong>作用</strong>：处理年月日（YYYY-MM-DD），不包含时间及时区</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>now()</code></td>
<td>LocalDate</td>
<td>获取当前日期</td>
</tr>
<tr>
<td><code>of(year, month, day)</code></td>
<td>LocalDate</td>
<td>创建指定日期</td>
</tr>
<tr>
<td><code>parse(String)</code></td>
<td>LocalDate</td>
<td>解析标准格式字符串（ISO 8601）</td>
</tr>
<tr>
<td><code>plusDays(long)</code></td>
<td>LocalDate</td>
<td>日期加法（天）</td>
</tr>
<tr>
<td><code>minusMonths(long)</code></td>
<td>LocalDate</td>
<td>日期减法（月）</td>
</tr>
<tr>
<td><code>isBefore(LocalDate)</code></td>
<td>boolean</td>
<td>日期比较</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建示例</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">nationalDay</span> <span class="operator">=</span> LocalDate.of(<span class="number">2023</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">parsedDate</span> <span class="operator">=</span> LocalDate.parse(<span class="string">&quot;2023-07-20&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用场景：计算有效期</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">orderDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">expireDate</span> <span class="operator">=</span> orderDate.plusDays(<span class="number">30</span>);  <span class="comment">// 30天后过期</span></span><br></pre></td></tr></table></figure></div>

<h3 id="LocalDateTime（日期时间处理）"><a href="#LocalDateTime（日期时间处理）" class="headerlink" title="LocalDateTime（日期时间处理）"></a>LocalDateTime（日期时间处理）</h3><p><strong>作用</strong>：处理年月日时分秒（精确到纳秒），不包含时区</p>
<h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>now()</code></td>
<td>LocalDateTime</td>
<td>获取当前日期时间</td>
</tr>
<tr>
<td><code>of(year, month, day, hour, minute)</code></td>
<td>LocalDateTime</td>
<td>创建指定日期时间</td>
</tr>
<tr>
<td><code>plusHours(long)</code></td>
<td>LocalDateTime</td>
<td>时间加法（小时）</td>
</tr>
<tr>
<td><code>toLocalDate()</code></td>
<td>LocalDate</td>
<td>提取日期部分</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建与操作示例</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">meetingTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2023</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用场景：会议提醒</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">nextMeeting</span> <span class="operator">=</span> meetingTime.plusWeeks(<span class="number">1</span>).withHour(<span class="number">15</span>);  <span class="comment">// 下周同时间，改为15点</span></span><br></pre></td></tr></table></figure></div>

<h4 id="DateTimeFormatter（格式化解析）"><a href="#DateTimeFormatter（格式化解析）" class="headerlink" title="DateTimeFormatter（格式化解析）"></a>DateTimeFormatter（格式化解析）</h4><p><strong>作用</strong>：线程安全的日期格式处理</p>
<h4 id="常用模式"><a href="#常用模式" class="headerlink" title="常用模式"></a>常用模式</h4><table>
<thead>
<tr>
<th>模式符号</th>
<th>说明</th>
<th>示例输出</th>
</tr>
</thead>
<tbody><tr>
<td><code>yyyy</code></td>
<td>四位年份</td>
<td>2023</td>
</tr>
<tr>
<td><code>MM</code></td>
<td>两位月份</td>
<td>08</td>
</tr>
<tr>
<td><code>dd</code></td>
<td>两位日期</td>
<td>15</td>
</tr>
<tr>
<td><code>HH</code></td>
<td>24 小时制小时</td>
<td>14</td>
</tr>
<tr>
<td><code>mm</code></td>
<td>分钟</td>
<td>30</td>
</tr>
<tr>
<td><code>ss</code></td>
<td>秒</td>
<td>45</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式化示例</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> now.format(formatter);  <span class="comment">// &quot;2023-07-20 14:30&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析示例</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">parsed</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2023-12-31 23:59&quot;</span>, formatter);</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="Duration（时间间隔）"><a href="#Duration（时间间隔）" class="headerlink" title="Duration（时间间隔）"></a>Duration（时间间隔）</h3><p><strong>作用</strong>：精确计算时间差（支持纳秒级精度）</p>
<h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>between(start, end)</code></td>
<td>Duration</td>
<td>计算两个时间的间隔</td>
</tr>
<tr>
<td><code>toHours()</code></td>
<td>long</td>
<td>转换为小时总数</td>
</tr>
<tr>
<td><code>plusMinutes(long)</code></td>
<td>Duration</td>
<td>增加分钟数</td>
</tr>
<tr>
<td><code>isNegative()</code></td>
<td>boolean</td>
<td>判断是否为负时间间隔</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算代码执行时间</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">start</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">// ...执行操作...</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">end</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line"><span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(start, end);</span><br><span class="line">System.out.println(<span class="string">&quot;耗时：&quot;</span> + duration.toMillis() + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间增量操作</span></span><br><span class="line"><span class="type">Duration</span> <span class="variable">extended</span> <span class="operator">=</span> duration.plusHours(<span class="number">2</span>).plusMinutes(<span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>一盏灯与计算机文明：从开关到智能的进化之旅</title>
    <url>/2024/12/17/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E4%B8%80%E7%9B%8F%E7%81%AF%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%87%E6%98%8E%EF%BC%9A%E4%BB%8E%E5%BC%80%E5%85%B3%E5%88%B0%E6%99%BA%E8%83%BD%E7%9A%84%E8%BF%9B%E5%8C%96%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p>提问！一盏正常工作的灯有几种状态？</p>
<p>答案似乎不言而喻——<strong>通电亮起</strong> 与 <strong>断电熄灭</strong> 两种状态。</p>
<p>但若将视野投向计算机内部，这个简单的物理现象正在以每秒数十亿次的频率上演。正是这些微观开关的精密舞蹈，支撑起人类文明史上最庞大的电子巨兽。</p>
<h1 id="第零章：二进制的创世纪"><a href="#第零章：二进制的创世纪" class="headerlink" title="第零章：二进制的创世纪"></a>第零章：二进制的创世纪</h1><p>人类用 26 个字母构建文明，计算机用 0 与 1 书写史诗。前者诞生于感性的诗意，后者扎根于绝对的理性：</p>
<ul>
<li>高电平&#x3D;逻辑 1 ➔ 电子世界的”是”</li>
<li>低电平&#x3D;逻辑 0 ➔ 电子世界的”否”</li>
</ul>
<p>这些电子脉冲如同数字时代的甲骨文，通过最基本的逻辑运算编织出机器认知世界的法则：</p>
<ul>
<li><strong>与门（AND）</strong>：两个 1 相遇才诞生光明</li>
<li><strong>或门（OR）</strong>：存在即合理，任一 1 存在即点亮世界</li>
</ul>
<p>当 1947 年贝尔实验室的肖克利团队将这类逻辑刻入晶体管时，他们或许未曾想到，这些砂砾中的开关将成为驯服电子巨兽的缰绳。</p>
<h1 id="第一章：机械巴别塔的建造者"><a href="#第一章：机械巴别塔的建造者" class="headerlink" title="第一章：机械巴别塔的建造者"></a>第一章：机械巴别塔的建造者</h1><p>当 1946 年 ENIAC 在费城实验室点亮第一个真空管时，程序员们不得不用最原始的灯语与机器对话——他们拨动数千个开关的位置，如同黑暗中织网的蜘蛛，用二进制丝线直接操控硬件，只为让这头电子巨兽理解最简单的算术。</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">00101010 01110101 11001011</span><br></pre></td></tr></table></figure></div>

<p>这类机器语言虽然高效，但每个字符都需要精准的电子脉冲对应，如同在针尖上雕刻天书，是反人性的。</p>
<p>计算机先驱们很快发现，为什么不用直接用几个简单的字符来代表一长串晦涩的电子咒语？<br>于是汇编语言应运而生:</p>
<div class="code-container" data-rel="Armasm"><figure class="iseeu highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 机器码                    → 汇编指令</span></span><br><span class="line"><span class="comment">; 10110000 01100101        → MOV AL, 65h</span></span><br><span class="line"><span class="comment">; 00000100 00000001        → ADD AL, 1</span></span><br></pre></td></tr></table></figure></div>

<p>用 几个简单的字母 <code>MOV AX, BX</code> 就能替代 一长串的机器编码。这不仅仅是符号替换，更是人类首次声明自己不是开关的奴隶，而是逻辑的祭司。<br>从此，巨兽开始理解人类的密码。</p>
<h1 id="第二章：抽象即力量"><a href="#第二章：抽象即力量" class="headerlink" title="第二章：抽象即力量"></a>第二章：抽象即力量</h1><p>真正的技术革命始于对重复的厌倦。<br>当 FORTRAN 之父约翰·巴克斯写下<code>X=(A+B)*C</code>时，他不仅发明了第一个高级语言，更点燃了数字文明的<strong>抽象引擎</strong>。这行看似简单的公式，实则是跨越人机鸿沟的巴别塔：</p>
<div class="code-container" data-rel="Fortran"><figure class="iseeu highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">! 1957年的革命性代码示例</span></span><br><span class="line">X = (A + B) * C  <span class="comment">! 直接对应数学表达式</span></span><br></pre></td></tr></table></figure></div>

<p>对比当时繁琐的汇编操作：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 实现相同功能的汇编代码</span><br><span class="line">LOAD A</span><br><span class="line">ADD B</span><br><span class="line">MULT C</span><br><span class="line">STOR X</span><br></pre></td></tr></table></figure></div>

<p>这场革命如同人类从象形文字进化到字母文字——<strong>表达能力不变，认知成本骤降</strong>。</p>
<p>认知成本骤降, 带来了使用机会的增加, 随之而来的是问题和矛盾：</p>
<blockquote>
<p><strong>高效率与灵活性无法共存</strong></p>
</blockquote>
<p>由此, 高级语言分化出两大智慧形态，恰似东方水墨与西方油彩的并立：</p>
<ul>
<li>科学家需要数值计算快如闪电 → 发展出提前编译的极致优化</li>
<li>教育者希望即时看到代码结果 → 开创即时解释的灵活应变</li>
</ul>
<p>正是这种分工，让计算机既能驾驭航天器的精准控制（编译型），也能实现网页交互的瞬息万变（解释型）。</p>
<h1 id="第三章：工具即进化"><a href="#第三章：工具即进化" class="headerlink" title="第三章：工具即进化"></a>第三章：工具即进化</h1><p>所有伟大的发明都始于同一个念头：”能不能更省事？” 程序员们的偷懒史，演化成一场让机器理解人性的史诗远征。<br>当我们追溯工具演进史，会发现每个划时代工具的诞生，都在回答同一个终极问题：<strong>如何让机器更懂人性？</strong></p>
<p>1983 年的硅谷实验室里，一群头发蓬乱的工程师正在用最原始的方式驯服代码：他们左手翻阅着砖头般的《Unix 系统手册》，右手在三个终端间疯狂切换——一个编辑代码，一个编译程序，最后一个监控内存地址。<br>直到某个清晨，一个叛逆者将这三个窗口缝合在同一个界面，编程史上的普罗米修斯之火就此点燃。<br>第一个集成开发环境问世时，程序员终于摆脱了<strong>碎片化工具链</strong>的黑暗时代。</p>
<p>早期编写代码需要切换多个工具（编辑器、编译器、调试器），而集成开发环境将代码编写、调试、测试整合到单一界面。</p>
<p>当 Eclipse IDE 首次展示<strong>代码自动补全</strong>功能时，全场开发者起立鼓掌——他们知道，那个需要背诵整本 API 手册的时代结束了，现代 IDE 早已进化为智能工作台。<br>这就像中世纪的炼金术士突然获得了现代化学实验室，让<strong>专注力</strong>真正回归逻辑创造本身。</p>
<p>2005 年的 Linux 社区正经历至暗时刻。由于缺乏版本控制，来自全球的代码如洪水般涌入，版本冲突让系统摇摇欲坠，成百上千的代码贡献让系统濒临崩溃。托瓦兹用两周时间写出了 Git，从此代码世界有了自己的时光机：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看代码进化史</span></span><br><span class="line">git <span class="built_in">log</span> --graph --pretty=format:<span class="string">&#x27;%C(yellow)%h%Creset -%C(red)%d%Creset %s %C(green)(%cr)%Creset&#x27;</span> --abbrev-commit</span><br></pre></td></tr></table></figure></div>

<p>这条命令会展示出代码的进化树，每个分支都是平行宇宙的入口。<br>如今，GitHub 上每秒产生 7 个新代码库，这些数字巴别塔的基石，正是当年那个芬兰青年为自救写出的工具。</p>
<p>2013 年，所罗门·海克斯在旧金山演示 Docker 时，用了一个精妙比喻：”我们要把代码装进集装箱”。就像麦哲伦不需要为每片海域重造航船，Docker 让程序带着自己的运行环境环球航行。他的 Docker 将代码与运行环境封装成标准集装箱，终结了”在我机器上能跑”的千年魔咒。</p>
<p>真正的范式革命在 2021 年悄然而至，GitHub Copilot 横空出世。当程序员输入注释：”&#x2F;&#x2F; 计算斐波那契数列”，AI 自动补全了代码。<br>此刻，编程语言正在经历它的巴别塔崩塌，人与机器的对话终于跨越了语法的鸿沟。</p>
<h1 id="终章：未完成的史诗"><a href="#终章：未完成的史诗" class="headerlink" title="终章：未完成的史诗"></a>终章：未完成的史诗</h1><p>回望来时路，从 ENIAC 的 18000 个真空管到如今指甲盖大小的百亿晶体管芯片，这段进化史本质上是对”开关艺术”的极致演绎。当我们用人工智能生成代码、自动补全时，那个需要直接操控开关的原始野兽，已蜕变为理解人类意图的智能体。</p>
<p>或许某天，当量子比特打破 0&#x2F;1 的二元禁锢，我们又将见证新的语言革命。但无论如何进化，那些在硅基世界里翩翩起舞的电子，永远是人类理性之光的延续。</p>
<p>此刻在你指尖流转的每寸微光，都栖息着整部数字文明史。下次锁屏时，请留意那转瞬即逝的暗影：那是光的呼吸，是八十年前费城实验室的余烬，也是量子计算机苏醒前的晨露。所有奇迹的源代码，始终是开与关的古老韵脚。</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>编程入门</tag>
        <tag>计算机通识</tag>
        <tag>技术发展</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统期末复习</title>
    <url>/2025/01/05/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h3 id="操作系统的定义与特征"><a href="#操作系统的定义与特征" class="headerlink" title="操作系统的定义与特征"></a>操作系统的定义与特征</h3><ul>
<li><strong>定义</strong>：操作系统是<strong>计算机系统资源</strong>的管理者，处于裸机之上的第一层软件.</li>
<li><strong>特征</strong>：<ul>
<li><strong>并发性</strong></li>
<li><strong>共享性</strong></li>
<li><strong>虚拟性</strong></li>
<li><strong>不确定性</strong></li>
</ul>
</li>
</ul>
<h3 id="操作系统的基本类型"><a href="#操作系统的基本类型" class="headerlink" title="操作系统的基本类型"></a>操作系统的基本类型</h3><ul>
<li><strong>实时系统</strong>：对响应时间有严格要求，分为硬实时和软实时两种.</li>
<li><strong>分时系统</strong>：在一台主机上同时<strong>连接多台终端</strong>，允许多个用户同时使用计算机，但每个用户的响应时间会随着<strong>用户数的增加而变长</strong>.</li>
<li><strong>批处理系统</strong>：把多个作业同时提交给计算机，作业之间无须进行交互，系统按照一定的顺序依次执行作业.</li>
<li><strong>分布式系统</strong>：由<strong>多台</strong>计算机组成的系统.</li>
</ul>
<h3 id="单道与多道程序"><a href="#单道与多道程序" class="headerlink" title="单道与多道程序"></a>单道与多道程序</h3><ul>
<li><strong>单道程序</strong>：内存中只有一个程序，CPU 与 I&#x2F;O 设备串行工作，即在一个程序的输入、计算和输出阶段完成后，才能开始下一个程序的执行.</li>
<li><strong>多道程序</strong>：<ul>
<li><strong>宏观上并行</strong> <strong>微观上串行</strong></li>
<li><strong>实现前提</strong>：系统具有<strong>中断功能</strong></li>
<li><strong>资源分配单位</strong>：操作系统是以<strong>进程</strong>为单位分配资源的.</li>
</ul>
</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>假设程序 P1、P2 和 P3 的执行时间如下：</p>
<ul>
<li><strong>P1</strong>: 输入 5ms，计算 3ms，输出 4ms.</li>
<li><strong>P2</strong>: 输入 4ms，计算 1ms，输出 3ms.</li>
<li><strong>P3</strong>: 输入 5ms，计算 3ms，输出 4ms.</li>
</ul>
<ol>
<li>在单道批处理环境下，计算完成 3 道程序运行需要的最少时间。</li>
<li>在多道批处理环境下，计算完成 3 道程序运行需要的最少时间。</li>
</ol>
<h4 id="单道批处理环境"><a href="#单道批处理环境" class="headerlink" title="单道批处理环境"></a>单道批处理环境</h4><ul>
<li>输入时间：5 + 4 + 5 &#x3D; 14 ms</li>
<li>计算时间：3 + 1 + 3 &#x3D; 7 ms</li>
<li>输出时间：4 + 3 + 4 &#x3D; 11 ms</li>
</ul>
<p>总时间 &#x3D; 14 + 7 + 11 &#x3D; 32 ms</p>
<h4 id="多道批处理环境"><a href="#多道批处理环境" class="headerlink" title="多道批处理环境"></a>多道批处理环境</h4><ul>
<li>输入时间：5 + 4 + 5 &#x3D; 14 ms</li>
<li>计算时间：最长的计算时间是 3ms</li>
<li>输出时间：4 + 3 + 4 &#x3D; 11 ms</li>
</ul>
<p>总时间 &#x3D; 14 + 3 + 11 &#x3D; 28 ms</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h3 id="程序并发执行的特征"><a href="#程序并发执行的特征" class="headerlink" title="程序并发执行的特征"></a>程序并发执行的特征</h3><ul>
<li><strong>间断性</strong></li>
<li><strong>失去了封闭性</strong></li>
<li><strong>不可再现性</strong></li>
</ul>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul>
<li>定义：是指<strong>宏观上可同时执行的进程</strong>，即多个进程在时间上交替执行，从宏观上看它们是同时进行的，但实际上是交替占用 CPU 资源的.</li>
<li><strong>并发执行的程序具有不可再现性</strong>，因为它们的执行结果可能受到其他并发程序的影响，且执行顺序和时间不确定.</li>
<li><strong>并发进程之间可能需要同步或互斥</strong>，以协调它们之间的执行顺序或防止对共享资源的冲突访问.</li>
</ul>
<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul>
<li>多道程序环境中操作系统分配资源是以<strong>进程</strong>为单位的，进程是程序在执行过程中的动态实体，拥有独立的地址空间和系统资源.</li>
<li>操作系统用 <strong>PCB（进程控制块）</strong> 来管理与控制进程，PCB 记录了进程的运行状态、优先级、资源使用情况等信息.</li>
<li>管理和控制是通过<strong>原语</strong>来实现的，原语是操作系统提供的一组低级系统调用，用于创建、撤销、挂起、唤醒等进程操作.</li>
<li><strong>线程</strong>：是进程中的一个执行流，是 CPU 调度和执行的最小单位，线程之间共享进程的资源，但每个线程有自己的栈和寄存器等局部状态.</li>
<li>线程与进程的区别主要在于<strong>是否拥有独立的资源</strong>，进程拥有独立的地址空间和资源，而线程共享进程的资源，但有自己的局部状态.</li>
</ul>
<h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><ul>
<li><strong>同步</strong>：是指进程之间逻辑上的制约关系，即某些进程的执行必须等待其他进程完成某些操作后才能继续执行，以保证程序的逻辑正确性.</li>
<li><strong>互斥</strong>：是指同一时间内只能允许一个进程访问临界资源，临界区是访问临界资源的一段程序，通过互斥机制可以防止多个进程同时访问临界资源导致的数据不一致等问题.</li>
<li><strong>资源的有序分配策略</strong>：可以破坏循环等待资源条件，从而预防死锁的发生，例如按照资源编号顺序申请资源等.</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><strong>预防死锁</strong>：可以通过破坏死锁产生的四个必要条件之一来实现，这四个条件是互斥条件、请求和保持条件、不剥夺条件、循环等待条件.</li>
<li><strong>避免死锁</strong>：是避免系统进入不安全状态，即在资源分配过程中，始终确保系统处于安全状态，不会发生死锁，银行家算法是一种常用的避免死锁的算法，通过模拟资源分配过程来判断系统是否安全.</li>
</ul>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题 1"></a>例题 1</h2><p>系统有 4 个进程 P1、P2、P3、P4，它们的到达时间和服务时间（或处理时间）如下表所示：</p>
<table>
<thead>
<tr>
<th>进程名</th>
<th>到达时间</th>
<th>处理时间</th>
<th>开始时间</th>
<th>完成时间</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>2</td>
</tr>
<tr>
<td>P2</td>
<td>2</td>
<td>6</td>
<td>2</td>
<td>8</td>
</tr>
<tr>
<td>P3</td>
<td>4</td>
<td>4</td>
<td>10</td>
<td>14</td>
</tr>
<tr>
<td>P4</td>
<td>6</td>
<td>2</td>
<td>8</td>
<td>10</td>
</tr>
</tbody></table>
<ol>
<li>各个进程的周转时间？</li>
<li>所有进程的平均周转时间是多少？</li>
</ol>
<h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h4><p>周转时间 &#x3D; 完成时间 - 到达时间</p>
<ul>
<li><strong>P1</strong>：周转时间 &#x3D; 2 - 0 &#x3D; 2</li>
<li><strong>P2</strong>：周转时间 &#x3D; 8 - 2 &#x3D; 6</li>
<li><strong>P3</strong>：周转时间 &#x3D; 14 - 4 &#x3D; 10</li>
<li><strong>P4</strong>：周转时间 &#x3D; 10 - 6 &#x3D; 4</li>
</ul>
<h4 id="平均周转时间"><a href="#平均周转时间" class="headerlink" title="平均周转时间"></a>平均周转时间</h4><p>平均周转时间 &#x3D; (所有进程的周转时间之和) &#x2F; (进程数)</p>
<ul>
<li>所有进程的周转时间之和 &#x3D; 2 + 6 + 10 + 4 &#x3D; 22</li>
<li>进程数 &#x3D; 4</li>
</ul>
<p>平均周转时间 &#x3D; 22 &#x2F; 4 &#x3D; 5.5</p>
<h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题 2"></a>例题 2</h2><p>假设系统中有 5 个进程 P1、P2、P3、P4 和 P5，有 3 种类型的资源 A、B 和 C。初始资源分配情况如下：</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>已分配资源数量</th>
<th>最大资源需求量</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>0 0 3</td>
<td>0 0 4</td>
</tr>
<tr>
<td>P2</td>
<td>0 7 5</td>
<td>0 6 0</td>
</tr>
<tr>
<td>P3</td>
<td>5 3 5</td>
<td>2 3 5</td>
</tr>
<tr>
<td>P4</td>
<td>0 2 0</td>
<td>0 6 6</td>
</tr>
<tr>
<td>P5</td>
<td>0 0 6</td>
<td>5 5 2</td>
</tr>
</tbody></table>
<p>初始可用资源数为 (x, y, z)。<br>请问当 x，y，z 取值分别为 0，5，8 和 1，5，2 时，系统是否处于安全状态？为什么？</p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><ol>
<li><p><strong>计算 Need 矩阵</strong>：<br>{Need} &#x3D; {最大资源需求量} - {已分配资源数量}</p>
<ul>
<li><strong>P1</strong>: Need &#x3D; (0 0 4) - (0 0 3) &#x3D; (0 0 1)</li>
<li><strong>P2</strong>: Need &#x3D; (0 6 0) - (0 7 5) &#x3D; (0 -1 -5)</li>
<li><strong>P3</strong>: Need &#x3D; (2 3 5) - (5 3 5) &#x3D; (-3 0 0)</li>
<li><strong>P4</strong>: Need &#x3D; (0 6 6) - (0 2 0) &#x3D; (0 4 6)</li>
<li><strong>P5</strong>: Need &#x3D; (5 5 2) - (0 0 6) &#x3D; (5 5 -4)</li>
</ul>
</li>
<li><p><strong>判断系统是否处于安全状态</strong>：</p>
<ul>
<li>从可用资源数开始，检查是否存在一个进程，其 Need 小于或等于可用资源数.</li>
<li>如果存在这样的进程，假设该进程获得资源并执行完毕，然后释放其所有资源，更新可用资源数.</li>
<li>重复上述步骤，直到所有进程都能获得资源并执行完毕，或者没有进程可以满足条件.</li>
</ul>
</li>
</ol>
<h4 id="当-x，y，z-取值分别为-0，5，8"><a href="#当-x，y，z-取值分别为-0，5，8" class="headerlink" title="当 x，y，z 取值分别为 0，5，8"></a>当 x，y，z 取值分别为 0，5，8</h4><ul>
<li>可用资源数 &#x3D; (0 5 8)</li>
<li>检查 Need 矩阵：<ul>
<li><strong>P1</strong>: Need(0 0 1) &lt;&#x3D; Available(0 5 8)？是的，因为 0 &lt;&#x3D; 0, 0 &lt;&#x3D; 5, 1 &lt;&#x3D; 8.</li>
<li>P1 可以执行，执行后释放资源，可用资源数变为 (0+0, 5+0, 8+3) &#x3D; (0 5 11).</li>
<li>此时，没有其他进程的 Need 可以被满足（P2、P3、P4、P5 的 Need 都包含负数或超过可用资源），因此系统处于不安全状态.</li>
</ul>
</li>
</ul>
<h4 id="当-x，y，z-取值分别为-1，5，2"><a href="#当-x，y，z-取值分别为-1，5，2" class="headerlink" title="当 x，y，z 取值分别为 1，5，2"></a>当 x，y，z 取值分别为 1，5，2</h4><ul>
<li>可用资源数 &#x3D; (1 5 2)</li>
<li>检查 Need 矩阵：<ul>
<li><strong>P1</strong>: Need(0 0 1) &lt;&#x3D; Available(1 5 2)？是的，因为 0 &lt;&#x3D; 1, 0 &lt;&#x3D; 5, 1 &lt;&#x3D; 2.</li>
<li>P1 可以执行，执行后释放资源，可用资源数变为 (1+0, 5+0, 2+3) &#x3D; (1 5 5).</li>
<li><strong>P3</strong>: Need(-3 0 0) &lt;&#x3D; Available(1 5 5)？是的，因为-3 &lt;&#x3D; 1, 0 &lt;&#x3D; 5, 0 &lt;&#x3D; 5.</li>
<li>P3 可以执行，执行后释放资源，可用资源数变为 (1+5, 5+3, 5+5) &#x3D; (6 8 10).</li>
<li>此时，所有进程的 Need 都可以被满足，因此系统处于安全状态.</li>
</ul>
</li>
</ul>
<h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题 3"></a>例题 3</h2><p>桌上有一个盘子，最多可存放两个水果。<br>妈妈向盘子中放苹果或桔子。<br>儿子专吃盘子中的桔子，女儿专吃盘子里的苹果。<br>取、放水果不能同时 进行。试用 PV 操作实现三个人的同步，并写出程序描述。</p>
<p>在这个问题中，我们需要使用信号量（semaphores）来实现妈妈、儿子和女儿之间的同步。信号量用于控制对共享资源的访问，确保在任何时刻只有一个操作可以进行。</p>
<h3 id="信号量说明"><a href="#信号量说明" class="headerlink" title="信号量说明"></a>信号量说明</h3><ul>
<li><strong>mutex</strong>：用于互斥访问盘子，初始值为 1.</li>
<li><strong>Sd</strong>：表示盘子中水果的总数，初始值为 2（因为盘子最多可放两个水果）.</li>
<li><strong>So</strong>：表示盘子中桔子的数量，初始值为 0.</li>
<li><strong>Sa</strong>：表示盘子中苹果的数量，初始值为 0.</li>
</ul>
<h3 id="操作说明"><a href="#操作说明" class="headerlink" title="操作说明"></a>操作说明</h3><ul>
<li><strong>P 操作</strong>（wait）：用于等待信号量的值大于 0，然后将其减 1，表示正在使用资源.</li>
<li><strong>V 操作</strong>（signal）：用于将信号量的值加 1，表示释放资源.</li>
<li><strong>mutex</strong>信号量用于互斥访问盘子，确保在任何时刻只有一个操作（放入或取出水果）可以进行.</li>
<li><strong>Sd</strong>信号量用于控制盘子的容量，确保盘子不会超过两个水果.</li>
<li><strong>So</strong>和<strong>Sa</strong>信号量分别用于同步桔子和苹果的数量，确保儿子和女儿能够正确地取出他们想要的水果.</li>
</ul>
<h3 id="程序描述"><a href="#程序描述" class="headerlink" title="程序描述"></a>程序描述</h3><h4 id="妈妈（Mother）"><a href="#妈妈（Mother）" class="headerlink" title="妈妈（Mother）"></a>妈妈（Mother）</h4><p>妈妈的任务是向盘子中放入水果（苹果或桔子），并确保盘子不会超过容量限制.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Mother</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 选择放入水果的类型</span></span><br><span class="line">        <span class="keyword">if</span> (放入桔子) &#123;</span><br><span class="line">            P(Sd);  <span class="comment">// 等待盘子有空位</span></span><br><span class="line">            P(mutex);  <span class="comment">// 获取对盘子的互斥访问</span></span><br><span class="line">            <span class="comment">// 放入桔子</span></span><br><span class="line">            V(mutex);  <span class="comment">// 释放对盘子的互斥访问</span></span><br><span class="line">            V(So);  <span class="comment">// 增加盘子中桔子的数量</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P(Sd);  <span class="comment">// 等待盘子有空位</span></span><br><span class="line">            P(mutex);  <span class="comment">// 获取对盘子的互斥访问</span></span><br><span class="line">            <span class="comment">// 放入苹果</span></span><br><span class="line">            V(mutex);  <span class="comment">// 释放对盘子的互斥访问</span></span><br><span class="line">            V(Sa);  <span class="comment">// 增加盘子中苹果的数量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="儿子（Son）"><a href="#儿子（Son）" class="headerlink" title="儿子（Son）"></a>儿子（Son）</h4><p>儿子的任务是取出盘子中的桔子.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(So);  <span class="comment">// 等待盘子中有桔子</span></span><br><span class="line">        P(mutex);  <span class="comment">// 获取对盘子的互斥访问</span></span><br><span class="line">        <span class="comment">// 取出桔子</span></span><br><span class="line">        V(mutex);  <span class="comment">// 释放对盘子的互斥访问</span></span><br><span class="line">        V(Sd);  <span class="comment">// 增加盘子的空位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="女儿（Daughter）"><a href="#女儿（Daughter）" class="headerlink" title="女儿（Daughter）"></a>女儿（Daughter）</h4><p>女儿的任务是取出盘子中的苹果.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Daughter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(Sa);  <span class="comment">// 等待盘子中有苹果</span></span><br><span class="line">        P(mutex);  <span class="comment">// 获取对盘子的互斥访问</span></span><br><span class="line">        <span class="comment">// 取出苹果</span></span><br><span class="line">        V(mutex);  <span class="comment">// 释放对盘子的互斥访问</span></span><br><span class="line">        V(Sd);  <span class="comment">// 增加盘子的空位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="存储器原理"><a href="#存储器原理" class="headerlink" title="存储器原理"></a>存储器原理</h1><h2 id="例题-1-1"><a href="#例题-1-1" class="headerlink" title="例题 1"></a>例题 1</h2><p>如果页面访问序列 0、3、6、5、6、2、4、3、2、5，且进程开始执行时，内 存中没有页面（初始为空），若给该进程分配驻留集为 3 个物理块，如下所示： 使用先进先出（FIFO）置换算法和用 LRU 置换算法。</p>
<ol>
<li>缺页中断次数、页面置换次数、缺页率分别是多少？</li>
<li>如果进程开始执行前，将最开始的 3 页先装入内存，会产生多少次缺页中断？</li>
</ol>
<h3 id="页面置换算法的基本概念"><a href="#页面置换算法的基本概念" class="headerlink" title="页面置换算法的基本概念"></a>页面置换算法的基本概念</h3><p>在虚拟存储器中，当一个进程访问的页面不在内存中时，会发生缺页中断。此时，操作系统需要从磁盘中将该页面调入内存。如果内存已满，就需要选择一个页面将其置换出内存，以便为新页面腾出空间。页面置换算法就是用来决定哪个页面应该被置换出内存的规则.</p>
<h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><p>题目关键信息:</p>
<ul>
<li>页面访问序列为：0、3、6、5、6、2、4、3、2、5，内存块数为 3，初始时内存为空.</li>
</ul>
<h3 id="FIFO-算法（先进先出）"><a href="#FIFO-算法（先进先出）" class="headerlink" title="FIFO 算法（先进先出）"></a>FIFO 算法（先进先出）</h3><ul>
<li><strong>基本原理</strong>：FIFO 算法按照页面进入内存的顺序来决定置换顺序，即最早进入内存的页面最先被置换出.</li>
<li><strong>工作过程</strong>：<ol>
<li>当发生缺页中断时，检查内存中是否有空闲的内存块.</li>
<li>如果有空闲内存块，直接将缺失的页面装入空闲内存块中.</li>
<li>如果没有空闲内存块，选择最早进入内存的页面将其置换出，然后将缺失的页面装入该内存块中.</li>
</ol>
</li>
</ul>
<h4 id="FIFO-算法操作过程"><a href="#FIFO-算法操作过程" class="headerlink" title="FIFO 算法操作过程"></a>FIFO 算法操作过程</h4><ul>
<li>访问 0：缺页，装入内存块 1，内存状态：[0, -, -].</li>
<li>访问 3：缺页，装入内存块 2，内存状态：[0, 3, -].</li>
<li>访问 6：缺页，装入内存块 3，内存状态：[0, 3, 6].</li>
<li>访问 5：缺页，置换内存块 1（0 -&gt; 5），内存状态：[5, 3, 6].</li>
<li>访问 6：不缺页，内存状态：[5, 3, 6].</li>
<li>访问 2：缺页，置换内存块 2（3 -&gt; 2），内存状态：[5, 2, 6].</li>
<li>访问 4：缺页，置换内存块 3（6 -&gt; 4），内存状态：[5, 2, 4].</li>
<li>访问 3：缺页，置换内存块 1（5 -&gt; 3），内存状态：[3, 2, 4].</li>
<li>访问 2：不缺页，内存状态：[3, 2, 4].</li>
<li>访问 5：缺页，置换内存块 2（2 -&gt; 5），内存状态：[3, 5, 4].</li>
</ul>
<h3 id="LRU-算法（最近最少使用）"><a href="#LRU-算法（最近最少使用）" class="headerlink" title="LRU 算法（最近最少使用）"></a>LRU 算法（最近最少使用）</h3><ul>
<li><strong>基本原理</strong>：LRU 算法根据页面最近的使用情况来决定置换顺序，即最近最少使用的页面最先被置换出.</li>
<li><strong>工作过程</strong>：<ol>
<li>当发生缺页中断时，检查内存中是否有空闲的内存块.</li>
<li>如果有空闲内存块，直接将缺失的页面装入空闲内存块中.</li>
<li>如果没有空闲内存块，选择最后面的页面，即最久未被访问的页面将其置换出，然后将缺失的页面装入该内存块中.</li>
</ol>
</li>
</ul>
<h4 id="LRU-算法操作过程"><a href="#LRU-算法操作过程" class="headerlink" title="LRU 算法操作过程"></a>LRU 算法操作过程</h4><ul>
<li>访问 0：缺页，装入内存块 1，内存状态：[0, -, -].</li>
<li>访问 3：缺页，装入内存块 2，内存状态：[0, 3, -].</li>
<li>访问 6：缺页，装入内存块 3，内存状态：[0, 3, 6].</li>
<li>访问 5：缺页，置换内存块 1（0 -&gt; 5），内存状态：[5, 3, 6].</li>
<li>访问 6：不缺页，内存状态：[5, 3, 6].</li>
<li>访问 2：缺页，置换内存块 2（3 -&gt; 2），内存状态：[5, 2, 6].</li>
<li>访问 4：缺页，置换内存块 3（6 -&gt; 4），内存状态：[5, 2, 4].</li>
<li>访问 3：缺页，置换内存块 1（5 -&gt; 3），内存状态：[3, 2, 4].</li>
<li>访问 2：不缺页，内存状态：[3, 2, 4].</li>
<li>访问 5：缺页，置换内存块 2（2 -&gt; 5），内存状态：[3, 5, 4].</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>FIFO 算法</strong>：<ul>
<li>初始为空时：缺页中断次数&#x3D;8，页面置换次数&#x3D;5，缺页率&#x3D;80%.</li>
</ul>
</li>
<li><strong>LRU 算法</strong>：<ul>
<li>初始为空时：缺页中断次数&#x3D;8，页面置换次数&#x3D;5，缺页率&#x3D;80%.</li>
</ul>
</li>
</ul>
<h2 id="例题-2-1"><a href="#例题-2-1" class="headerlink" title="例题 2"></a>例题 2</h2><p>某虚拟存储器（采用请求页式存储管理）的用户空间共有 64 个页面，每页 1KB，内存 32KB。假定某用户作业的长度为 6 页，进程驻留集为 3 个内存块。<br>某时刻系统为用户的第 0、1、2 页分配的内存块号分别为 4、5、6。<br>假设逻辑地址(或虚拟地址)的访问序列 0A2DH、106FH、1A33H（H 表示十六进制），将 3 个逻辑地址转换成物理地址，若能够转换，则说明转换过程，并给出具体的物理地址;若不能转换，则说明原因。</p>
<p>题目关键信息:</p>
<ul>
<li>用户空间共有 64 个页面，每页 1KB.</li>
<li>内存为 32KB.</li>
<li>进程驻留集为 3 个内存块，系统为用户的第 0、1、2 页分配的内存块号分别为 4、5、6.</li>
<li>逻辑地址的访问序列：0A2DH、106FH、1A33H.</li>
</ul>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><ol>
<li><p><strong>确定页号和偏移量</strong>：</p>
<ul>
<li>由于每页 1KB，即(2^{10})字节，因此偏移量占 10 位.</li>
<li>用户空间有 64 个页面，即(2^6)页，因此页号占 6 位.</li>
</ul>
</li>
<li><p><strong>转换逻辑地址到物理地址</strong>：</p>
<ul>
<li>将逻辑地址转换为二进制形式.</li>
<li>分离出页号和偏移量，页号位于二进制表示的高位，偏移量位于低位.</li>
<li>检查页号是否合法（是否小于 64）.</li>
<li>检查该页是否已装入内存.<ul>
<li>如果该页已装入内存，将页号替换为对应的物理块号，拼接偏移量得到物理地址.</li>
<li>如果该页未装入内存，产生缺页中断.</li>
<li>如果页号不合法，访问越界.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="示例计算"><a href="#示例计算" class="headerlink" title="示例计算"></a>示例计算</h3><h4 id="逻辑地址-0A2DH"><a href="#逻辑地址-0A2DH" class="headerlink" title="逻辑地址 0A2DH"></a>逻辑地址 0A2DH</h4><ul>
<li><strong>转换为二进制</strong>：0A2DH &#x3D; 000010 1000101101B</li>
<li><strong>分离页号和偏移量</strong>：<ul>
<li>页号(高位) &#x3D; 000010B（或 2 号页）</li>
<li>偏移量(低位) &#x3D; 1000101101B</li>
</ul>
</li>
<li><strong>检查页号合法性</strong>：2 号页 &lt; 64，页号合法.</li>
<li><strong>检查内存块</strong>：2 号页已装入内存，对应物理块号为 6（0110B）.</li>
<li><strong>计算物理地址</strong>：将页号替换为对应的物理块号，物理地址 &#x3D; 011010 00101101B，即 1A2DH.</li>
</ul>
<h4 id="逻辑地址-106FH"><a href="#逻辑地址-106FH" class="headerlink" title="逻辑地址 106FH"></a>逻辑地址 106FH</h4><ul>
<li><strong>转换为二进制</strong>：106FH &#x3D; 000100 0001101111B</li>
<li><strong>分离页号和偏移量</strong>：<ul>
<li>页号(高位) &#x3D; 000100B（或 4 号页）</li>
<li>偏移量(低位) &#x3D; 00001101111B</li>
</ul>
</li>
<li><strong>检查页号合法性</strong>：4 号页 &lt; 64，页号合法.</li>
<li><strong>检查内存块</strong>：4 号页未装入内存，故产生缺页中断.</li>
</ul>
<h4 id="逻辑地址-1A33H"><a href="#逻辑地址-1A33H" class="headerlink" title="逻辑地址 1A33H"></a>逻辑地址 1A33H</h4><ul>
<li><strong>转换为二进制</strong>：1A33H &#x3D; 0001101000110011B</li>
<li><strong>分离页号和偏移量</strong>：<ul>
<li>页号 &#x3D; 000110B（或 6 号页）</li>
<li>偏移量 &#x3D; 001000110011B</li>
</ul>
</li>
<li><strong>检查页号合法性</strong>：6 号页 &lt; 64，页号合法.</li>
<li><strong>检查内存块</strong>：6 号页未装入内存，故产生缺页中断.</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li><strong>逻辑地址 0A2DH</strong>：可以转换为物理地址 1A2DH.</li>
<li><strong>逻辑地址 106FH</strong>：不能转换，因为该页未装入内存，产生缺页中断.</li>
<li><strong>逻辑地址 1A33H</strong>：不能转换，因为该页未装入内存，产生缺页中断.</li>
</ul>
<h2 id="例题-3-1"><a href="#例题-3-1" class="headerlink" title="例题 3"></a>例题 3</h2><p>假设一次内存的访问时间是 80ns,一次快表的访问时间是 10ns，采用最 近最久未使用（LRU）页面置换算法，处理一次缺页中断的平均时间是 200ns (包括更新快表和页表的时间）。<br>访问逻辑地址(或虚拟地址) 106FH 的物理地址和时间分别是多少？</p>
<p>题目关键信息:</p>
<ul>
<li>一次内存的访问时间是 80ns.</li>
<li>一次快表的访问时间是 10ns.</li>
<li>处理一次缺页中断的平均时间是 200ns (包括更新快表和页表的时间).</li>
<li>采用最近最久未使用（LRU）页面置换算法.</li>
</ul>
<h3 id="页表信息"><a href="#页表信息" class="headerlink" title="页表信息"></a>页表信息</h3><table>
<thead>
<tr>
<th>页号</th>
<th>内存块号</th>
<th>状态位</th>
<th>访问字段</th>
<th>装入内存时间</th>
<th>上次访问时间</th>
<th>修改位</th>
<th>外存地址</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>4</td>
<td>1</td>
<td>0:20:16</td>
<td>10:20:16</td>
<td>10:20:20</td>
<td>1</td>
<td>123</td>
</tr>
<tr>
<td>1</td>
<td>5</td>
<td>1</td>
<td>0:20:14</td>
<td>10:20:14</td>
<td>10:20:18</td>
<td>0</td>
<td>47</td>
</tr>
<tr>
<td>2</td>
<td>6</td>
<td>1</td>
<td>0:20:11</td>
<td>10:20:11</td>
<td>10:20:21</td>
<td>1</td>
<td>23</td>
</tr>
</tbody></table>
<h3 id="地址转换步骤"><a href="#地址转换步骤" class="headerlink" title="地址转换步骤"></a>地址转换步骤</h3><ol>
<li><p><strong>确定页号和偏移量</strong>：</p>
<ul>
<li>逻辑地址 106FH &#x3D; 000100 0001101111B.</li>
<li>页号 &#x3D; 000100B（或 4 号页）.</li>
<li>偏移量 &#x3D; 00001101111B.</li>
</ul>
</li>
<li><p><strong>检查页号合法性</strong>：</p>
<ul>
<li>4 号页 &lt; 6，不越界.</li>
</ul>
</li>
<li><p><strong>检查内存块</strong>：</p>
<ul>
<li>4 号页未装入内存，故产生缺页中断.</li>
</ul>
</li>
<li><p><strong>处理缺页中断</strong>：</p>
<ul>
<li>根据 LRU 置换算法，查表得应淘汰 1 号页.</li>
<li>4 号页存放在 5 号块的位置，块号是 0101.</li>
<li>偏移量：00001101111B.</li>
<li>物理地址：010100 0001101111B，即 146FH.</li>
</ul>
</li>
<li><p><strong>计算访问时间</strong>：</p>
<ul>
<li>一次快表的访问时间是 10ns.</li>
<li>一次内存的访问时间是 80ns.</li>
<li>处理一次缺页中断的平均时间是 200ns.</li>
<li>总时间 &#x3D; 快表访问时间 + 内存访问时间 + 缺页中断处理时间.</li>
<li>总时间 &#x3D; 10ns + 80ns + 200ns &#x3D; 290ns.</li>
</ul>
</li>
</ol>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ul>
<li><strong>物理地址</strong>：146FH.</li>
<li><strong>访问时间</strong>：290ns.</li>
</ul>
<h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h3 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h3><ol>
<li><strong>虚拟存储器</strong>：通过将主存和辅存结合起来，为用户提供一个比实际主存空间大得多的存储空间。</li>
<li><strong>请求页式管理</strong>：一种虚拟存储管理方式，当进程运行时，只有部分页面被调入内存，其余页面存放在辅存中，当需要访问不在内存中的页面时，发生缺页中断，操作系统会将该页面调入内存。</li>
<li><strong>页表</strong>：用于记录虚拟页号到物理块号的映射关系，是实现虚拟地址到物理地址转换的关键数据结构。</li>
<li><strong>缺页中断</strong>：当访问的页面不在内存中时，系统会触发缺页中断，将该页面从辅存调入内存，可能需要替换内存中的某些页面。</li>
<li><strong>页面置换算法</strong>：当内存空间不足时，选择一个页面将其移出内存，以便为新页面腾出空间。常见的算法有 FIFO、LRU 等.</li>
<li><strong>局部性原理</strong>：程序在运行过程中，其访问的地址空间具有时间局部性和空间局部性，即在一段时间内，程序倾向于访问相近的地址和重复访问某些地址，这为虚拟存储管理提供了理论基础.</li>
</ol>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><ol>
<li><strong>文件的存取方式</strong>：顺序存取 随机存取 .</li>
<li><strong>文件的逻辑结构</strong>：从用户的角度看到的文件组织方式，常见的有无结构文件和有结构文件（如<strong>顺序文件</strong>、<strong>索引文件</strong>、<strong>索引顺序文件</strong>等）.</li>
<li><strong>文件的物理结构</strong>：指文件在外存上的存储形式，常见的有连续分配、链接分配和索引分配等.</li>
<li><strong>文件控制块（FCB）</strong>：用于存储文件的基本信息、存取控制信息和文件的使用信息等，是文件系统管理文件的重要数据结构.</li>
<li><strong>文件目录</strong>：是文件控制块的集合，用于实现文件的符号名与物理地址的转换，方便用户管理和访问文件.</li>
<li><strong>多级目录结构</strong>：采用多级目录结构可以解决命名冲突问题，允许多个用户使用相同的文件名，同时提高了文件系统的灵活性和安全性.</li>
<li><strong>目录的功能</strong>：实现“按名存取”，提高文件检索速度，允许文件同名等.</li>
<li><strong>文件系统的安全性</strong>：通过设置文件的访问权限、密码保护等措施，确保文件系统的安全性，防止未授权访问和数据泄露等.</li>
<li><strong>文件系统的可靠性</strong>：采用文件备份、日志记录等技术手段，提高文件系统的可靠性，防止因系统故障等原因导致数据丢失或损坏.</li>
</ol>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>计算机理论</category>
      </categories>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/2023/09/23/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>大二上学期选修报名了Python,实际上也有点想学习的念头.早听说python处理一些重复性的事很在行?  </p>
<p>课程笔记来自:<a class="link"   href="https://www.bilibili.com/video/BV1qW4y1a7fU/?spm_id_from=333.999.0.0&vd_source=b19220b8f372f3a81aa8463fde694a63" >Python基础<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h1 id="Python-基础语法"><a href="#Python-基础语法" class="headerlink" title="Python 基础语法"></a>Python 基础语法</h1><h3 id="字面量、数据类型"><a href="#字面量、数据类型" class="headerlink" title="字面量、数据类型"></a>字面量、数据类型</h3><p>被写下来的固定值称之为字面量,有以下6种常用数据类型:</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>数字(Number)</td>
<td>整数(int)<br>浮点(float)<br>复数(complex)<br>布尔(bool)</td>
<td>复数形如4+3j,以j结尾表示的数</td>
</tr>
<tr>
<td>字符串(string)</td>
<td>描述文本的一种数据类型</td>
<td>由任意数量字符组成</td>
</tr>
<tr>
<td>列表(List)</td>
<td>有序的可变序列</td>
<td>Python中最频繁使用的数据类型</td>
</tr>
<tr>
<td>元组(Tuple)</td>
<td>有序的不可变序列</td>
<td>有序记录不可变的Python数据</td>
</tr>
<tr>
<td>集合(Set)</td>
<td>无序不重复集合</td>
<td>可无序记录不重复的数据</td>
</tr>
<tr>
<td>字典(Dictionary)</td>
<td>无序Key-Value集合</td>
<td>无序记录Key-Value型数据</td>
</tr>
</tbody></table>
<p><code>type()</code>能够查看字面量和变量的数据类型</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">114</span></span><br><span class="line"><span class="number">5.14</span></span><br><span class="line"><span class="string">&quot;我去!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 甚至都不用声明类型...</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">另外关于注释,单行注释是一个井号就ok,</span></span><br><span class="line"><span class="string">多行注释是像这样三个引号.</span></span><br><span class="line"><span class="string">不过md的代码块好像没给显示出来</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><table>
<thead>
<tr>
<th>语句(函数)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int(x)</td>
<td>将x转换为整数</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换为浮点数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将x转换为字符串</td>
</tr>
</tbody></table>
<ul>
<li>任何类型都可以转换成字符串</li>
<li>字符串只有数字才能转换成数字</li>
<li>浮点转换整数会丢失精度(小数部分)</li>
</ul>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>是用户在编程时用于给变量、类、方法等自定义的命名.<br>能自定义标识符的有:</p>
<ul>
<li>变量的名字</li>
<li>方法的名字</li>
<li>类的名字,等等…</li>
</ul>
<p>注意:  </p>
<ul>
<li>标识符不能以数字开头  </li>
<li>标识符不能使用关键字</li>
<li>标识符不推荐使用中文</li>
<li>标识符大小写敏感</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>除加减乘除外Python还有:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;&#x2F;</td>
<td>取整</td>
<td>返回商的整数部分</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>返回商的余数部分</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
<td>就是指数运算</td>
</tr>
</tbody></table>
<p>除了基本运算,Python也支持赋值运算.<br><strong>注意: Python 中是没有 ++ 和 – 的</strong></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol>
<li>单引号定义法: <code>name=&#39;雲之残骸&#39;</code></li>
<li>双引号定义法: <code>name=&quot;雲之残骸&quot;</code></li>
<li>三引号定义法: <code>name=&quot;&quot;&quot;雲之残骸&quot;&quot;&quot;</code></li>
</ol>
<p>其中,三引号定义法和多行注释写法相同,同样支持换行<br>当使用变量接收它时,会变成字符串.<br>不使用变量接收时,就可以当作多行注释.   </p>
<p>除了用 “+” 号拼接字符串, 我们还能使用占位符快速拼接字符串和变量  </p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;雲之残骸&quot;</span></span><br><span class="line">year = <span class="number">114514</span></span><br><span class="line">price = <span class="number">19.5</span></span><br><span class="line">massage = <span class="string">&quot;我去,是 %s.今年是 %d 年,衬衫的价格是 %2.1f&quot;</span> % (name,year,price)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>输出: &gt; 我去,是 雲之残骸 .今年是 114514 年,衬衫的价格是 19.5</p>
</blockquote>
<p>其中,%s:</p>
<ul>
<li>% 表示:占位</li>
<li>s 表示:将变量变成字符串放入占位的地方</li>
</ul>
<p>这一点与c语言相同,包括支持 %f 浮点数.<br>使用格式 %m.nf 能实现控制精度.</p>
<p>快速写法:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;雲之残骸&quot;</span></span><br><span class="line">year = <span class="number">114514</span></span><br><span class="line">price = <span class="number">19.5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;我去,是<span class="subst">&#123;name&#125;</span>.今年是 <span class="subst">&#123;year&#125;</span> 年,衬衫的价格是 <span class="subst">&#123;price&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>此方法不限数字类型,也不关心精度控制.</p>
<h3 id="数据输入输出"><a href="#数据输入输出" class="headerlink" title="数据输入输出"></a>数据输入输出</h3><ul>
<li>输出: print<br>print输出默认换行,若想让输出换行,则可以:</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)  </span><br><span class="line">```    </span><br><span class="line">可以在结尾加上 `end=<span class="string">&#x27;&#x27;</span>` 即可不换行.</span><br><span class="line">* 输入: <span class="built_in">input</span></span><br><span class="line"></span><br><span class="line">```Python</span><br><span class="line"><span class="comment"># 可以直接把提示语句写在input中:</span></span><br><span class="line"></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;你是?&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;明白了,你是 %s&quot;</span> % name)</span><br></pre></td></tr></table></figure></div>

<p>input输入的数据默认都会当成<strong>字符串</strong><br>可以使用强制转换: num &#x3D; input(num)</p>
<h1 id="Python-判断语句"><a href="#Python-判断语句" class="headerlink" title="Python 判断语句"></a>Python 判断语句</h1><p><strong>True &#x3D; 1<br>False &#x3D; 0</strong></p>
<h3 id="if-判断语句"><a href="#if-判断语句" class="headerlink" title="if 判断语句"></a>if 判断语句</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 要判断的条件<span class="number">1</span>:</span><br><span class="line">    条件成立要做的事<span class="number">1</span></span><br><span class="line">    条件成立要做的事<span class="number">2</span></span><br><span class="line"><span class="keyword">elif</span> 要判断的条件<span class="number">2</span>:</span><br><span class="line">    条件成立要做的事</span><br><span class="line"><span class="keyword">elif</span> 要判断的条件<span class="number">3</span>:</span><br><span class="line">    条件成立要做的事</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    条件不成立做的事</span><br></pre></td></tr></table></figure></div>

<p>注意冒号不能省略,<br>以及归属于if的代码块,需要四个空格缩进.      </p>
<p>可将input( )写入if中简化代码:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(<span class="built_in">input</span>(请输入数字:))&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure></div>
<p>例如将输入的数字与 3 比较判断大小.</p>
<h1 id="Python-循环语句"><a href="#Python-循环语句" class="headerlink" title="Python 循环语句"></a>Python 循环语句</h1><p>条件满足,便会去做对应的操作</p>
<h3 id="while-循环语句"><a href="#while-循环语句" class="headerlink" title="while 循环语句"></a>while 循环语句</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    条件满足,要做的事.</span><br></pre></td></tr></table></figure></div>

<p>嵌套循环时,一定要注意空格缩进来确定关系.</p>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 待处理数据集:</span><br><span class="line">    循环满足条件时执行的代码</span><br></pre></td></tr></table></figure></div>

<ul>
<li>for循环无法定义循环条件,只能被动取出数据处理</li>
<li>依旧注意缩进格式</li>
</ul>
<h4 id="for-循环的变量作用域"><a href="#for-循环的变量作用域" class="headerlink" title="for 循环的变量作用域"></a>for 循环的变量作用域</h4><p>临时变量, 在 <strong>编程规范</strong> 上, 作用范围(作用域), 只限定 for 循环内部.</p>
<p>如果在 for 循环外部访问的临时变量:</p>
<ul>
<li>实际上是能访问的.</li>
<li>在规范上, 是不允许的. <strong>不建议</strong> 这样做.</li>
<li>如需访问, 可以在循环外定义它.</li>
</ul>
<h3 id="range-语句"><a href="#range-语句" class="headerlink" title="range 语句"></a>range 语句</h3><p>本质上是遍历: 序列类型</p>
<ul>
<li>语法 1</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(num)</span><br></pre></td></tr></table></figure></div>

<p>获取一个从 0 开始, 到 num 结束的数字序列 (<strong>不含</strong>num本身)</p>
<ul>
<li>语法 2</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(num1,num2)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">获得一个从 num1 开始, 到 num2 结束的数字序列 (**不含**num2本身)</span><br><span class="line"></span><br><span class="line">* 语法 <span class="number">3</span></span><br><span class="line"></span><br><span class="line">```Python</span><br><span class="line"><span class="built_in">range</span>(num1,num2,step)</span><br></pre></td></tr></table></figure></div>
<p>获得一个从 num1 开始,到 num2 结束的数字序列 (<strong>不含</strong>num2本身)<br>数字之间的步长为step的值 (step默认为 1 )</p>
<h3 id="continue-和-break-关键字"><a href="#continue-和-break-关键字" class="headerlink" title="continue 和 break 关键字"></a>continue 和 break 关键字</h3><ul>
<li>临时跳过: contine</li>
</ul>
<p>中断本次循环, 直接进入下一次循环  </p>
<ul>
<li>直接结束: break</li>
</ul>
<p>直接结束循环</p>
<h1 id="Python-函数"><a href="#Python-函数" class="headerlink" title="Python 函数"></a>Python 函数</h1><p>函数是 <strong>组织好的</strong>, <strong>可重复使用的</strong>, 用来<strong>实现特定功能的</strong> 代码段.</p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><ul>
<li>def关键字</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">传入参数</span>):</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br></pre></td></tr></table></figure></div>
<p>def关键字, 可以定义带有名称的函数.<br>传入参数和返回值不需要可以省略.</p>
<ul>
<li>lambda关键字(匿名函数)</li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">add</span>):</span><br><span class="line">    result = add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">func(<span class="keyword">lambda</span> x,y:x+y)</span><br></pre></td></tr></table></figure></div>

<p>函数体只能写一行</p>
<h3 id="函数的传入参数"><a href="#函数的传入参数" class="headerlink" title="函数的传入参数"></a>函数的传入参数</h3><p>作用是能让函数接收外部传入数据</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>): <span class="comment"># 多个参数用逗号隔开</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数说明文档</span></span><br><span class="line"><span class="string">    :param x: 形参x的说明</span></span><br><span class="line"><span class="string">    :param y: 形参y的说明</span></span><br><span class="line"><span class="string">    :return: 返回值的说明</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    result = x + y <span class="comment"># &lt;--形式参数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span>+<span class="subst">&#123;y&#125;</span>=<span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>函数定义中的参数为 <strong>形式参数</strong><br>函数调用中的参数为 <strong>实际参数</strong></p>
<p>传入的参数要与形式参数一一对应.</p>
<ul>
<li><strong>多个传入参数</strong></li>
</ul>
<p>根据使用方式的不同, 函数有4种常见的参数使用方式.</p>
<ol>
<li><p><strong>位置参数</strong>: 调用函数时根据函数定义的参数位置来传递参数.</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name,age,gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;名字<span class="subst">&#123;name&#125;</span>,年龄<span class="subst">&#123;age&#125;</span>,性别<span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&quot;TOM&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>关键字参数</strong>: 调用时用”键&#x3D;值”形式传递参数</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name,age,gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;名字<span class="subst">&#123;name&#125;</span>,年龄<span class="subst">&#123;age&#125;</span>,性别<span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">user_info(gender=<span class="string">&quot;男&quot;</span>,name=<span class="string">&quot;TOM&quot;</span>,age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure></div></li>
<li><p><strong>缺省参数</strong>: 也就是设置默认值</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name,age,gender=<span class="string">&quot;男&quot;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;名字<span class="subst">&#123;name&#125;</span>,年龄<span class="subst">&#123;age&#125;</span>,性别<span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&quot;TOM&quot;</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>不定长参数</strong>: 也叫可变参数, 用于不确定调用的时候会传递多少个参数.</p>
</li>
</ol>
<p>(1) 位置传递:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">*arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&quot;男&quot;</span>,<span class="string">&quot;TOM&quot;</span>,<span class="number">20</span>)</span><br></pre></td></tr></table></figure></div>
<p>传进的参数会被args变量收集, 成为一个元组.</p>
<p>(2) 关键字传递:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line"></span><br><span class="line">user_info(gender=<span class="string">&quot;男&quot;</span>,name=<span class="string">&quot;TOM&quot;</span>,age=<span class="number">20</span>)</span><br></pre></td></tr></table></figure></div>
<p>传进的参数会被kwargs变量收集, 成为一个”键&#x3D;值”的字典.</p>
<h4 id="函数作为参数传递"><a href="#函数作为参数传递" class="headerlink" title="函数作为参数传递"></a>函数作为参数传递</h4><p>传入函数的不仅可以是数据, 也可以是计算逻辑.  </p>
<p>传入数据:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></div>

<p>传入一个计算逻辑(函数):</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">add</span>):</span><br><span class="line">    result = add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x,y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></div>

<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>函数的返回值能在函数执行完毕后, 返回 <strong>给调用者</strong> 结果.</p>
<ul>
<li>注意: 函数体在遇到return后就结束了, 不会执行return后的代码.</li>
</ul>
<p>当函数没有使用return语句返回数据时, 会返回 <strong>字面量 None</strong>,   </p>
<blockquote>
<p>无返回值的函数, 返回的内容是: None<br>无返回值的函数, 返回的内容类型是: &lt;class ‘NoneType’&gt;</p>
</blockquote>
<p>表示空的, 没有意义.</p>
<p>在if判断中, None等同于False  </p>
<ul>
<li><strong>多个返回值</strong></li>
</ul>
<p>要使函数返回多个返回值, 可以用逗号分隔.</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_return</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"></span><br><span class="line">x,y,z = test_return()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;x&#125;</span>,<span class="subst">&#123;y&#125;</span>,<span class="subst">&#123;z&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>变量的作用域指的是变量的<strong>作用范围</strong>.<br>主要分为两类: <strong>局部变量</strong> 和 <strong>全局变量</strong></p>
<ol>
<li><strong>局部变量</strong></li>
</ol>
<p>定义在函数体内部的变量, 只在函数体内部生效  </p>
<p>能在函数体内部临时保存数据, 函数调用完后销毁</p>
<ol start="2">
<li><strong>全局变量</strong></li>
</ol>
<p>能在函数体内外都能生效的变量.</p>
<ol start="3">
<li><strong>global关键字</strong></li>
</ol>
<p>可以让函数内定义的局部变量转换为全局变量以修改.</p>
<h1 id="Python-数据容器"><a href="#Python-数据容器" class="headerlink" title="Python 数据容器"></a>Python 数据容器</h1><p>数据容器是能够存储多个元素的Python数据类型</p>
<p><strong>list [列表]</strong><br><strong>tuple (元组)</strong><br><strong>str “字符串”</strong><br><strong>set {集合}</strong><br><strong>dict(字典)</strong>  </p>
<p>它们各自有各自的特点</p>
<h2 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h2><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字面量</span></span><br><span class="line">[元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,元素<span class="number">4</span>,...]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义变量</span></span><br><span class="line">变量名称 = [元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>,元素<span class="number">4</span>,...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义空列表</span></span><br><span class="line">变量名称 = []</span><br><span class="line">变量名称 = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure></div>

<p>元素的数据类型没有任何限制, 甚至元素也可以是列表, 这样就定义了嵌套列表</p>
<h3 id="列表的下标索引"><a href="#列表的下标索引" class="headerlink" title="列表的下标索引"></a>列表的下标索引</h3><p>列表的每个元素, 都有编号称之为下标索引</p>
<p>从前向后看, 下标索引从 <strong>0 开始递增.</strong><br>从后向前看, 下标索引从 <strong>-1开始递减.</strong></p>
<p><code>列表名称[ 下标 ]</code>即可使用下标索引取出元素</p>
<h3 id="列表的方法"><a href="#列表的方法" class="headerlink" title="列表的方法"></a>列表的方法</h3><p>把一个函数封装到类当中, 这个函数就会被称作为 <strong>方法</strong></p>
<ul>
<li><p>查找某元素的下标<br><code>列表. index(要查找的元素)</code></p>
</li>
<li><p>修改特定下标索引的值<br><code>列表[下标] = 要修改的值</code></p>
</li>
<li><p>插入元素<br><code>列表.insert(下标, 插入的元素)</code></p>
</li>
<li><p>追加元素(到末尾)<br><code>列表.append(要插入的元素)</code><br>也可以批量追加元素:<br><code>列表.extend(其他数据容器)</code></p>
</li>
<li><p>删除元素(匹配下标)<br><code>del列表[下标]</code><br>也可以通过pop取出元素达到删除效果:<br><code>列表.pop(下标)</code><br>pop能得到取出的元素.</p>
</li>
<li><p>删除匹配(指定)的元素<br><code>列表.remove(元素)</code><br>只能删掉第一个匹配的元素.</p>
</li>
<li><p>清空<br><code>列表.clear()</code></p>
</li>
<li><p>统计指定元素在列表内的数量<br><code>列表.count(元素)</code></p>
</li>
<li><p>统计列表内总元素个数<br><code>len(列表)</code></p>
</li>
</ul>
<h3 id="列表的特点"><a href="#列表的特点" class="headerlink" title="列表的特点"></a>列表的特点</h3><ul>
<li>可以容纳 <strong>多个, 类型不同</strong> 的元素</li>
<li>元素是 <strong>有序存储</strong> 的</li>
<li>允许 <strong>增加删除</strong> 元素, 允许 <strong>重复数据</strong> 存在.</li>
</ul>
<h3 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h3><ol>
<li>while 循环</li>
</ol>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="built_in">len</span>(列表):</span><br><span class="line">    元素 = 列表[index]</span><br><span class="line">    对元素进行处理</span><br><span class="line">    index += <span class="number">1</span></span><br></pre></td></tr></table></figure></div>
<p>while循环更灵活</p>
<ol start="2">
<li>for 循环</li>
</ol>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 数据容器:</span><br><span class="line">    对临时变量进行处理</span><br></pre></td></tr></table></figure></div>
<p>for循环更简单</p>
<h2 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h2><p>定义完成后, 就不可修改. 其他特点与列表类似.</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义元组字面量</span></span><br><span class="line">(元素,元素,...,元素,)</span><br><span class="line"><span class="comment"># 定义元组变量</span></span><br><span class="line">变量名称 = (元素,元素,...,元素,)</span><br><span class="line"><span class="comment"># 定义空元组</span></span><br><span class="line">变量名称 = () <span class="comment"># 方式1</span></span><br><span class="line">变量名称 = <span class="built_in">tuple</span>() <span class="comment">#方式2</span></span><br></pre></td></tr></table></figure></div>

<p>虽然元组元素不能修改, 但是元组嵌套中的列表能修改.</p>
<h3 id="元组的方法"><a href="#元组的方法" class="headerlink" title="元组的方法"></a>元组的方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>元组.index(&quot;元素&quot;)</code></td>
<td>查找某个数据, 如果数据存在返回对应的下标, 否则报错</td>
</tr>
<tr>
<td><code>元组.count(&quot;元素&quot;)</code></td>
<td>统计某个数据在当前元组出现的次数</td>
</tr>
<tr>
<td><code>len(元组)</code></td>
<td>统计元组内的元素个数</td>
</tr>
</tbody></table>
<h2 id="字符串-str"><a href="#字符串-str" class="headerlink" title="字符串(str)"></a>字符串(str)</h2><p>是字符的容器, 一个字符串可以存放任意数量的字符.</p>
<p>字符串同元组一样, 是 <strong>无法修改</strong> 的数据容器.</p>
<h3 id="字符串的方法"><a href="#字符串的方法" class="headerlink" title="字符串的方法"></a>字符串的方法</h3><ul>
<li><p>字符串的替换<br><code>字符串.replace(字符串1, 字符串2)</code><br>能将老字符串替换成一个新的字符串</p>
</li>
<li><p>字符串分割<br><code>字符串.split(分隔符字符)</code><br>字符串本身不变, 得到一个新的列表对象</p>
</li>
<li><p>字符串规整操作<br><code>字符串.strip()</code> 去掉前后空格<br><code>字符串.strip(字符串)</code> 去掉前后指定字符串</p>
</li>
<li><p>统计字符串某个字符串的出现次数<br><code>字符串.count(&quot;字符串&quot;)</code></p>
</li>
<li><p>统计字符串长度<br><code>len(字符串)</code></p>
</li>
</ul>
<h2 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h2><p>内容连续, 有序, 可使用下标索引的一类数据容器.  </p>
<p>列表, 元组, 字符串, 均可视为序列.</p>
<h3 id="序列的常用操作"><a href="#序列的常用操作" class="headerlink" title="序列的常用操作"></a>序列的常用操作</h3><ul>
<li>切片<br><code>序列[起始下标:结束下标:步长]</code><br>从一个序列中, 取出一个子序列, 会得到一个新字符串<br>步长表示取元素的间隔</li>
</ul>
<p>起始下标不写 表示从头<br>结束下标不写 表示到尾<br>步长为负 表示倒序</p>
<h2 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h2><p>不支持元素重复(自带去重功能), 并且内容无序.</p>
<p>内容无序, 导致不支持下标索引访问.</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义集合字面量</span></span><br><span class="line">&#123;元素, 元素, ... , 元素&#125;</span><br><span class="line"><span class="comment"># 定义集合变量</span></span><br><span class="line">变量名称 = &#123;元素, 元素, ... , 元素&#125;</span><br><span class="line"><span class="comment"># 定义空集合</span></span><br><span class="line">变量名称 = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure></div>

<h3 id="集合的常用操作"><a href="#集合的常用操作" class="headerlink" title="集合的常用操作"></a>集合的常用操作</h3><ul>
<li><p>添加新元素<br><code>集合.add(元素)</code><br>将指定元素, 添加到集合内.<br>修改集合本身, 添加了新元素.</p>
</li>
<li><p>移除元素<br><code>集合.remove</code><br>将指定元素, 从集合中移除.<br>集合本身被修改, 移除了元素.</p>
</li>
<li><p>从集合中随机取出元素<br><code>集合.pop</code><br>由于集合无序, 无法指定取出. 因此达到随机取出的效果.<br>集合本身被修改, 元素被移除.</p>
</li>
<li><p>清空集合<br><code>集合.clear</code></p>
</li>
<li><p>取出2个集合的差集<br><code>集合1.difference(集合2)</code><br>原集合1,2不变, 得到一个新集合.</p>
</li>
<li><p>消除2个集合的差集<br><code>集合1.difference_updata(集合2)</code><br>集合1被修改, 集合2不变.</p>
</li>
<li><p>2个集合合并<br><code>集合1.union(集合2)</code><br>原集合1,2不变, 得到一个新集合.</p>
</li>
<li><p>统计元素个数<br><code>len(集合)</code></p>
</li>
</ul>
<h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><p>由于无序, 因此不支持while循环.  </p>
<p>但支持for循环遍历:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> 集合:</span><br><span class="line">    要对element的操作</span><br></pre></td></tr></table></figure></div>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义字典字面量</span></span><br><span class="line">&#123;key:value,key:value,...,key:value&#125;</span><br><span class="line"><span class="comment"># 定义字典变量</span></span><br><span class="line">my_dict = &#123;key:value,key:value,...,key:value&#125;</span><br><span class="line"><span class="comment"># 定义空字典</span></span><br><span class="line">my_dict = &#123;&#125;</span><br><span class="line">my_dict = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure></div>

<p>可以通过Key, 取到对应的Value.<br>存储的元素 Key:value 键值对.<br>不支持下标索引.</p>
<blockquote>
<p>字典嵌套:</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th>语文</th>
<th>数学</th>
</tr>
</thead>
<tbody><tr>
<td>张三</td>
<td>95</td>
<td>92</td>
</tr>
<tr>
<td>李四</td>
<td>94</td>
<td>98</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">  socre_dict = &#123;</span><br><span class="line">   <span class="string">&quot;张三&quot;</span>:&#123;</span><br><span class="line">          <span class="string">&quot;语文&quot;</span>:<span class="number">95</span></span><br><span class="line">          <span class="string">&quot;数学&quot;</span>:<span class="number">92</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</blockquote>
<h3 id="字典的常用操作"><a href="#字典的常用操作" class="headerlink" title="字典的常用操作"></a>字典的常用操作</h3><ul>
<li><p>新增&#x2F;更新元素<br><code>字典[Key] = Value</code><br>对已经存在的Key执行, 就会更新Value值.</p>
</li>
<li><p>删除元素<br><code>字典.pop(Key)</code>  </p>
</li>
<li><p>清空元素<br><code>字典.clear()</code></p>
</li>
<li><p>获取全部的key<br><code>字典.keys()</code></p>
</li>
</ul>
<p>遍历字典  </p>
<p>第一种方法:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">keys = my_dict.keys()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">    要执行的操作</span><br></pre></td></tr></table></figure></div>

<p>第二种方法:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> my_dict:</span><br><span class="line">    要执行的操作</span><br></pre></td></tr></table></figure></div>

<ul>
<li>统计字典内元素数量:<br><code>len(字典)</code></li>
</ul>
<h2 id="数据容器总结"><a href="#数据容器总结" class="headerlink" title="数据容器总结"></a>数据容器总结</h2><p>数据容器可以从以下视角进行简单分类:  </p>
<ul>
<li><p><strong>是否支持下标索引</strong><br>序列类型(支持): 列表, 元组, 字符串<br>非序列类型(不支持):集合, 字典</p>
</li>
<li><p><strong>是否支持重复元素</strong><br>序列类型(支持): 列表, 元组, 字符串<br>非序列类型(不支持):集合, 字典</p>
</li>
<li><p><strong>是否可以修改</strong><br>支持: 列表, 集合, 字典<br>不支持: 元组, 字符串</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>列表</th>
<th>元组</th>
<th>字符串</th>
<th>集合</th>
<th>字典</th>
</tr>
</thead>
<tbody><tr>
<td>元素类型</td>
<td>任意</td>
<td>任意</td>
<td>仅字符</td>
<td>任意</td>
<td>key:除字典外任意类型 <br> value:任意类型</td>
</tr>
<tr>
<td>下标索引</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>重复元素</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>不支持</td>
<td>key不支持</td>
</tr>
<tr>
<td>可修改性</td>
<td>-</td>
<td>不支持</td>
<td>不支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>数据有序</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>无序</td>
<td>无序</td>
</tr>
<tr>
<td>使用场景</td>
<td>可修改的, <br>带重复的数据记录</td>
<td>不可修改, <br>带重复的数据记录</td>
<td>一串字符的记录</td>
<td>去重的数据记录</td>
<td>以Key检索Value的记录</td>
</tr>
</tbody></table>
<h1 id="Python-文件操作"><a href="#Python-文件操作" class="headerlink" title="Python 文件操作"></a>Python 文件操作</h1><p>文件操作步骤分为: 打开, 读写, 关闭</p>
<h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><p><code>open(name,mode,encoding)</code><br>name: 文件的名称&#x2F;路径<br>mode: 有只读(r), 写入(w), 追加(a)等.<br>encoding: 编码格式(推荐使用UTF-8)  </p>
<h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><ol>
<li><p>read()方法<br><code>文件对象.read(num)</code><br>num表示要从文件中读取的数据的长度(单位是字节), 如果省略, 就会读取文件中所有的数据.</p>
</li>
<li><p>readlines()方法<br><code>文件对象.readlines()</code><br>readlines可以按照行的方式把整个文件一次性读取, 返回一个列表, 其中每一行的数据为一个元素.</p>
</li>
<li><p>readline()方法<br><code>文件对象.readline()</code><br>一次读取一行内容</p>
</li>
</ol>
<h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p><code>文件对象.write(&quot;写入内容&quot;)</code></p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f.write(hello world)</span><br><span class="line"></span><br><span class="line">f.flush()</span><br></pre></td></tr></table></figure></div>
<p>为避免频繁操作硬盘而导致效率低, 内容会先积攒到程序的内存中(缓冲区), 当调用flush时, 内容才会真正写进文件.<br>.close()方法也会自带.flush()方法  </p>
<p>w模式下写入时, 文件不存在, 会创建新文件. 文件存在, 会清空原有内容.</p>
<h3 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h3><p>方法同w, 有:</p>
<p>wirte(), 写入内容<br>flush(), 刷新内容到硬盘</p>
<p>a同w, 文件不存在, 会创建新文件. 不同的是:文件存在, 会在原有内容后继续写入.</p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><ol>
<li><p><code>文件对象.close()</code><br>解除文件占用</p>
</li>
<li><p><code>with open() as 文件对象</code><br>自动关闭文件</p>
</li>
</ol>
<h1 id="Python-异常"><a href="#Python-异常" class="headerlink" title="Python 异常"></a>Python 异常</h1><h3 id="异常处理-捕获异常"><a href="#异常处理-捕获异常" class="headerlink" title="异常处理&#x2F;捕获异常"></a>异常处理&#x2F;捕获异常</h3><p>基本语法:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能发生错误的代码</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    如果出现异常要执行的代码</span><br><span class="line"></span><br><span class="line"><span class="comment"># [ ]中括号代表代码可选</span></span><br><span class="line">[<span class="keyword">else</span>:]</span><br><span class="line">    没有异常时执行的代码</span><br><span class="line"></span><br><span class="line">[<span class="keyword">finally</span>:]</span><br><span class="line">    无论是否异常, 都会执行的代码</span><br></pre></td></tr></table></figure></div>

<p>若要捕获指定的异常:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">except</span> 错误类型 <span class="keyword">as</span> e(别名):</span><br><span class="line">    出现异常要执行的操作</span><br></pre></td></tr></table></figure></div>

<p>若要捕获多个异常, 可以通过元组书写:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">except</span> (错误类型<span class="number">1</span>,错误类型<span class="number">2</span>) <span class="keyword">as</span> e:</span><br><span class="line">    出现异常要执行的操作</span><br></pre></td></tr></table></figure></div>

<p>捕获所有异常:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    出现异常要执行的操作</span><br></pre></td></tr></table></figure></div>

<p>异常具有传递性.</p>
<h1 id="Python-模块"><a href="#Python-模块" class="headerlink" title="Python 模块"></a>Python 模块</h1><p>是一个Python文件(以.py结尾), 里面有类, 函数, 变量等. 我们可以导入模块使用.</p>
<p>导入方式:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">from</span> 模块名] <span class="keyword">import</span> [模块|类|变量|函数|*][<span class="keyword">as</span> 别名]</span><br><span class="line"></span><br><span class="line"><span class="comment">#import会导入整个模块, 通过 . 能使用其中所有功能</span></span><br><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span>, 模块名<span class="number">2</span></span><br><span class="line">模块名.功能名()</span><br><span class="line"></span><br><span class="line"><span class="comment">#form import 能具体导入某个功能</span></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 功能名</span><br><span class="line">功能名()</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 * 导入模块的全部功能, 只是写法不同而已. </span></span><br><span class="line">form 模块名 <span class="keyword">import</span> *</span><br><span class="line">功能名()</span><br></pre></td></tr></table></figure></div>
<p>如果使用这种方式导入, 模块文件含有<code>__all__</code>变量, 就只会导入列表all中记录的元素:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [函数<span class="number">1</span>,函数<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">函数<span class="number">1</span></span><br><span class="line"></span><br><span class="line">函数<span class="number">2</span></span><br><span class="line"></span><br><span class="line">函数<span class="number">3</span></span><br><span class="line"><span class="comment"># 只会导入 1 和 2</span></span><br></pre></td></tr></table></figure></div>
<h3 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h3><p>新建一个<code>my_module1.py</code>的文件,内容如下:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br></pre></td></tr></table></figure></div>

<p>在另一个文件中,使用这个Python模块:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> my_module1</span><br><span class="line"></span><br><span class="line">my_module1.test(<span class="number">10</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure></div>

<p>当导入两个同名的模块时, 后调用的会覆盖先调用的.</p>
<p>如果想让模块调用时不执行, 而在测试时执行, 可以添加:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">导入模块要执行的代码</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    导入模块不会执行的代码</span><br></pre></td></tr></table></figure></div>

<h3 id="Python-包"><a href="#Python-包" class="headerlink" title="Python 包"></a>Python 包</h3><p>本质是一个包含 <code>__init__.py</code> 文件的文件夹, 能存放模块.</p>
<p>没有 <code>__init__.py</code> ,就不是包.</p>
<p>在Python程序的生态中, 有许多第三方包,例如: </p>
<ul>
<li>科学计算的 numpu 包</li>
<li>数据分析的 pandas 包</li>
<li>大数据计算的 pyspark apache-flink 包</li>
<li>图形可视化的 matplotlib pyrcharts</li>
<li>人工智能的 tensorflow</li>
<li>等等</li>
</ul>
<h4 id="安装第三方包"><a href="#安装第三方包" class="headerlink" title="安装第三方包"></a>安装第三方包</h4><p>使用Python内置的pip程序, 在命令提示符中输入:</p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install 包名称</span><br></pre></td></tr></table></figure></div>
<p>即可通过网络安装包.</p>
<h4 id="优化下载的方法"><a href="#优化下载的方法" class="headerlink" title="优化下载的方法"></a>优化下载的方法</h4><p>让其链接国内的网站进行下载</p>
<div class="code-container" data-rel="Cmd"><figure class="iseeu highlight cmd"><table><tr><td class="code"><pre><span class="line">pip instal -i https://pypi.tuna.tsinghua.edu.cn/simple 包名称</span><br></pre></td></tr></table></figure></div>

<p><a class="link"   href="https://pypi.tuna.tsinghua.edu.cn/simple" >https://pypi.tuna.tsinghua.edu.cn/simple<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> 是清华大学提供的一个网站, 可供pip程序下载第三方包.</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="数据的组织"><a href="#数据的组织" class="headerlink" title="数据的组织"></a>数据的组织</h3><p>生活中, 可以设计一个表格, 将数据整齐地统计出来, 在程序中也有相同的思路.</p>
<ol>
<li>在程序中设计表格, 称之为: <strong>设计类(class)</strong></li>
<li>在程序中打印生产表格, 称之为: <strong>创建对象</strong></li>
<li>在程序中填写表格, 称之为: <strong>对象属性赋值</strong></li>
</ol>
<h3 id="类的定义和使用"><a href="#类的定义和使用" class="headerlink" title="类的定义和使用"></a>类的定义和使用</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># classs是关键字, 表示要定义类了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">类名称</span>:</span><br><span class="line">    <span class="comment"># 类的属性: 定义在类中的变量(成员变量)</span></span><br><span class="line">    name = <span class="literal">None</span> </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类的行为: 定义在类中的函数(成员方法)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello world!&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<p>self关键字是成员方法定义时, 必须填写.<br>它用来表示类对象自身的意思.<br>在方法内部, 想要访问类的成员变量, 必须使用self.</p>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>基于类创建对象的语法: <code>对象名 = 类名称()</code>  </p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:</span><br><span class="line">    name = <span class="literal">None</span></span><br><span class="line">    age = <span class="literal">None</span></span><br><span class="line">    fur = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">wolf1 = Wolf()</span><br><span class="line">wolf1.name = <span class="string">&quot;沃里克&quot;</span></span><br><span class="line">wolf1.age = <span class="number">31</span></span><br><span class="line">wolf1.fur = <span class="string">&quot;gray&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(wolf1.name)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>Python类也可以使用:  <code>__init__</code> (方法)构造方法  </p>
<p>能使创建类对象 (构造类) 的时候, 会自动执行.<br>在创建类对象 (构造类) 的时候, 将传入参数自动传递给 <code>__init__</code> 方法使用</p>
<p>例如:</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, tel</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">        <span class="variable language_">self</span>.fur = fur</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;此构造方法会自动执行&quot;</span>)</span><br><span class="line"></span><br><span class="line">Wolf1 = Wolf(<span class="string">&quot;沃里克&quot;</span>, <span class="number">31</span>, <span class="string">&quot;gray&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(wolf1.name)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<h3 id="常用的类内置方法"><a href="#常用的类内置方法" class="headerlink" title="常用的类内置方法"></a>常用的类内置方法</h3><p>除了 <code>__init__</code> 构造方法外, Python类中还有其他的类内置方法.<br>这些内置的类方法, 各有各自特殊的功能, 这些内置方法我们称之为: <strong>魔术方法</strong></p>
<h4 id="str-字符串方法"><a href="#str-字符串方法" class="headerlink" title="__str__ 字符串方法"></a><code>__str__</code> 字符串方法</h4><p>当类对象需要被转换为字符串之时: </p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">wolf1 = Wolf(<span class="string">&quot;沃里克&quot;</span>, gray)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(wolf1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(wolf1)) <span class="comment">#输出地址值, 没什么实际作用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>会输出内存地址.<br>我们可以通过 <code>__str__</code> 方法, 控制类转换为指定的字符串</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;有一只名叫<span class="subst">&#123;self.name&#125;</span>的<span class="subst">&#123;self.fur&#125;</span>毛狼!&quot;</span></span><br><span class="line"></span><br><span class="line">wolf1 = Wolf(<span class="string">&quot;沃里克&quot;</span>, gray)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(wolf1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(wolf1)) <span class="comment">#会按照__str__设定的输出.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="lt-小于大于符号比较方法"><a href="#lt-小于大于符号比较方法" class="headerlink" title="__lt__小于大于符号比较方法"></a><code>__lt__</code>小于大于符号比较方法</h4><p>无法直接对两个对象进行比较.<br>但使用 <code>__lt__</code> 方法, 可以同时完成 大于和小于 的比较.</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wolf</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.age &lt; other.age</span><br><span class="line"></span><br><span class="line">wolf1 = Wolf(<span class="string">&quot;沃里克&quot;</span>, <span class="number">31</span>)</span><br><span class="line">wolf2 = Wolf(<span class="string">&quot;布莱泽&quot;</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(wolf1 &lt; wolf2) <span class="comment">#返回 false</span></span><br><span class="line"><span class="built_in">print</span>(wolf1 &gt; wolf2) <span class="comment">#返回 true </span></span><br></pre></td></tr></table></figure></div>

<p>而小于等于大于等于可以使用: <code>__le__</code><br>同理, 判断两个对象是否相等: <code>__eq__</code><br>用法都同 <code>__lt__</code></p>
<h1 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h1><p>面向对象编程, 是许多编程语言都支持的一种编程思想.<br>简单理解就是: 基于模板 (类) 去创建实体对象 (对象), 使对象完成功能开发.</p>
<p>面向对象包含 3 大主要特性:</p>
<ol>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ol>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装表示将现实世界事物的:</p>
<ul>
<li>属性</li>
<li>行为</li>
</ul>
<p>封装到类中, 称为:</p>
<ul>
<li>成员变量</li>
<li>成员方法</li>
</ul>
<p>从而完成程序对现实世界事物的描述</p>
<h3 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h3><p>有的属性呵行为不公开, 我没将其称之为私有成员形式, 定义私有成员的方式非常简单, 只要:</p>
<ul>
<li>私有成员变量: 变量名以__开头(2个下划线)</li>
<li>私有成员方法: 方法名以__开头(2个下划线)</li>
</ul>
<p>私有成员只能被内部类中的其他成员访问.</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><blockquote>
<p>wow! 基础学完力!<br>不过速通疏漏还挺多, 继续加油吧!</p>
</blockquote>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>入门基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2024/06/23/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>正则表达式是用特殊字符组合描述文本规则的强大工具.<br>在 Java 中，正则表达式是通过 <code>str.matches(正则表达式规则)</code> 来实现的。</p>
<p>以下是核心语法和案例：</p>
<h3 id="中括号表达式"><a href="#中括号表达式" class="headerlink" title="[] 中括号表达式"></a><code>[]</code> 中括号表达式</h3><p>匹配中括号中的任意一个字符.</p>
<ul>
<li><code>[a-z]</code>  表示字母 a 到 z 的范围</li>
<li><code>[^abc]</code>  表示排除 a&#x2F;b&#x2F;c 的任意字符</li>
<li><code>^</code>  在中括号内表示”排除”</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配单个元音字母</span></span><br><span class="line">System.out.println(<span class="string">&quot;a&quot;</span>.matches(<span class="string">&quot;[aeiou]&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配非数字字符</span></span><br><span class="line">System.out.println(<span class="string">&quot;k&quot;</span>.matches(<span class="string">&quot;[^0-9]&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配 1 个大写字母或数字</span></span><br><span class="line">System.out.println(<span class="string">&quot;A&quot;</span>.matches(<span class="string">&quot;[A-Z0-9]&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="转义字符与元字符"><a href="#转义字符与元字符" class="headerlink" title="\ 转义字符与元字符"></a><code>\</code> 转义字符与元字符</h3><p>转义字符将其后紧跟的字符标记为有特殊含义的<strong>元字符</strong>（Metacharacter）</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>作用</th>
<th>Java 正则写法</th>
</tr>
</thead>
<tbody><tr>
<td><code>.</code></td>
<td>匹配任意字符（除换行符）</td>
<td><code>\\.</code></td>
</tr>
<tr>
<td><code>\d</code></td>
<td>匹配数字</td>
<td><code>\\d</code></td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配非数字</td>
<td><code>\\D</code></td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配字母、数字、下划线</td>
<td><code>\\w</code></td>
</tr>
<tr>
<td><code>\W</code></td>
<td>匹配非单词字符</td>
<td><code>\\W</code></td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配空格、制表符等</td>
<td><code>\\s</code></td>
</tr>
<tr>
<td><code>\b</code></td>
<td>匹配单词边界</td>
<td><code>\\b</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查字符串是否为 3 位数字</span></span><br><span class="line">System.out.println(<span class="string">&quot;123&quot;</span>.matches(<span class="string">&quot;\\d&#123;3&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 判断是否包含非数字字符</span></span><br><span class="line">System.out.println(<span class="string">&quot;a1&quot;</span>.matches(<span class="string">&quot;.*\\D.*&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配以 &quot;cat&quot; 结尾的单词（需用 \\b 表示边界）</span></span><br><span class="line">System.out.println(<span class="string">&quot;bobcat&quot;</span>.matches(<span class="string">&quot;.*\\bcat&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><h4 id="1-模糊限定符"><a href="#1-模糊限定符" class="headerlink" title="1. 模糊限定符"></a>1. 模糊限定符</h4><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>匹配 0 次或多次</td>
<td><code>a*</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>匹配 1 次或多次</td>
<td><code>\\d+</code></td>
</tr>
<tr>
<td><code>?</code></td>
<td>匹配 0 次或 1 次</td>
<td><code>xyz?</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配以 a 开头，后跟 0 或多个 b 的字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;abbb&quot;</span>.matches(<span class="string">&quot;ab\*&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配至少 1 位数字</span></span><br><span class="line">System.out.println(<span class="string">&quot;7&quot;</span>.matches(<span class="string">&quot;\\d+&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配 &quot;http&quot; 或 &quot;https&quot;</span></span><br><span class="line">System.out.println(<span class="string">&quot;https&quot;</span>.matches(<span class="string">&quot;https?&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-精确限定符"><a href="#2-精确限定符" class="headerlink" title="2. 精确限定符"></a>2. 精确限定符</h4><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;n&#125;</code></td>
<td>匹配恰好 n 次</td>
<td><code>a&#123;3&#125;</code></td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td>匹配至少 n 次</td>
<td><code>\\d&#123;2,&#125;</code></td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td>匹配至少 n 次，至多 m 次</td>
<td><code>a&#123;2,4&#125;</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配 3 位区号 + 8 位数字的电话号码</span></span><br><span class="line">System.out.println(<span class="string">&quot;010-12345678&quot;</span>.matches(<span class="string">&quot;\\d&#123;3&#125;-\\d&#123;8&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配 2~4 个连续字母 a</span></span><br><span class="line">System.out.println(<span class="string">&quot;aaa&quot;</span>.matches(<span class="string">&quot;a&#123;2,4&#125;&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 匹配至少 5 位数字</span></span><br><span class="line">System.out.println(<span class="string">&quot;12345&quot;</span>.matches(<span class="string">&quot;\\d&#123;5,&#125;&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><ol>
<li>邮箱格式验证</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;[a-zA-Z0-9]+@[a-z]+\\.[a-z]&#123;2,3&#125;&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;test@mail.com&quot;</span>.matches(regex)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>日期格式验证（YYYY-MM-DD）</li>
</ol>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;\\d&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12]\\d|3[01])&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;2023-10-05&quot;</span>.matches(regex)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>计算机通识</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法(c语言)</title>
    <url>/2023/09/17/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E7%A1%80-c%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<p>上课老师真的好无聊,还是上b站自学吧,听说这门课还挺难学习的?<br>笔记源自于这套课程:<br><a class="link"   href="https://www.bilibili.com/video/BV1Fv411H7jH/?share_source=copy_web&vd_source=663cc380bfc10fe6df62cd0cb979820d" >C语言《数据结构和算法》<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h1 id="第零章-C语言基础"><a href="#第零章-C语言基础" class="headerlink" title="第零章 C语言基础"></a>第零章 C语言基础</h1><blockquote>
<p>补一补c语言有关指针和结构体的基础知识…<br>视频来源: <a class="link"   href="https://www.bilibili.com/video/BV1kV4y1C7z6/?spm_id_from=333.337.search-card.all.click&vd_source=b19220b8f372f3a81aa8463fde694a63" >数据结构所需要的c语言基础<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
</blockquote>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>类似于 定义int能存放整数, 定义char能存放字符;<br>指针能存放地址. </p>
<p>地址 可以类比理解成 寝室号.<br>“ * “ 可以类比为 寝室钥匙.</p>
<p>例如: “ *a “ 可以访问到a的值.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">12</span>;<span class="comment">//定义一个整型变量</span></span><br><span class="line"><span class="type">int</span>* p;<span class="comment">//定义一个int类型的指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* p = &amp;x;<span class="comment">//将x的地址值赋给指针变量</span></span><br></pre></td></tr></table></figure></div>

<p>知道地址后如何访问地址存的变量值?<br>有以下两种方法:</p>
<ol>
<li>“ * “ + 地址</li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span>* q = &amp;y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*q);<span class="comment">//通过地址访问y的值,然后打印y的值</span></span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>地址 + [  ]</li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>* p = a;<span class="comment">//将数组a第一个数的地址值给指针p</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">0</span>])<span class="comment">//通过地址值访问数组a[2]的值</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">2</span>]);<span class="comment">//访问数组a[2]的值</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>也可以试试第一种方法:</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(p+<span class="number">2</span>));</span><br></pre></td></tr></table></figure></div>

<ul>
<li>还有这几种方式,也能输出相同的结果:</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;%d&quot;</span>, a[<span class="number">0</span>]);<span class="comment">//知道a的地址(首地址),偏移[0]个位置的值.</span></span><br><span class="line">print(<span class="string">&quot;%d&quot;</span>, a[<span class="number">2</span>]);<span class="comment">//知道a的地址(首地址),偏移[2]个位置的值.</span></span><br><span class="line">print(<span class="string">&quot;%d&quot;</span>, *a);<span class="comment">//知道a的地址(首地址),访问a的值.</span></span><br><span class="line">print(<span class="string">&quot;%d&quot;</span>, *(a+<span class="number">2</span>));<span class="comment">//知道a的地址(首地址),访问(a+2)的值.</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>同理的<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&quot;%d&quot;</span>,(a+<span class="number">1</span>)[<span class="number">0</span>]);<span class="comment">//知道首地址(a+1),偏移[0]个位置的值.</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>即a[1]的值</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>例如管理学生信息. </p>
<p>若需求存储十个学生的: 姓名 学号 分数.<br>如果没有使用结构体:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> score[<span class="number">10</span>];</span><br><span class="line"><span class="type">float</span> sno[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div>

<p>不能以学生为单位查看,较为凌乱.</p>
<p>试一试结构体定义:</p>
<ul>
<li>定义方式一</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> son[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> score[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若要访问第一个学生的学号:</span></span><br><span class="line">s[<span class="number">0</span>].son;</span><br><span class="line"><span class="comment">//同理,要访问第四个学生的成绩:</span></span><br><span class="line">s[<span class="number">4</span>].score;</span><br></pre></td></tr></table></figure></div>


<ul>
<li>定义方式二(更常用)</li>
</ul>
<blockquote>
<p>typedef 约等于重命名<br>例如: typedef int a, 就是把int重新改名为a.<br>即: int x; 等价于 a x;  </p>
</blockquote>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> son[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">float</span> score[<span class="number">3</span>];</span><br><span class="line">&#125; stu;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>同理,此处是将 定义一中的 “struct student{…}” 重命名成 “stu”.</p>
</blockquote>
<p>尝试理解以下结构体定义:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; LNode,* Linklist;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>逗号相当于分隔符,类似于: int a,b; 是int a; int b;两条语句.</p>
<p>因此可以这样拆分出两条语句:</p>
<blockquote>
<p>typedef struct LNode{…} LNode:<br>将”struct LNode{…}”重命名为 LNode.</p>
</blockquote>
<blockquote>
<p>typedef struct LNode* linklist:<br>将”struct LNode”重命名为 * linklist.</p>
</blockquote>
<p>不过用逗号像这样链接容易造成误解, 大家一般不这样写去为难自己.</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Lnode s;<span class="comment">//创造一个LNode类型的空间叫做s.</span></span><br><span class="line"></span><br><span class="line">Linklist p = &amp;s;<span class="comment">//取这个s空间的地址给p空间存放.</span></span><br></pre></td></tr></table></figure></div>


<pre class="mermaid">graph LR;

A1[data1]
B1[next1]
A2[data2]
B2[next2]

subgraph LNode1: s
A1---B1
end

subgraph LNode2
B1--指针-->A2---B2
end</pre>


  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>的异同</p>

    </div>
    <div class="notel-content">
      <ul>
<li>#define 是一个预处理器指令，它在编译之前就对代码进行了文本替换;</li>
</ul>
<p>typedef 是一个关键字，它在编译时创建了一个新的类型别名。</p>
<ul>
<li>#define 可以用于定义常量、变量、函数或者代码片段的宏。</li>
</ul>
<p>typedef 可以用于定义结构体、枚举、联合或者指针等复杂的类型的别名。</p>
<ul>
<li>#define 的作用域是从定义处到文件末尾，除非用 #undef 取消。</li>
</ul>
<p>typedef 的作用域是从定义处到所在的代码块末尾。</p>

    </div>
  </div>



<h3 id="结构体指针运算符"><a href="#结构体指针运算符" class="headerlink" title="结构体指针运算符"></a>结构体指针运算符</h3><p><code>-&gt;</code> 是一个结构体指针运算符，它用于通过结构体指针访问结构体的成员。<br>它的一般形式是：</p>
<blockquote>
<p><strong>结构体指针-&gt;成员名</strong></p>
</blockquote>
<p>例如，如果 L 是一个指向 SqList 类型的结构体的指针，那么 L-&gt;length 就表示访问该结构体的 length 成员，也就是线性表的当前长度。<br>可以把 -&gt; 理解为先解引用指针，再用 . 访问成员，即：</p>
<p>L-&gt;length 等价于 (*L).length</p>
<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><blockquote>
<p>不得不说我们老师讲的是真不行,说的话总是有很多完全没必要的句子,得不到她要说的重点…<br>还有就是数据结构真的好难好抽象!!</p>
</blockquote>
<h3 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h3><ol>
<li><p>数据: 所有能输入到计算机中去能用来描述客观事物的符号</p>
</li>
<li><p>数据元素: <strong>数据的基本单位</strong>, 也称为 结点 或 记录</p>
</li>
<li><p>数据项: <strong>数据最小单位</strong>, 也称为 域</p>
</li>
<li><p>数据对象: 是性质相同的数据<strong>元素的集合</strong>, 是数据的一个子级</p>
</li>
<li><p>数据结构: 是相互之间存在一种或多种特定关系的数据元素的集合</p>
</li>
</ol>
<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><blockquote>
<p><strong>程序设计 &#x3D; 数据结构 + 算法</strong>  </p>
</blockquote>
<p>就是数据与元素的<strong>关系集合</strong></p>
<hr>
<p>传统上,数据结构分为<strong>逻辑结构</strong>和<strong>存储(物理)结构</strong>。   </p>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>是数据元素间抽象化的相互关系, 与数据的存储无关, 独立于计算机.    </p>
<p>逻辑结构又分为:  </p>
<ul>
<li>集合</li>
<li>线性结构 (一对一)</li>
<li>树形结构 (一对多)</li>
<li>图形结构 (多对多)</li>
</ul>
<h3 id="存储-物理-结构"><a href="#存储-物理-结构" class="headerlink" title="存储(物理)结构"></a>存储(物理)结构</h3><ul>
<li>顺序存储</li>
<li>链式存储</li>
<li>索引存储</li>
<li>散列存储</li>
</ul>
<h2 id="算法的基本特征"><a href="#算法的基本特征" class="headerlink" title="算法的基本特征"></a>算法的基本特征</h2><h3 id="五个重要特性"><a href="#五个重要特性" class="headerlink" title="五个重要特性"></a>五个重要特性</h3><ul>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
<li>0个或多个输入</li>
<li>一个或多个输出</li>
</ul>
<h3 id="评价优劣的标准"><a href="#评价优劣的标准" class="headerlink" title="评价优劣的标准"></a>评价优劣的标准</h3><ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效性</li>
<li>存储量低</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>语句频度: 一条语句的重复执行次数.</p>
<p>算法的执行时间 &#x3D;&#x3D; 该算法中所有语句的频度之和.</p>
<blockquote>
<p>$T(n) &#x3D; O(f(n))$ </p>
</blockquote>
<p>例如:</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>( j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">        c[i][j]=a[i][j]+b[i][j]</span><br></pre></td></tr></table></figure></div>

<p>是for循环的嵌套, 每个for循环的语句频度为n.<br>因此, 整体为n*n</p>
<p>即:   $T(n) &#x3D; O(n^2)$ </p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>算法所需存储空间的度量, 记作</p>
<blockquote>
<p>$S(n) &#x3D; O(f(n))$</p>
</blockquote>
<p>通常,求”复杂度”是指时间复杂度</p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><ul>
<li>逻辑结构: 一对一</li>
<li>存储结构: 顺序存储(顺序表) 链式存储(链表)</li>
</ul>
<h3 id="线性表的顺序存储-顺序表"><a href="#线性表的顺序存储-顺序表" class="headerlink" title="线性表的顺序存储 (顺序表)"></a>线性表的顺序存储 (顺序表)</h3><p>会预先分配存储空间, 可能会导致空间闲置或溢出现象.<br>不用为表示结点的逻辑关系而增加额外的存储开销, 存储密度等于1.  </p>
<p>随机存取元素, 时间复杂度为 O(1)<br>插入删除时平均移动约表中一半元素, 时间复杂度为 0(n)</p>
<p>适用于: </p>
<ul>
<li>表长变化不大, 且能事先确定变化的范围.</li>
<li>很少进行插入或删除操作, 经常按元素序号访问数据元素.</li>
</ul>
<h5 id="定义线性表的存储结构"><a href="#定义线性表的存储结构" class="headerlink" title="定义线性表的存储结构"></a>定义线性表的存储结构</h5><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100 <span class="comment">//线性表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType; <span class="comment">//假设线性表的元素类型为整型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType data[MAXSIZE]; <span class="comment">//用数组存储元素</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">//线性表的当前长度</span></span><br><span class="line">&#125; SqList; <span class="comment">//顺序表类型</span></span><br></pre></td></tr></table></figure></div>

<h3 id="线性表的链式存储-链表"><a href="#线性表的链式存储-链表" class="headerlink" title="线性表的链式存储 (链表)"></a>线性表的链式存储 (链表)</h3><p>存储空间动态分配, 不会出现闲置或溢出的现象.<br>需要借助指针来体现元素间的逻辑关系, 存储密度小于1.</p>
<p>顺序存取元素, 时间复杂度为 O(n)<br>插入删除时不需要移动元素, 确定插入删除位置后, 时间复杂度为 O(1)  </p>
<p>适用于:</p>
<ul>
<li>长度变化较大</li>
<li>频繁进行插入删除操作的</li>
</ul>
<h4 id="单向链表的表示"><a href="#单向链表的表示" class="headerlink" title="单向链表的表示"></a>单向链表的表示</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义单链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElemType data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125; LNode, *LinkList; <span class="comment">//LNode为结点类型，LinkList为指向结点的指针类型</span></span><br></pre></td></tr></table></figure></div>

<p>头指针: </p>
<ul>
<li>是链表指向的<strong>第一个节点</strong>的指针 (若链表存在<strong>头节点</strong>,则指向头节点).</li>
<li>头指针具有<strong>标识作用</strong>,因此常用头指针冠以链表的名字.</li>
<li>无论链表是否为空,头指针<strong>均不为空</strong>.</li>
<li>头指针是链表<strong>必要</strong>元素</li>
</ul>
<p>头节点:</p>
<ul>
<li>是为了操作的统一和方便而设立. (统一了在第一元素节点前插入删除操作与其他节点)</li>
<li>头节点 <strong>不一定</strong> 是链表的必要元素.</li>
</ul>
<h4 id="双向链表的表示"><a href="#双向链表的表示" class="headerlink" title="双向链表的表示"></a>双向链表的表示</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>;</span> <span class="comment">// 指向前驱结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">next</span>;</span> <span class="comment">// 指向后继结点</span></span><br><span class="line">&#125; DLinkList;</span><br></pre></td></tr></table></figure></div>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>逻辑结构: 一对一<br>存储结构: 顺序存储(顺序栈) 链式存储(链栈)</p>
<p><strong>后进先出</strong> 是受限制的线性表.</p>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></div>

<p>栈空标志: base &#x3D;&#x3D; top<br>栈满标志: top-base &#x3D;&#x3D; stacksize </p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>进栈</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base == S.stacksize)<span class="comment">// 判断是否栈满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    *S.top ++ = e; <span class="comment">//先获取栈顶元素 e ,然后栈顶指针减一</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>出栈 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Pop</span><span class="params">(SaStack &amp;S, SElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base) <span class="comment">//判断栈空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = *--S.top;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>&#123;</span></span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; StackNode, *LinkStack;</span><br><span class="line">LinkStack S;</span><br></pre></td></tr></table></figure></div>

<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><p>进栈 </p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span>&#123;</span><br><span class="line">    p = new StackNode; <span class="comment">//生成新结点p</span></span><br><span class="line">    <span class="keyword">if</span> (!p) </span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW); <span class="comment">// 如果结点申请失败, 就退出</span></span><br><span class="line"></span><br><span class="line">    p -&gt; data = e;</span><br><span class="line">    p -&gt; next = S;</span><br><span class="line">    S = P;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>出栈</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack &amp;S, SElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == <span class="literal">NULL</span>) <span class="comment">// 判断是否为空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    e = S -&gt; data;</span><br><span class="line">    p = S;</span><br><span class="line">    S = S -&gt; next;</span><br><span class="line">    delete p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>逻辑结构: 一对一<br>存储结构: 顺序存储 (循环队列) 链式存储 (链队)</p>
<h3 id="顺序存储-循环队列"><a href="#顺序存储-循环队列" class="headerlink" title="顺序存储 (循环队列)"></a>顺序存储 (循环队列)</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    QElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Qnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Qnode, *QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    QueuePtr front; <span class="comment">// 队头指针</span></span><br><span class="line">    QueuePtr rear; <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure></div>

<h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><p>入队</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q, QElemType e)</span>&#123;</span><br><span class="line">    p = new QNode;</span><br><span class="line">    <span class="keyword">if</span>(!p) </span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line"></span><br><span class="line">    p -&gt; data = e; p -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear -&gt; next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>出队</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q, QElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="comment">// 判断队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line"></span><br><span class="line">    p = Q.front -&gt; next;</span><br><span class="line">    e = p -&gt; data;</span><br><span class="line">    Q.front -&gt; next = p -&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) <span class="comment">// 出队为最后一个元素, 还原为初始队列状态</span></span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line"></span><br><span class="line">    delete p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="链式存储-链栈"><a href="#链式存储-链栈" class="headerlink" title="链式存储(链栈)"></a>链式存储(链栈)</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line">Typedef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    QElemType *base;</span><br><span class="line">    <span class="type">int</span> front; <span class="comment">// 队头下标</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">// 队尾下标</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure></div>

<h4 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h4><p>循环队列入队</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,QElemType e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXQSIZE == Q.front) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q.base[Q.rear = e];</span><br><span class="line">    Q.rear = (Q.rear+<span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>循环队列出队</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue &amp;Q,QElemType &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = Q.base[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>)%MAXQSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>逻辑结构: 一对一<br>存储结构: 顺序存储(顺序串) 链式存储(链串)  </p>
<p>是受限制的线性表, 数据元素是字符.</p>
<h3 id="顺序串"><a href="#顺序串" class="headerlink" title="顺序串"></a>顺序串</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> *ch;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; HString;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 255 <span class="comment">// 用户可以在255以内定义最长串长</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> SString[MAXSTRLEN+<span class="number">1</span>]; <span class="comment">// 0号单元存放串的长度</span></span><br></pre></td></tr></table></figure></div>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>逻辑结构: 一对一<br>存储结构: 顺序存储 顺序+链式存储</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>逻辑结构: 一对多<br>存储结构: 顺序存储 链式存储</p>
<p>树是n个结点的有限集</p>
<h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><p><strong>结点的度:</strong> 树中一个结点的孩子个数, 树中结点的最大度数称为树的度数.<br><strong>分支结点:</strong> 度数大于0的结点<br><strong>叶子结点(终端结点):</strong> 度为零 (没有子孙结点) 的结点 </p>
<p><strong>结点的层次:</strong> 从树根开始定义, 根节点为第一层, 它的子结点为第二层, 以此类推.<br><strong>结点的深度:</strong> 从根节点开始自顶向下逐层累加的<br><strong>结点的高度:</strong> 从叶结点开始自底向上逐层累加的</p>
<p><strong>树的高度(或深度):</strong> 树中结点的最大层数</p>
<p><strong>有序树和无序树:</strong> 树中结点的各子树从左到右是有次序的, 不能互换, 称之为有序树, 否则称为无序树.<br><strong>路径:</strong> 两个节点之间的路径是由这两个结点之间所经过的 <strong>结点序列</strong> 构成<br><strong>路径长度:</strong> 两个节点之间的路径长度是路径上所经过的 <strong>边的个数</strong> 构成</p>
<p><strong>森林:</strong> 森林是n棵互不相交的树的集合</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li><p>树中的结点数等于所有结点的度数加1  </p>
</li>
<li><p>度为 $m$ 的树中, 第i层至多有 $m^{i-1}$ 个结点</p>
</li>
<li><p>高度为$h$的$m$叉树至少有 $h$ 个结点, 至多有 $m^h-1 \over m-1$ 个结点.</p>
</li>
<li><p>具有 $sum$ 个结点的 $m$ 叉树的最小高度为 $\log _m{n(m-1)+1}$</p>
<blockquote>
<p>$sum &#x3D; {m^h-1 \over m-1}$</p>
</blockquote>
</li>
<li><p>高度为 $h$ 的 $m$ 叉数至少有 $h+m-1$ 个结点</p>
</li>
</ul>
<h4 id="区分-度为m的树-m叉树"><a href="#区分-度为m的树-m叉树" class="headerlink" title="区分 度为m的树\m叉树"></a>区分 度为m的树\m叉树</h4><ol>
<li>m 叉树–每个结点最多只能有m个孩子的树</li>
</ol>
<ul>
<li>任意结点的度数 ≦ m</li>
<li>可以是空树</li>
</ul>
<ol start="2">
<li>度为m的树–至少有一个结点度 &#x3D;&#x3D; m</li>
</ol>
<ul>
<li>任意结点的度数 ≦ m</li>
<li>一定为非空树</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树有左右之分(有序树), 给结点编号时每一层从左往右依次编号.</p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>高度为h的满二叉树, 含有 $2^h-1$ 个结点.</p>
<p>对于编号为 $i$ 的结点: </p>
<ul>
<li>双亲为 <code>i/2</code></li>
<li>若有左孩子, 则其为2i</li>
<li>若有右孩子, 则其为2i</li>
</ul>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>不同于满二叉树, 完全二叉树最后一层的结点都靠右排列,且除最后一层, 其他层都是满的.</p>
<p>高度为 $h$ 的完全二叉树, 最多有 $2^h-1$ 个结点.</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>树上任意结点的左子树和右子树的深度差不超过1.</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ol>
<li>先序遍历: 根节点 -&gt; 左子树 -&gt; 右子树</li>
<li>中序遍历: 左子树 -&gt; 根节点 -&gt; 右子树</li>
<li>后续遍历: 左子树 -&gt; 右子树 -&gt; 根节点</li>
</ol>
<p>以上三种其时间复杂度为O(n)</p>
<ol start="4">
<li>层次遍历: 从上到下, 从左往右</li>
</ol>
<h3 id="哈夫曼树-最优树"><a href="#哈夫曼树-最优树" class="headerlink" title="哈夫曼树(最优树)"></a>哈夫曼树(最优树)</h3><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，为哈夫曼树.<br>哈夫曼树是带权路径长度最短的树, 权值较大的结点离根较近.</p>
<h4 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h4><p>结点的带权路径长度为: 从根结点到该结点之间的路径长度与该结点的权的乘积.</p>
<p>树的带权路径长度规定为所有叶子结点的带权路径长度之和, 记为WPL.</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>线性表可以是空表, 图不可以是空图.</p>
<h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>适合于稠密图</p>
<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>适合于稀疏图</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="深度优先-前序遍历"><a href="#深度优先-前序遍历" class="headerlink" title="深度优先 (前序遍历)"></a>深度优先 (前序遍历)</h4><h4 id="广度优先-层次遍历"><a href="#广度优先-层次遍历" class="headerlink" title="广度优先 (层次遍历)"></a>广度优先 (层次遍历)</h4><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>用于查找的数据集合称为查找表, 他是由同一类型的数据元素 (或记录) 组成, 可以是一个数组或链表等数据类型.</p>
<p><strong>关键字:</strong> 数据元素中唯一标识干元素的某个数据项的值, 使用基于关键字的查找, 结果应该是唯一的.</p>
<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>从表的一端开始, 按顺序从后往前查找, 没什么好说的.</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul>
<li>算法简单, 对表结构无任何要求</li>
<li>平均查找长度较大, 当n较大时不推荐采用顺序查找</li>
</ul>
<h3 id="折半查找-二分查找"><a href="#折半查找-二分查找" class="headerlink" title="折半查找(二分查找)"></a>折半查找(二分查找)</h3><p>通过三个指针(low, high, mid), low &#x3D; 1, high &#x3D; 表长, mid取low 和 high 的中间值.  </p>
<ol>
<li>mid 与给定的 key 比较, 若相等则查找成功, 若不相等则将表分成前后两个子表.</li>
<li>如果 key 比 mid 大, 则将 low 取为 <code>mid + 1</code>; 反之比 mid 小, 则将 high 取为 <code>mid - 1</code></li>
</ol>
<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><ul>
<li>显然效率比顺序查找快</li>
<li>必须采用顺序存储结构</li>
</ul>
<h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>建立一个索引表,然后在块中顺序查找.</p>
<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><ul>
<li>效率在顺序查找和折半查找之间</li>
<li>适用于经常动态变化的线性表</li>
</ul>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>KCN: 关键字比较次数<br>RMN: 记录移动次数</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>最简单的一种排序方式.</p>
<ol>
<li>一个一个取待排表中的关键字</li>
<li>在新的表中顺序查找, 逐个后移元素, 直到找到插入位置</li>
</ol>
<h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>时间复杂度</p>
<p>最坏情况下:<br>KCN ≈ ${n^2}\over {2}$<br>RMN ≈ ${n^2}\over {2}$</p>
<p>空间复杂度</p>
<p>只需要一个用于记录的空间, 因此为: <code>O(1)</code></p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>简单, 稳定</li>
<li>适用于链式</li>
<li>不推荐用于n较大的情况</li>
</ul>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><p>使用折半查找的排序方法.</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>稳定</li>
<li>不适用于链式结构</li>
<li>适合初始记录无序, n较大的情况</li>
</ul>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>先分组, 使数据 “基本有序” 后, 再进行 直接插入排序.</p>
<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>跳跃式移动, 不稳定</li>
<li>不适用于链式</li>
<li>适合初始记录无序, n较大的情况</li>
</ul>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><ol>
<li><p>简单选择排序</p>
</li>
<li><p>树形选择排序</p>
</li>
<li><p>堆排序</p>
</li>
</ol>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机通识</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的排序算法</title>
    <url>/2025/04/21/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%AE%97%E6%B3%95-%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 (Bubble Sort)"></a>冒泡排序 (Bubble Sort)</h3><p>时间复杂度: O(n²) - 最坏、平均情况<br>空间复杂度: O(1) - 原地排序<br>稳定性: 稳定</p>
<p>工作原理:<br>重复遍历数组，比较相邻元素并交换位置<br>每轮遍历将当前最大元素”冒泡”到末尾<br>下一轮遍历长度减少 1(已排序部分)</p>
<p>@param {Array} <code>arr</code> - 需要排序的数组<br>@return {Array} - 排序后的数组(原地修改)</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 外层循环控制排序轮数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 优化标志: 如果一轮中没有交换，则数组已排序</span></span><br><span class="line">    <span class="keyword">let</span> swapped = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内层循环比较相邻元素</span></span><br><span class="line">    <span class="comment">// 注意 j &lt; len - 1 - i: 每轮后最大的i个元素已确定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="comment">// 如果当前元素大于下一个元素，交换它们</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// ES6解构赋值语法完成交换</span></span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">        swapped = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果本轮未发生交换，数组已排序，提前退出</span></span><br><span class="line">    <span class="keyword">if</span> (!swapped) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 (Insertion Sort)"></a>插入排序 (Insertion Sort)</h3><p>时间复杂度: O(n²) - 最坏、平均情况; O(n) - 最好情况(已排序)<br>空间复杂度: O(1) - 原地排序<br>稳定性: 稳定</p>
<p>工作原理:<br>将数组分为已排序和未排序两部分<br>初始时已排序部分只有第一个元素<br>每次从未排序部分取出一个元素，插入到已排序部分的正确位置<br>像整理扑克牌一样逐步构建有序数组</p>
<p>@param {Array} <code>arr</code> - 需要排序的数组<br>@return {Array} - 排序后的数组(原地修改)</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从第二个元素开始，第一个元素视为已排序</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 保存当前要插入的元素</span></span><br><span class="line">    <span class="keyword">const</span> current = arr[i];</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前查找插入位置，将大于current的元素后移</span></span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; current) &#123;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j]; <span class="comment">// 元素后移一位</span></span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到插入位置，放入当前元素</span></span><br><span class="line">    arr[j + <span class="number">1</span>] = current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h3><p>时间复杂度: O(n log n) - 平均情况; O(n²) - 最坏情况<br>空间复杂度: O(log n) - 递归调用栈<br>稳定性: 不稳定</p>
<p>选择一个”基准”元素(pivot)<br>将小于基准的元素放左边，大于基准的放右边<br>递归地对左右两个子数组进行快速排序<br>分治法的典型应用</p>
<p>@param {Array} <code>arr</code> - 需要排序的数组<br>@param {number} <code>[left=0]</code> - 起始索引<br>@param {number} <code>[right=arr.length-1]</code> - 结束索引<br>@return {Array} - 排序后的数组</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr, left = <span class="number">0</span>, right = arr.length - <span class="number">1</span></span>) &#123;</span><br><span class="line">  <span class="comment">// 递归终止条件: 子数组长度为1或更小</span></span><br><span class="line">  <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取基准元素的最终位置</span></span><br><span class="line">  <span class="keyword">const</span> pivotIndex = <span class="title function_">partition</span>(arr, left, right);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归排序基准左侧子数组</span></span><br><span class="line">  <span class="title function_">quickSort</span>(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 递归排序基准右侧子数组</span></span><br><span class="line">  <span class="title function_">quickSort</span>(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分区操作: 将数组分为小于和大于基准元素的两部分</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">arr</span> - 需要分区的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">left</span> - 起始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">right</span> - 结束索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125; - 基准元素的最终位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">arr, left, right</span>) &#123;</span><br><span class="line">  <span class="comment">// 选择最右元素作为基准</span></span><br><span class="line">  <span class="keyword">const</span> pivot = arr[right];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// i指向小于基准区域的最后一个元素</span></span><br><span class="line">  <span class="keyword">let</span> i = left - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// j遍历数组元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = left; j &lt; right; j++) &#123;</span><br><span class="line">    <span class="comment">// 当前元素小于基准，扩展小于区域，交换元素</span></span><br><span class="line">    <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      [arr[i], arr[j]] = [arr[j], arr[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将基准元素放到正确位置(小于区域之后)</span></span><br><span class="line">  [arr[i + <span class="number">1</span>], arr[right]] = [arr[right], arr[i + <span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回基准元素的最终位置</span></span><br><span class="line">  <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 (Merge Sort)"></a>归并排序 (Merge Sort)</h3><p>时间复杂度: O(n log n) - 所有情况<br>空间复杂度: O(n) - 需要额外空间存储合并结果<br>稳定性: 稳定</p>
<p>分治法: 将数组分成两半，递归排序<br>将排序后的两半合并为一个有序数组<br>不断分割直到子数组长度为 1(天然有序)</p>
<p>@param {Array} <code>arr</code> - 需要排序的数组<br>@return {Array} - 排序后的新数组</p>
<div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归终止条件: 数组长度为1时已排序</span></span><br><span class="line">  <span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将数组分为两半</span></span><br><span class="line">  <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(len / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> left = arr.<span class="title function_">slice</span>(<span class="number">0</span>, mid);</span><br><span class="line">  <span class="keyword">const</span> right = arr.<span class="title function_">slice</span>(mid);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归排序两个子数组</span></span><br><span class="line">  <span class="keyword">const</span> sortedLeft = <span class="title function_">mergeSort</span>(left);</span><br><span class="line">  <span class="keyword">const</span> sortedRight = <span class="title function_">mergeSort</span>(right);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合并两个有序数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(sortedLeft, sortedRight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并两个有序数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">left</span> - 第一个有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">right</span> - 第二个有序数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Array</span>&#125; - 合并后的有序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> rightIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 比较两个数组的元素，按序放入结果数组</span></span><br><span class="line">  <span class="keyword">while</span> (leftIndex &lt; left.<span class="property">length</span> &amp;&amp; rightIndex &lt; right.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[leftIndex] &lt; right[rightIndex]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(left[leftIndex]);</span><br><span class="line">      leftIndex++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(right[rightIndex]);</span><br><span class="line">      rightIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将剩余元素添加到结果中</span></span><br><span class="line">  <span class="comment">// (两个数组中只有一个会有剩余元素)</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">    .<span class="title function_">concat</span>(left.<span class="title function_">slice</span>(leftIndex))</span><br><span class="line">    .<span class="title function_">concat</span>(right.<span class="title function_">slice</span>(rightIndex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="计数排序-Count-Sort-适用于整数范围较小的场景"><a href="#计数排序-Count-Sort-适用于整数范围较小的场景" class="headerlink" title="计数排序 (Count Sort) - 适用于整数范围较小的场景"></a>计数排序 (Count Sort) - 适用于整数范围较小的场景</h3><div class="code-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数排序</span></span><br><span class="line"><span class="comment"> * 时间复杂度: O(n + k) - n是数组长度，k是整数范围</span></span><br><span class="line"><span class="comment"> * 空间复杂度: O(k) - 需要计数数组</span></span><br><span class="line"><span class="comment"> * 稳定性: 稳定(如果实现正确)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 工作原理:</span></span><br><span class="line"><span class="comment"> * - 统计每个整数出现的次数</span></span><br><span class="line"><span class="comment"> * - 根据统计结果重建有序数组</span></span><br><span class="line"><span class="comment"> * - 非比较排序，适用于有限范围整数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array&lt;number&gt;</span>&#125; <span class="variable">arr</span> - 需要排序的整数数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">Array&lt;number&gt;</span>&#125; - 排序后的新数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">countSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> [...arr];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找出数组中的最大值和最小值</span></span><br><span class="line">  <span class="keyword">let</span> max = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> min = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; max) max = arr[i];</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; min) min = arr[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算计数数组的大小，偏移量为min</span></span><br><span class="line">  <span class="keyword">const</span> range = max - min + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> counts = <span class="keyword">new</span> <span class="title class_">Array</span>(range).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统计每个元素出现的次数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    counts[arr[i] - min]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据计数重建排序后的数组</span></span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">    <span class="comment">// 将每个元素按照出现次数添加到结果数组</span></span><br><span class="line">    <span class="keyword">while</span> (counts[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(i + min);</span><br><span class="line">      counts[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="排序算法比较表"><a href="#排序算法比较表" class="headerlink" title="排序算法比较表"></a>排序算法比较表</h3><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度(平均)</th>
<th>时间复杂度(最好)</th>
<th>时间复杂度(最坏)</th>
<th>空间复杂度</th>
<th>稳定性</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
<td>简单，适合小数据集</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>稳定</td>
<td>对近乎有序数据高效</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n²)</td>
<td>O(log n)</td>
<td>不稳定</td>
<td>实际应用最广泛</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>稳定</td>
<td>性能稳定但需额外空间</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(k)</td>
<td>稳定</td>
<td>适用于整数范围较小情况</td>
</tr>
</tbody></table>
<p>JavaScript 的 sort()方法在不同浏览器中实现方式不同，但大多采用这些算法的混合：</p>
<ul>
<li>V8 引擎(Chrome&#x2F;Node.js):  对于小数组（长度&lt;10）使用插入排序，大数组使用快速排序的变种——TimSort（结合了归并排序和插入排序）</li>
<li>SpiderMonkey(Firefox): 使用归并排序</li>
<li>JavaScriptCore(Safari): 使用混合排序算法</li>
</ul>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>数字世界的构建手册</title>
    <url>/2024/12/28/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86-%E6%95%B0%E5%AD%97%E4%B8%96%E7%95%8C%E7%9A%84%E6%9E%84%E5%BB%BA%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="数字存储"><a href="#数字存储" class="headerlink" title="数字存储"></a>数字存储</h2><p>计算机内存是由无数个电容器组成，可以通过电路控制给电容充电或放电，充满电代表 1，未充电代表 0，所以计算机存储任何数据只能用 0 和 1 来表示。<br>每个电容就是一个最小存储单元，称为 bit（位）。</p>
<p>由于每个 bit 只能是 0 和 1，为了能表示更多的数, 计算机采用二进制存储数字，逢 2 进 1.<br>这就是 二进制.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="comment">// 这是十进制</span></span><br><span class="line"></span><br><span class="line"><span class="number">0b1010</span> <span class="comment">//10 使用0b开头来表示二进制</span></span><br></pre></td></tr></table></figure></div>

<p>当一个二进制过长时, 阅读就不太方便了…<br>分组可以方便阅读, 例如可以四个 bit 为一组, 那么每一位的十进制取值就是 0<del>15.<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241226135228593.jpg"
                     
                ><br>这就是 十六进制, 逢 16 进 1. 为了表示方便, 用字母来代替两位数的值.<br>也就是 大于 9 的用 A</del>F 代替.<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241226135917227.jpg"
                     
                ></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0xA</span> <span class="comment">//10 十六进制以0x开头</span></span><br></pre></td></tr></table></figure></div>

<p>也可以 三个 bit 为一组, 那么每一组的十进制取值就是 0~7<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241226135433677.jpg"
                     
                ><br>这就是 八进制, 逢 8 进 1.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">012</span> <span class="comment">//还是10 八进制以0开头</span></span><br></pre></td></tr></table></figure></div>

<h1 id="字符存储原理"><a href="#字符存储原理" class="headerlink" title="字符存储原理"></a>字符存储原理</h1><p>使用一串固定的二进制数能表示一个十进制数.</p>
<p>那么同理的,<br>使用一串固定的二进制数, 再指定这个二进制数表示的字符,</p>
<p>也就是制定一套字符与二进制的映射关系, 就能实现存储字符了.<br>这就是编码表的原理.</p>
<h3 id="ASCII-编码表"><a href="#ASCII-编码表" class="headerlink" title="ASCII 编码表"></a>ASCII 编码表</h3><p>最早的编码表就是 ASCII 编码表, 它规定了数字字符, 英语字母 和其他常见符号等共计 128 个字符.<br>每个字符对应的数值称为 <strong>码点(Code Point)</strong>.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241228142911512.jpg"
                     
                ></p>
<p>如表所示, 由于常见字符对的码点用 8 个二进制位就可以表示, 因此在计算机设计时就默认以每 8 个 bit 为一组来读写数据.<br>为了表达方便, 像这样成组的 8 个 bit, 我们简称为 一个 <strong>Byte(字节)</strong>, 简写为 B.</p>
<blockquote>
<p>1 KB &#x3D; 1024 B<br>1 MB &#x3D; 1024 KB<br>1 GB &#x3D; 1024 MB<br>1 TB &#x3D; 1024 GB</p>
</blockquote>
<h3 id="GBK-汉字内码拓展规范"><a href="#GBK-汉字内码拓展规范" class="headerlink" title="GBK 汉字内码拓展规范"></a>GBK 汉字内码拓展规范</h3><p>由于只有 128 个字符, ASCII 码表覆盖有限, 因此各个国家都需要给自己单独规定编码表.</p>
<p>我国的 汉字内码拓展规范 简称 GBK, 在兼容 ASCII 码表的同时, 拓展了 2 万多个汉字.<br>相比于 ASCII 码用一个字节, GBK 码用<strong>两个</strong>字节来表示字符.</p>
<h3 id="Unicode-码"><a href="#Unicode-码" class="headerlink" title="Unicode 码"></a>Unicode 码</h3><p>如果有一万个国家, 那就得有一万种不同的编码.</p>
<p>因此, ISO (国际标准化组织) 就制定了统一的标准, Unicode 码, 也叫 统一&#x2F;万国(union)码.<br>Unicode 码包含了世界上大部分国家的大多数文字和字符, 大约有 14 万多个.<br>其中包含 65536 个常用基础字符, 剩下的是补充字符.<br>其中, 汉字的码点通常占两个字节.</p>
<p>Unicode 编码表有多种不同的实现方式, 常见的有:</p>
<ul>
<li>UTF- 8 : 是一种变长的编码方式. 它可以使用 1~4 个字节表示一个符号, 根据不同的符号而变化字节长度. (常用, 更节省资源)</li>
<li>UTF-16: 也是变长编码方式, 基础字符用 2 个字节, 补充字符用 4 字节.</li>
<li>UTF-32: 固定长度编码, 不管字符的 Unicode 码多大, 统一使用 4 个字节.</li>
</ul>
<p>很多情况下, 我们都使用 变长编码方式 UTF-8, 下面简单介绍以下它的编码规则:</p>
<p>UTF-8 首先将码点的范围进行约束.<br>通过码点的范围来分配位数:</p>
<table>
<thead>
<tr>
<th>UCS-2 编码(16 进制)</th>
<th>UTF-8 编码(二进制)</th>
</tr>
</thead>
<tbody><tr>
<td>0000 ~ 007F</td>
<td>0xxx xxxx</td>
</tr>
<tr>
<td>0080 ~ 07FF</td>
<td>110x xxxx 10xx xxxx</td>
</tr>
<tr>
<td>0800 ~ FFFF</td>
<td>1110 xxxx 10xx xxxx 10xx xxxx</td>
</tr>
<tr>
<td>01 0000 ~ 10 FFFF</td>
<td>1111 0xxx 10xx xxxx 10xx xxxx</td>
</tr>
</tbody></table>
<p>确定好范围, 再将 UCS-2 编码的二进制由低到高填入 UTF-8 中的 x 位中.</p>
<h1 id="图像的存储"><a href="#图像的存储" class="headerlink" title="图像的存储"></a>图像的存储</h1><p>计算机中的图片都是由无数个 像素点组成的, 每个像素点有各自的颜色.<br>当像素点足够小, 足够多时, 就组成了人眼能识别的图像了.</p>
<p>显示器的每一个像素点都包含 红绿蓝(R&#x2F;G&#x2F;B) 三个子像素, 我们称为三基色.<br>通过调整每种颜色的亮度, 就能组合出世界上所有的颜色.<br>每种颜色的亮度都用 0 ~ 255 的数值来表示, 数值越大就越亮.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241228163813786.jpg"
                     
                ></p>
<p>用两位十六进制 00 ~ FF 刚好能表示 0 ~ 255 , 因此三个颜色的亮度可以这样表示:</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#RRGGBB</span><br></pre></td></tr></table></figure></div>

<p>例如, 白色是所有颜色亮度最大值 255, 对应的十六进制是 FF</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#FFFFFF</span><br></pre></td></tr></table></figure></div>

<h1 id="音频的存储"><a href="#音频的存储" class="headerlink" title="音频的存储"></a>音频的存储</h1><p>声音是靠物体震动传播, 震动的频率和振幅不同, 得到的声音的音高和大小也不同,<br>所以保存声音信息主要记录的就是: 声波的<strong>频率</strong>和<strong>振幅</strong>.</p>
<p>计算机存储声音通常会经过三个步骤：采样、量化、编码</p>
<p>对音频最重要的两个元素 <strong>频率</strong>和<strong>振幅</strong> 采样, 然后取其近似值做量化, 最后转换位二进制编码存储.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/file-20241228165147613.jpg"
                     
                ><br>量化单位越密集, 音频越接近原始音频, 但代价是信息量大, 所需要的存储空间越大.</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>计算机通识</category>
      </categories>
      <tags>
        <tag>数字信息架构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2024/04/04/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h1><p>是一些 <strong>互相连接</strong> , <strong>自治</strong> 的计算机的集合.</p>
<blockquote>
<p>互连: 计算机之间可以通过有线或无线的方式进行数据通信<br>自治: 独立的计算机, 有自己的硬件和软件, 可以单独运行使用</p>
</blockquote>
<h4 id="计算机网络的主要功能"><a href="#计算机网络的主要功能" class="headerlink" title="计算机网络的主要功能:"></a>计算机网络的主要功能:</h4><ul>
<li>资源共享</li>
<li>数据通信</li>
</ul>
<h4 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成:"></a>计算机网络的组成:</h4><ul>
<li>网络硬件系统</li>
<li>网络软件系统</li>
</ul>
<p>逻辑上又分为：</p>
<ul>
<li>资源子网: 包含大量网络资源的网络部分 (如服务器等)</li>
<li>通信子网: 负责数据传输的网络部分 (如路由器等)</li>
</ul>
<h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><h4 id="按覆盖范围分类"><a href="#按覆盖范围分类" class="headerlink" title="按覆盖范围分类"></a>按覆盖范围分类</h4><ul>
<li><p>广域网(WAN)</p>
</li>
<li><p>城域网(MAN)</p>
</li>
<li><p>局域网(LAN)</p>
</li>
<li><p>个域网(PAN)</p>
</li>
</ul>
<h4 id="按拓扑结构"><a href="#按拓扑结构" class="headerlink" title="按拓扑结构"></a>按拓扑结构</h4><ul>
<li>总线型网络<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%841.png"
                      alt="alt text"
                ></li>
<li>星型网络<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%842.png"
                      alt="alt text"
                ></li>
<li>环形网络<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%843.png"
                      alt="alt text"
                ></li>
<li>网状型网络<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%844.png"
                      alt="alt text"
                ></li>
</ul>
<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p>计算机网络的体系结构是计算机网络的 各 <strong>层</strong> 及其 <strong>协议</strong> 和 <strong>层间接口</strong> 的集合.  </p>
<p>计算机网络通过分成不同的层次来组织和管理，每一层都有自己的规则（协议）和与其他层交流的方式（层间接口）.<br>这样做的好处是可以把一个复杂的问题分解成几个简单的小问题来处理.</p>
<p>如今用的最多的是  TCP&#x2F;IP体系结构, 现今规模最大, 覆盖全球的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"
                      alt="alt text"
                ></p>
<h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><p>分为7个层次, 自顶向下依次为: </p>
<ol>
<li><p>物理层：负责实际的物理连接和电气信号, 例如电话线或光纤.</p>
</li>
<li><p>数据链路层：在同一网络内（如一个办公室的局域网）确保数据的可靠传输, 包括错误检测和纠正.</p>
</li>
<li><p>网络层：负责在不同网络之间, 找到数据从发送方到接收方的最佳路径，就像导航系统，告诉数据怎么走.</p>
</li>
<li><p>传输层：确保数据从一个网络端点到另一个端点(不同网络之间)的传输.</p>
</li>
<li><p>会话层：管理不同设备间的通信会话.</p>
</li>
<li><p>表示层：确保数据能够被接收设备理解, 让接收方能够理解.</p>
</li>
<li><p>应用层：是用户与网络交互的接口, 比如网页浏览器, 让用户能够使用网络服务.</p>
</li>
</ol>
<h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h3><p>分为4个层次, 自顶向下依次为: </p>
<ol>
<li><p>网络接口层: 对应于OSI模型的物理层和数据链路层, 负责在物理媒介上传输原始比特流, 以及确保局域网内数据的可靠传输.</p>
</li>
<li><p>网络层: 负责跨网络的数据传输, 使用 <strong>IP协议</strong> 来实现数据包从源头到目的地的路由.</p>
</li>
</ol>
<blockquote>
<p>IP协议（Internet Protocol）的两个基本功能可以概括为：</p>
<p>寻址：IP协议为网络中的每个设备分配一个唯一的<strong>IP地址</strong>(互联网协议地址)，这样数据就可以被发送到正确的目的地。</p>
<p>路由：IP协议负责将数据包从源头,找到到达目的地的方式. 通过一系列的网络设备和网络，直到到达目标。</p>
</blockquote>
<ol start="3">
<li>传输层: 负责在网络端点之间提供可靠的通信服务. 主要协议有 <strong>TCP</strong>和 <strong>UDP</strong>.</li>
</ol>
<blockquote>
<p>TCP（Transmission Control Protocol）提供可靠的, 面向连接的服务. 对于那些需要确保数据完整性和可靠性的应用, TCP是更好的选择.</p>
<p>UDP（User Datagram Protocol）提供不可靠的, 无连接的服务. 适用于那些对传输速度和实时性有较高要求，但可以容忍一定数据丢失的应用场景.</p>
</blockquote>
<ol start="4">
<li>应用层: 对应于OSI模型的 会话层, 表示层和应用层. 为用户和应用程序提供网络服务.</li>
</ol>
<h3 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h3><p>网络可以识别的地址有 <strong>逻辑(IP)地址</strong> 和 <strong>物理(MAC)地址</strong> 两大类.</p>
<ul>
<li><p>物理地址（MAC地址）：是网络设备硬件的唯一标识符，通常指的是网络接口卡（NIC）上的媒体访问控制（MAC）地址, 设备生产时就固化在其中.</p>
</li>
<li><p>逻辑地址（IP地址）：逻辑地址是<strong>IP协议分配</strong>给网络设备的, 用于网络层和传输层通信的地址, IP地址的分配可根据需求灵活调整.</p>
</li>
</ul>
<p>MAC地址用于局域网内的通信, 而IP地址用于更广泛的网络环境.</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p><strong>子网掩码</strong> 与IP地址一起使用, 用于定义网络中哪些部分是<strong>网络地址</strong>, 哪些是<strong>主机地址</strong>.  子网掩码中的1表示该位属于网络号, 0表示属于主机号.</p>
<p>IP地址是由 <strong>网络地址</strong> 和 <strong>主机地址</strong> 组成</p>
<p>将IP地址与子网掩码进行 <strong>逻辑“与”（AND）</strong> 操作, 所得结果就是<strong>网络号</strong>.<br>网络号相同的设备被认为是在同一子网内。</p>
<blockquote>
<p>例如:<br>假设有一个IP地址192.168.1.10和一个子网掩码255.255.255.0 </p>
<p>将IP地址和子网掩码转换为二进制，然后进行逻辑“与”操作：<br>(逻辑“与”: 只有当两个相应的位都是1时，结果位才为1，否则为0)</p>
</blockquote>
<table>
<thead>
<tr>
<th>元素</th>
<th>二进制表示</th>
</tr>
</thead>
<tbody><tr>
<td>IP地址</td>
<td>11000000 . 10101000 . 00000001 . 00001010</td>
</tr>
<tr>
<td>子网掩码</td>
<td>11111111 . 11111111 . 11111111 . 00000000</td>
</tr>
<tr>
<td>逻辑“与”结果</td>
<td>11000000 . 10101000 . 00000001 . 00000000</td>
</tr>
</tbody></table>
<blockquote>
<p>将结果转换回十进制，得到网络号192.168.1.0。</p>
</blockquote>
<p>IPv4和IPv6是IP协议的两个版本, 它们用于 <strong>定义互联网上设备如何标识和通信的方式</strong>.  </p>
<h4 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h4><p>是32位二进制的, 以四组十进制数表示.</p>
<blockquote>
<p>例如: 192.168.1.1</p>
</blockquote>
<p>在<strong>IPv4</strong>中, IP地址被分为五类：A、B、C、D和E。这种分类基于IP地址的第一个字节（二进制中最高位的8位）, 用于决定地址的用途和可能的地址数量.</p>
<ul>
<li><strong>A类</strong>（1-127）,用于大型网络(如跨国公司), 默认子网掩码：255.0.0.0</li>
<li><strong>B类</strong>（128-191）,用于中型网络(如地区网络), 默认子网掩码：255.255.0.0</li>
<li><strong>C类</strong>（192-223）,小型网络(如家庭), 默认子网掩码：255.255.255.0</li>
<li><strong>D类</strong>（224-239）,广播地址.</li>
<li><strong>E类</strong>（240-255）,保留用于实验和研究, 不用于公共网络.</li>
</ul>
<blockquote>
<p>给定IP地址为 192.55.12.120&#x2F;24  </p>
<p>192.55.12.120 是其IP地址 (11000000 . 00110111 . 00001100 . 01111000)<br>&#x2F;24 表示子网掩码的前24位是网络部分，剩下的8位是主机部分<br>即子网掩码为: (255.255.255.0) 11111111 . 111111111 . 11111111 . 00000000 </p>
<p>网络号由 IP地址 和 子网掩码 转换为二进制，然后进行逻辑“与”操作, 得到.<br>为: 11000000 . 00110111 . 00001100 . 00000000 (192.55.12.0)<br>主机号由 子网掩码 取反(0.0.0.255), 与IP地址“按位与”, 得到主机号：0.0.0.120.</p>
</blockquote>
<h4 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h4><p>是128位的, 以八组四个十六进制数表示.</p>
<blockquote>
<p>例如: 2001:0db8:85a3:0000:0000:8a2e:0370:7334</p>
</blockquote>
<p>IPv6地址一组中的前导0可以不写<br>在有多个0连续出现时, 可以用一对冒号取代, 且只能取代一次.</p>
<blockquote>
<p>例如:<br>21DA:0000:0000:0000:02AA:000F:FE08:9C5A</p>
<p>缩写为:<br>21DA::2AA:F:FE08:9C5A 或者<br>21DA:0:0:0:2AA:F:FE08:9C5A</p>
</blockquote>
<p>IPv6提供了比IPv4更大的地址空间, 解决了IPv4地址耗尽的问题.  </p>
<p>为了从IPv4平稳过渡到IPv6, IPv6引入一种特殊的格式, 即在IPv4地址转换为十六进制, 再前置80个”0”和一个”ffff”以匹配128位的IPv6.</p>
<blockquote>
<p>例如, 将IPv4: 192.168.0.1 转换为IPv6</p>
<ol>
<li>转换为十六进制：C0A8 0001</li>
<li>前导零 + ffff：0000:0000:0000:0000:0000:ffff:c0a8:0001</li>
</ol>
<p>也可以简化表示为:<br>::ffff:c0a8:1  </p>
</blockquote>
<h1 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h1><h3 id="交换机（Switch）"><a href="#交换机（Switch）" class="headerlink" title="交换机（Switch）"></a>交换机（Switch）</h3><p>是局域网内的交换设备, 用于连接网络节点, 每个端口独享带宽, 实现点对点通信, 提高网络效率.</p>
<p>交换机的主要功能有：</p>
<ol>
<li><strong>数据转发</strong>：根据MAC地址表将数据帧转发到正确的端口</li>
<li><strong>MAC地址学习</strong>：动态学习并<strong>更新MAC地址表</strong></li>
<li><strong>广播抑制</strong>：减少不必要的广播流量</li>
<li><strong>避免冲突</strong>：通过CSMA&#x2F;CD协议避免数据发送冲突</li>
</ol>
<p>当交换机收到数据帧后，根据目的MAC地址查找MAC地址表, 确定对应端口, 然后将数据帧转发出去.</p>
<blockquote>
<p>数据链路层 传输的协议 数据单元 就是 <strong>帧</strong></p>
</blockquote>
<p>MAC地址表初始为空, 会动态学习过程构建. 这一过程主要包含:</p>
<ol>
<li><strong>学习</strong>：记录数据帧来源的MAC地址和端口。</li>
<li><strong>转发</strong>：根据学习到的信息将数据帧转发到目的端口。</li>
<li><strong>泛洪</strong>：未知目的MAC地址时，将数据帧发送到所有端口。</li>
<li><strong>更新</strong>：定期更新MAC地址表，移除过时的条目。</li>
</ol>
<h3 id="路由器（Router）"><a href="#路由器（Router）" class="headerlink" title="路由器（Router）"></a>路由器（Router）</h3><p>连接不同网络（如局域网、广域网）的设备, 工作在网络层.</p>
<p>主要功能：</p>
<ol>
<li>路由选择和数据交换：根据路由表选择数据包的最佳传输路径, 通过转发表实现数据包的快速转发.</li>
<li>网络分段和流量控制：提高网络的可管理性和安全性, 管理网络流量，防止拥塞。</li>
<li>隔离广播和异种网络连接：限制广播域的范围。连接不同类型的网络技术。</li>
</ol>
<ul>
<li>路由表：根据路由选择算法生成，包含目的网络和下一跳地址。</li>
<li>转发表：从路由表生成，用于快速查找和转发数据包。</li>
</ul>
<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>物理层 就是要解决 <strong>在各种传输媒体上传输比特0,1</strong> 的问题, 进而给数据链路层提供透明传输比特流的服务.</p>
<p>物理层为了解决传输比特0和1的问题, 主要有以下四个任务</p>
<ul>
<li>机械特性: 指明所有接线器的形状和尺寸, 引脚数目和排列, 固定和锁定装置.</li>
<li>电器特性: 指明在接口电缆的各条线上出现的电压的范围.</li>
<li>功能特性: 指明某条线上出现的某一电平的电压表示何种意义.</li>
<li>过程特性: 指明对于不同功能的各种可能事件的出现顺序.</li>
</ul>
<h3 id="信号传输"><a href="#信号传输" class="headerlink" title="信号传输"></a>信号传输</h3><p>模拟信号：随时间变化而连续变化的信号.<br>数字信号: 是离散的、值的变化是瞬时发生的.</p>
<p>数据也分为模拟数据和数字数据。 </p>
<h4 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h4><ul>
<li><p>串行传输: 数据是一个 <strong>比特</strong> 一个比特依次发送的, 只需要一条数据传输线路</p>
</li>
<li><p>并行传输: 一次发送n个 <strong>比特</strong> , 需要n条传输线路</p>
</li>
<li><p>同步传输: 数据以稳定的 <strong>比特流</strong> 形式传输, 字节间没有间隔. 接收端在每个比特的中间时刻进行检测, 一边别接收到的是比特0或1.</p>
</li>
<li><p>异步传输: 以字节为独立得到传输单位, 字节之间的时间间隔不是固定的. 在每个字节的前后分别加上起始位和结束位.<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%BC%82%E6%AD%A5%E4%BC%A0%E8%BE%93.png"
                      alt="alt text"
                ></p>
</li>
<li><p>单向通信: 又称单工通信, 通信双方只有一个传输方向</p>
</li>
<li><p>双向交替通信(半双工): 通信双方可以相互传输数据, 但不能同时进行</p>
</li>
<li><p>双向同时通信(双工): 通信双方可以同时发送和接收信息</p>
</li>
<li><p>码元: 是一段调制好的基本波形, 可以表示比特信息<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%A0%81%E5%85%83.png"
                      alt="alt text"
                ></p>
</li>
<li><p>编码: 数字数据编码为数字信号</p>
</li>
<li><p>调制: 数字数据编码为模拟信号<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6.png"
                      alt="alt text"
                ></p>
</li>
</ul>
<h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><p>理想低通信道的最高码元传输速率 $&#x3D; 2W Baud &#x3D; 2W$ 码元&#x2F;秒<br>理想带宽信道的最高码元传输速率 $&#x3D; W Baud &#x3D; W$ 码元&#x2F;秒</p>
<blockquote>
<p>$W$ : 信道带宽 (Hz)<br>$Baud$ : 波特, 即 码元&#x2F;秒</p>
</blockquote>
<h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><p>$c &#x3D; W × log_2^{(1 +  \frac{S}{N})}$</p>
<blockquote>
<p>$c$ : 信道的极限信息传输速率 (b&#x2F;s)<br>$W$ : 信道带宽 (Hz)<br>$S$ : 信道内所传输信号的平均功率<br>$N$ : 信道内的高斯噪声功率<br>$\frac{S}{N}$ : 信噪比(dB)</p>
</blockquote>
<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p><strong>链路</strong>是从一个结点到相邻结点的一段物理路线, <strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件(如网络适配器) 和软件 (如协议实现)</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF.png"
                      alt="alt text"
                ></p>
<p>数据链路层传输的协议数据单元是 <strong>帧</strong></p>
<h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>在一段数据的前后分别添加首部和尾部, 首部和尾部的一个重要作用就是进行帧界定</p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>如果数据中1的某个字节的二进制代码恰好和 SOH 或 EOT 一样, 数据链路层就会错误地 “找到帧的边界”</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93.png"
                      alt="alt text"
                ></p>
<p>解决透明传输问题的方法就是发送端的数据链路层在数据中出现控制字符 SOH 或 EOT 的前面插入一个转义字符 “ESC”</p>
<h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>比特在传输过程中可能会产生差错.<br>1可能变0, 0可能变1; 这就称之为比特差错.</p>
<h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../img/%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C.png"
                      alt="alt text"
                ></p>
<p>只能检查出奇数个比特出现误码的情况.</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机通识</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Java入门-面向对象</title>
    <url>/2024/12/25/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Java%E5%85%A5%E9%97%A8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类: 用来描述一类事物的模板.<br>对象: 根据类这个模板创建的具体实例.</p>
<ul>
<li>类中的变量叫成员变量, 表示事物的属性</li>
<li>类中的方法叫成员方法, 表示事物的行为</li>
</ul>
<h3 id="类的语法格式"><a href="#类的语法格式" class="headerlink" title="类的语法格式"></a>类的语法格式</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 class 类名 &#123;</span><br><span class="line">    <span class="comment">// 属性声明 (属性, 成员变量, 不用初始化)</span></span><br><span class="line">    数据类型 变量名;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法声明 (行为, 方法 也叫函数)</span></span><br><span class="line">    <span class="keyword">public</span> 数据类型 方法名(参数列表) &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>有了 类 这个模板后, 我们就能实例化出具体的对象了.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用对象的方法</span></span><br><span class="line">对象名.方法名(参数列表);</span><br></pre></td></tr></table></figure></div>

<p>定义的变量会存储在 <strong>栈</strong> 中, 创建的对象会存储在 <strong>堆</strong> 中.</p>
<ul>
<li>局部变量一般存在栈里, 存取快.</li>
<li>对象实例存在堆里, 堆地方大.</li>
<li>对象引用存在栈里, 方便快速找到对象实例.</li>
</ul>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>封装(Encapsulation)是面向对象的核心特点之一, 要求将数据和操作这些数据的方法捆绑在一起, 作为一个整体.</p>
<p>例如, 以下是一个 <strong>过程式编程</strong> 案例, 求最终工资:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalaryDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="comment">//底薪</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">baseSalary</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">	<span class="comment">//奖金</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">bonus</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">	<span class="comment">//绩效等级</span></span><br><span class="line">	<span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span><span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算薪资</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">salary</span> <span class="operator">=</span> calculateSalary(baseSalary，bonus， grade);</span><br><span class="line">	System.out.println(salary);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateSalary</span><span class="params">(<span class="type">int</span> baseSalary，<span class="type">int</span> bonus，<span class="type">char</span> grade）&#123;</span></span><br><span class="line"><span class="params">	<span class="type">double</span> rate = <span class="keyword">switch</span> (grade）&#123;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> -&gt; <span class="number">1.0</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span> -&gt; <span class="number">0.8</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span> -&gt; <span class="number">0.6</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> -&gt; <span class="number">0.4</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">default</span> -&gt;<span class="number">0</span>;</span></span><br><span class="line"><span class="params">	&#125;;</span></span><br><span class="line"><span class="params">	return baseSalary +(<span class="type">int</span>)</span><span class="params">(bonus * rate)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>其中, 底薪 奖金 绩效等级 就是 数据; 计算薪资 就是 方法.</p>
<p>使用面向对象编程, 将其封装:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义员工模板, 不用赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">	<span class="type">int</span> baseSalary;</span><br><span class="line">	<span class="type">int</span> bonus;</span><br><span class="line">	<span class="comment">// grade 不固定, 不在此处定义</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">calculateSalary</span><span class="params">(<span class="type">char</span> grade）&#123;</span></span><br><span class="line"><span class="params">	// 计算奖金系数</span></span><br><span class="line"><span class="params">	<span class="type">double</span> rate = <span class="keyword">switch</span> (grade）&#123;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> -&gt; <span class="number">1.0</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span> -&gt; <span class="number">0.8</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span> -&gt; <span class="number">0.6</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> -&gt; <span class="number">0.4</span>;</span></span><br><span class="line"><span class="params">	<span class="keyword">default</span> -&gt;<span class="number">0</span>;</span></span><br><span class="line"><span class="params">	&#125;;</span></span><br><span class="line"><span class="params">	// 计算薪资</span></span><br><span class="line"><span class="params">	return baseSalary +(<span class="type">int</span>)</span><span class="params">(bonus * rate)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样, 一个员工类就定义好了, 接下来使用它:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="comment">// 使用模板</span></span><br><span class="line">	<span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">	<span class="comment">// 为属性赋值</span></span><br><span class="line">	employee.baseSalary = <span class="number">5000</span>;</span><br><span class="line">	employee.bonus = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用类中计算薪资的方法</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">salary</span> <span class="operator">=</span> employee.calculateSalary( grade: <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">	System.out.println(salary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>


  <div class="note p-4 mb-4 rounded-small default">
    <p>对选中的元素快速定义变量以接收结果: <code>alt</code> + <code>enter</code></p>

  </div>

<h3 id="Getter-and-Setter"><a href="#Getter-and-Setter" class="headerlink" title="Getter and Setter"></a>Getter and Setter</h3><p>为了避免给属性赋错误的值, 我们还需要在类中定义校验方法.</p>
<p>在刚刚封装的类中添加方法</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBaseSalary</span><span class="params">(<span class="type">int</span> baseSalary)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(校验条件)&#123;</span><br><span class="line">		不符合值的处理方法</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 符合的值, 将当前的值赋给类的属性.</span></span><br><span class="line">	<span class="built_in">this</span>.baseSalary = baseSalary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>this</code>. 是为了区分 当前对象 和 方法参数,<br><code>this.baseSalary = baseSalary;</code><br>其含义就是将此方法的参数值赋给当前类</p>
<p>不过此时我们仍然能用老办法 <code>employee.baseSalary = 5000;</code> 的方式赋值,<br>为了只让外部通过 <code>.setBaseSalary</code> , 需要在类的属性添加 <code>private</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> baseSalary;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> bonus;</span><br></pre></td></tr></table></figure></div>

<p>private 限制其只在类的内部使用, 而禁止外部调用.</p>
<p>同理地, 为了安全地获取值, 可以再定义一个 <code>.getBaseSalary</code></p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getBaseSalary</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> baseSalary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>通常, 在做封装时.<br>成员变量 做 <strong>私有化</strong>, 禁止对外访问.<br>同时, 对外提供 <strong>set 和 get 方法</strong>, 使其能正常获取和赋值.</p>
<p>这些对外提供的方法, 称之为 Getter 和 Setter .<br>他们的作用为:<br>能够设置校验, 避免给属性赋错误的值.</p>
<h3 id="降低耦合"><a href="#降低耦合" class="headerlink" title="降低耦合"></a>降低耦合</h3><p>耦合是指事物之间存在相互依赖, 相互影响, 相互制约的情况.<br>在程序设计中是指一个类依赖另一个类的程度.</p>
<p>类与类之间相互协作, 一些耦合是无法避免的.<br>不重要的方法可以使用 <code>private</code> 修饰, 以减少耦合的可能性.</p>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>()</span><br></pre></td></tr></table></figure></div>

<p>调用了<strong>构造方法</strong>, 是由 JVM 自动生成的方法, 会自动为成员变量赋初值, 初值类型由数据类型决定.</p>
<p>自定义构造方法, 让其带参数:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> baseSalary, <span class="type">int</span> bonus)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.baseSalary = baseSalary;</span><br><span class="line">	<span class="built_in">this</span>.bonus = bonus;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 构造方法特点:</span></span><br><span class="line"><span class="comment"> *  1.没有返回值</span></span><br><span class="line"><span class="comment"> *  2.方法名与类名完全一致</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></div>

<p>为了安全调用成员变量, 我们可以使用写好的 Getter 和 Setter:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(<span class="type">int</span> baseSalary, <span class="type">int</span> bonus)</span>&#123;</span><br><span class="line">	setBaseSalary(BaseSalary);</span><br><span class="line">	setBouns(bonus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样, 我们就能更进一步降低耦合, 只将自定义后的构造方法暴露.</p>
<p>当自定义了有参的构造方法, 无参构造就会消失, 可根据实际要求选择是否需要手动定义.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 空参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>封装是面向对象的三大特征之一(封装 继承 多态), 简单来说就是:<br>将数据和操作数据的方法放到一起.</p>
<p>封装降低了耦合, 提高程序的可维护性和可复用性.</p>
<h4 id="如何实现封装"><a href="#如何实现封装" class="headerlink" title="如何实现封装"></a>如何实现封装</h4><ul>
<li>将数据和操作数据的方法放到一个类中, 作为类的<strong>成员变量</strong>和<strong>成员方法</strong>.</li>
<li>成员变量私有化, 对外提供 Getter 和 Setter 方法操作成员变量.</li>
<li>对于必须初始化的变量, 以构造方法来接收参数完成初始化.</li>
<li>使用 Private 隐藏不必要的细节, 只对外暴露必要的方法.</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在程序设计中, 继承是指让一个类继承另一个类的成员, 从而提高代码的复用性.<br>被继承的类叫父类, 继承的类就是子类.</p>
<p>例如, 商品分为实体商品和虚拟商品.</p>
<p>它们都属于商品, 都会有 商品名称 商品价格<br>而实体商品又独特拥有 重量;<br>虚拟商品又独特拥有 卡密.</p>
<p>定义一个父类:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类 Produce</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">displayInfo</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;商品名称：&quot;</span> + name + <span class="string">&quot;，商品价格：&quot;</span> + price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 空参构造</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Product</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>extends</code> 定义子类, 只用声明特有的属性行为:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类 PhysicalProduct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhysicalProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">double</span> weight)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>Java 中一切类都直接或者间接地继承了 Object 类.</p>
<h3 id="调用父类构造"><a href="#调用父类构造" class="headerlink" title="调用父类构造"></a>调用父类构造</h3><p>由于共性成员变量(名称&#x2F;价格)在父类中都是私有的, 无法直接在子类中操作.<br>如何让子类的构造和父类的构造相互协作, 共同完成初始化?</p>
<p>使用关键字 <code>super</code> 可访问当前类的父类.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>(); <span class="comment">// 调用当前父类的构造方法</span></span><br><span class="line"><span class="comment">// ()中没有参数, 调用的是空参构造</span></span><br></pre></td></tr></table></figure></div>

<p>这句代码 JVM 默认会自动生成.</p>
<p>因此, 当我们 <code>new PhysicalProduct()</code> 子类对象时, 会首先执行这句自动生成的代码.<br>结果就是调用了父类构造 <code>Product()</code> 的空参构造.</p>
<p>只要通过 super() 传递参数, 再由父类的有参构造接收参数即可:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类 Produce</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">displayInfo</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;商品名称：&quot;</span> + name + <span class="string">&quot;，商品价格：&quot;</span> + price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.price = price;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有参构造</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(String name, <span class="type">double</span> price)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.price = price;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子类 PhysicalProduct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhysicalProduct</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">double</span> weight)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.weight = weight;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有参构造</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">PhysicalProduct</span><span class="params">(String name, <span class="type">double</span> price, <span class="type">double</span> weight)</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>(name, price); <span class="comment">// 调用父类的有参构造, 对父类的成员变量初始化</span></span><br><span class="line">	<span class="built_in">this</span>.weight = wegiht; <span class="comment">// 对自己的成员变量赋值</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>这时只需要调用子类的构造方法即可让子类的构造和父类的构造相互协作, 共同完成初始化:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">Demo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">PhysicalProduct</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhysicalProduct</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意, 一旦使用有参构造, 默认的空参构造会被覆盖, 默认调用的 <code>super();</code> 找不到空参构造会报错.<br>因此 <code>super(name, price);</code> 是不可少的.</p>
<h3 id="方法的覆写"><a href="#方法的覆写" class="headerlink" title="方法的覆写"></a>方法的覆写</h3><p>覆写（override）也叫重写, 是指子类定义了一个与父类中<strong>声明完全相同</strong>, 但实现不同的方法.<br>子类的实现就覆盖了父类的实现.</p>
<p>例如, 之前商品的例子中, 父类的 <code>displayInfo()</code> 只展示了商品的共性(名称&#x2F;价格).<br>要展示子类独特的成员变量显然是不够的.</p>
<p>重写的方法应在开头加入 <code>@Override</code> 标记, 此标记会自动检测重写是否正确.<br>在子类中覆写 <code>displayInfo()</code> 方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">displayInfo</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">super</span>.displayInfo() + <span class="string">&quot;,商品重量&quot;</span> + weight + <span class="string">&quot;g&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用 <code>super</code> 关键字调用父类的方法, 然后再拼接额外的信息.</p>
<blockquote>
<p>IDEA 覆写快捷键: <code>Ctrl</code> + <code>O</code></p>
</blockquote>
<p>当不希望方法被重写\类被继承, 添加 <code>final</code> 关键字:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br></pre></td></tr></table></figure></div>

<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p>权限修饰符 (AccessModifier) 用来修饰类和类的成员, 它约束了类的成员的可访问范围.</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>作用于本类</th>
<th>相同包下的类</th>
<th>子类</th>
<th>其他类</th>
</tr>
</thead>
<tbody><tr>
<td><code>private</code></td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>default(默认)</code></td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>protected</code></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td><code>public</code></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>多态 (Polymorphism) 就是事物具有多种不同形态, 或者同一行为, 具有多种不同表现.</p>
<p>设计一个创建订单的方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PhysicalProduct</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhysicalProduct</span>(<span class="string">&quot;手机&quot;</span>,<span class="number">1999</span>,<span class="number">672</span>);</span><br><span class="line"><span class="type">DigitalProduct</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DigitalProduct</span>(<span class="string">&quot;充值卡&quot;</span>,<span class="number">99.9</span>,<span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类型变量指向子类型的对象, JVM会隐式类型转换, 向上将子类型转换为父类型</span></span><br><span class="line">createOrder(p);</span><br><span class="line">createOrder(d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(Product product)</span>&#123;</span><br><span class="line">	<span class="comment">// 向上转型只能调用父类方法</span></span><br><span class="line">	System.out.println(product.displayInfo())</span><br><span class="line">	System.out.println(<span class="string">&quot;订单已确定&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>一般不会使用向下转型, 了解即可:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(Product product)</span>&#123;</span><br><span class="line">	<span class="comment">// 向下转型必须判断类型</span></span><br><span class="line">	<span class="keyword">if</span> (product <span class="keyword">instanceof</span> PhysicalProduct)&#123;</span><br><span class="line">		<span class="type">PhysicalProduct</span> <span class="variable">p</span> <span class="operator">=</span> (PhysicalProduct) product;</span><br><span class="line">		p.setWeight(<span class="number">586.00</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(product.displayInfo())</span><br><span class="line">	System.out.println(<span class="string">&quot;订单已确定&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>抽象 (Abstract) 是与具体相对应的概念, 代表事物中共性的但不确定的特征.</p>
<p>例如实体商品和虚拟商品, 它们都应有一个发货的行为, 但不确定行为的具体表现.<br>实体商品通过邮寄发货, 虚拟商品通过发送卡密信息发货.</p>
<p>“发货”这个方法, 就可以称之为 抽象方法.<br>定义抽象方法的类, 就是抽象类.</p>
<p>在父类 Product 使用 <code>abstract</code> 关键字, 定义 抽象方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">sendProduct</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></div>

<p>抽象方法必须定义在抽象类中, 被抽象的类无法再用 new 方法实例化</p>
<p>在实体商品和虚拟商品中添加定义发货的方法:</p>
<ul>
<li>实体商品</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendProduct</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;通过物流发货&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>虚拟商品</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendProduct</span><span class="params">()</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;通过网络发货&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>新建测试类:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	<span class="type">PhysicalProduct</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhysicalProduct</span>(<span class="string">&quot;华为Mate70&quot;</span>, <span class="number">7299.00</span>, <span class="number">672.00</span>) ;</span><br><span class="line">	<span class="type">DigitalProduct</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DigitalProduct</span>(<span class="string">&quot;Appstore 充值卡&quot;</span>, <span class="number">99.9</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用数组存储多个</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendProducts</span><span class="params">(Product[] products)</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; products.length; i++) &#123;</span><br><span class="line">			<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> products[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>IDEA 中 输入 <code>需要遍历的变量名称.fori</code> 回车, 即可自动生成 for 循环.</p>
<h1 id="static-静态"><a href="#static-静态" class="headerlink" title="static 静态"></a>static 静态</h1><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>静态变量就是类中用 static 关键字修饰的变量, 静态变量是属于类的变量, 可以理解为一类事物的共享属性.</p>
<ul>
<li>静态变量随着类首次使用而加载，并且完成初始化</li>
<li>使用静态变量无需创建对象，可以直接使用<code>类名.变量名</code>访问</li>
</ul>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>静态方法就是类中用 static 关键字修饰的方法, 静态方法是属于类的方法.</p>
<ul>
<li>静态方法无需创建对象, 直接用<code>类名.方法名</code>调用.</li>
<li>静态方法中不能直接访问非静态成员（变量和方法）, 只能访问静态成员.</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">// 静态方法不能使用 this 关键字</span></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><p>静态的实际用途是用来做工具类.</p>
<p>工具类是用来封装某一非业务领域内一些通用的公共方法的类.<br>由于这些方法不需要用到实例变量, 仅仅是作为工具方法使用, 因此通常都是静态的.</p>
<p>例如, 一个角度转弧度的方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathUtil</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">STRAIGHT_ANGLR</span> <span class="operator">=</span> <span class="number">180</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">toRadians</span> <span class="params">(<span class="type">double</span> degrees)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> degrees * <span class="number">3.14</span> / <span class="number">180</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h3><p>静态工厂方法就是在类中提供一个用来创建对象的静态方法来代替构造方法.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span>() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 提供一个用来创建对象的静态方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Worker <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		ruturn <span class="keyword">new</span> <span class="title class_">Worker</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>为什么要这样多此一举呢?<br>先来几个案例:</p>
<h4 id="简化开发"><a href="#简化开发" class="headerlink" title="简化开发"></a>简化开发</h4><p>例如, 定义一个代表程序运行结果的类 Result, 具备以下属性:</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>int</td>
<td>结果状态码: <br>0 成功, 1 失败</td>
</tr>
<tr>
<td>msg</td>
<td>String</td>
<td>结果描述: <br>ok 表示成功, 失败描述失败原因</td>
</tr>
<tr>
<td>data</td>
<td>Object</td>
<td>运行成功返回的结果数据</td>
</tr>
</tbody></table>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">	<span class="keyword">private</span> String msg;</span><br><span class="line">	<span class="comment">// 使用 Object 顶级父类,以此来接收任意类型</span></span><br><span class="line">	<span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(<span class="type">int</span> code, String msg, Object data)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.code = code;</span><br><span class="line">		<span class="built_in">this</span>.msg  = msg;</span><br><span class="line">		<span class="built_in">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略了Getter Setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>假设通过 id 查询学生信息, 有 查询成功(有返回结果) 和失败 两种情况,<br>通过 id 删除学生信息, 有 删除成功(无返回结果) 和 失败 两种情况.<br>如果不使用静态工厂方法:</p>
<ul>
<li>成功,有返回结果:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, <span class="string">&quot;OK&quot;</span>, student)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>成功, 无返回结果:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, <span class="string">&quot;Ok&quot;</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>失败, 返回错误信息, 无返回结果:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>, <span class="string">&quot;id不能小于0&quot;</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// null 代表是空, 通常是指一个引用类型数据不存在</span></span><br></pre></td></tr></table></figure></div>

<p>每一次需要此对象时, 都必须如此声明.<br>虽然编译不报错, 但可以使用 静态工厂方法 来进一步简化.</p>
<p>在 Reslut 类中定义 静态工厂方法.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 成功,有返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">(Object data)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, <span class="string">&quot;OK&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功, 无返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">ok</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ok(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">fail</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">1</span>, msg, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在测试类中调用定义的方法:</p>
<ul>
<li>成功,有返回结果:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Result.ok(student);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>成功, 无返回结果:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">0</span>, <span class="string">&quot;Ok&quot;</span>, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>失败, 返回错误信息, 无返回结果:</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Result.fail(<span class="string">&quot;id不能小于0&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p>增强了可读性和可维护性</p>
<h4 id="避免重复创建对象"><a href="#避免重复创建对象" class="headerlink" title="避免重复创建对象"></a>避免重复创建对象</h4><p>有这样一个需求:<br>定义一个表示性别的类 Gender, 包含以下属性.</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>int</td>
<td>性别标识:<br>0 代表男, 1 代表女</td>
</tr>
<tr>
<td>lable</td>
<td>String</td>
<td>性别标签:<br>男, 女</td>
</tr>
</tbody></table>
<p>首先定义一个传统的 Gender 类.<br>包含 属性, 有参构造和 Getter Setter.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Gender</span><span class="params">(<span class="type">int</span> value String label)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">		<span class="built_in">this</span>.label = label;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getLabel</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> label;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLabel</span><span class="params">(String label)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.label = label;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用这个传统的 Gender 类, 会遇到如下问题:</p>
<ul>
<li>能重复创建对象, 导致空间浪费.</li>
<li>创建对象无限制, 会出现意料之外的错误(创建了两种以上的性别标签).</li>
<li>数字与标识的关联不强(每次用 if 判断来识别标签).</li>
</ul>
<p>为了避免这些问题, 可以这样修改:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.构造方法私有化, 禁止在外部随意创建对象, 只能通过内部的工厂方法创建</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Gender</span><span class="params">(<span class="type">int</span> value String label)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">		<span class="built_in">this</span>.label = label;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3.使用常量预先构造好对象, 避免重复创建</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Gender</span> <span class="variable">MALE</span> <span class="operator">=</span> Gender(<span class="number">0</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Gender</span> <span class="variable">FEMALE</span> <span class="operator">=</span> Gender(<span class="number">2</span>, <span class="string">&quot;女&quot;</span>)</span><br><span class="line">	<span class="comment">// 2.使用工厂方法规定创建的对象类型</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Gender <span class="title function_">male</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MALE</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Gender <span class="title function_">female</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FEMALE</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.根据值得到当前类对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Gender <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(value != <span class="number">0</span> &amp;&amp; != <span class="number">1</span> )</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;性别参数不合法.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getLabel</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> label;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLabel</span><span class="params">(String label)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.label = label;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="创建不同子类"><a href="#创建不同子类" class="headerlink" title="创建不同子类"></a>创建不同子类</h4><p>在父类中定义创建子类的方法.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> PhysicalProduct <span class="title function_">createPhysicalProduct</span><span class="params">(String name, <span class="type">double</span> price, <span class="type">double</span> weight)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PhysicalProduct</span>(name, price, weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样定义所有的子类方法后,</p>
<blockquote>
<p>快捷键:<br>快速生成变量 <code>Alt</code> + <code>Enter</code><br>在变量后输入 <code>.var</code> 回车, 也是同样的效果.</p>
</blockquote>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块就是用大括号括起来, 独立于方法之外的代码片段</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CodeBlock</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;无参构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;普通方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//代码块</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>静态代码块在类的加载时执行, 用于处理静态成员变量.<br>构造代码块在每次构造方法加载时执行, 用于处理普通的成员变量.</p>
<p>运行以下代码:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock</span>&#123;</span><br><span class="line"><span class="comment">// 1.类加载和初始化的顺序</span></span><br><span class="line"><span class="comment">// 1.1 静态成员变量的初始化</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	<span class="comment">// 2.对象创建的流程</span></span><br><span class="line">	<span class="comment">// 2.1 普通成员变量初始化</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	<span class="comment">// 2.3 构造方法初始化</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CodeBlock</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">		System.out.println(<span class="string">&quot;无参构造方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;普通方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 2.2 构造代码块初始化</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;num2的初始值:&quot;</span> + num2);</span><br><span class="line">		num2 = <span class="number">20</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;构造代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 1.2 静态代码块执行, 只在类加载后初始化时执行一次</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;num的初始值:&quot;</span> + num);</span><br><span class="line">	num++;</span><br><span class="line">		System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + CodeBlock.num);</span><br><span class="line">        System.out.println(<span class="string">&quot;num = &quot;</span> + CodeBlock.num);</span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">        <span class="type">CodeBlock</span> <span class="variable">cb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeBlock</span>();</span><br><span class="line">        cb1.func();</span><br><span class="line">        System.out.println(<span class="string">&quot;======================&quot;</span>);</span><br><span class="line">        <span class="type">CodeBlock</span> <span class="variable">cb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeBlock</span>();</span><br><span class="line">        cb2.func();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>所得结果:</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">num的初始值:100</span><br><span class="line">静态代码块</span><br><span class="line">num = 101</span><br><span class="line">num = 101</span><br><span class="line">======================</span><br><span class="line">num2的初始值:10</span><br><span class="line">构造代码块</span><br><span class="line">num2 = 20</span><br><span class="line">无参构造方法</span><br><span class="line">普通方法</span><br><span class="line">======================</span><br><span class="line">num2的初始值:10</span><br><span class="line">构造代码块</span><br><span class="line">num2 = 20</span><br><span class="line">无参构造方法</span><br><span class="line">普通方法</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></div>

<pre class="mermaid">graph TD
    A(类加载) --> B[静态成员变量初始化]
    B --> C[静态代码块执行]
    C --> D(类初始化完成)

    E(对象创建) --> F[普通成员变量初始化]
    F --> G[构造代码块执行]
    G --> H[构造方法执行]
    H --> I(对象创建完成)</pre>

<h4 id="静态代码块案例"><a href="#静态代码块案例" class="headerlink" title="静态代码块案例"></a>静态代码块案例</h4><p>需求: 定义一个表示交通信号灯的类 TrafficLight, 包含下列属性:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrafficLight</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">private</span>  TrafficLight nextLight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">TrafficLight</span><span class="params">(String label)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TrafficLight RED;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TrafficLight YELLOW;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TrafficLight GREEN;</span><br><span class="line">	<span class="comment">// 使用静态代码块初始化</span></span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">	    RED = <span class="keyword">new</span> <span class="title class_">TrafficLight</span>(<span class="string">&quot;红&quot;</span>);</span><br><span class="line">	    YELLOW = <span class="keyword">new</span> <span class="title class_">TrafficLight</span>(<span class="string">&quot;黄&quot;</span>);</span><br><span class="line">	    GREEN = <span class="keyword">new</span> <span class="title class_">TrafficLight</span>(<span class="string">&quot;绿&quot;</span>);</span><br><span class="line">	    RED.nextLight = YELLOW;</span><br><span class="line">	    YELLOW.nextLight = GREEN;</span><br><span class="line">	    GREEN.nextLight = YELLOW;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLabel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> label;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TrafficLight <span class="title function_">getNextLight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextLight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>调用:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(TrafficLight.GREEN.getLabel()+<span class="string">&quot;灯下一个灯是&quot;</span>+TrafficLight.GREEN.getNextLight().getLabel()+<span class="string">&quot;灯&quot;</span>);</span><br><span class="line">    System.out.println(TrafficLight.YELLOW.getLabel()+<span class="string">&quot;灯下一个灯是&quot;</span>+TrafficLight.YELLOW.getNextLight().getLabel()+<span class="string">&quot;灯&quot;</span>);</span><br><span class="line">    System.out.println(TrafficLight.RED.getLabel()+<span class="string">&quot;灯下一个灯是&quot;</span>+TrafficLight.RED.getNextLight().getLabel()+<span class="string">&quot;灯&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">绿灯下一个灯是黄灯</span><br><span class="line">黄灯下一个灯是绿灯</span><br><span class="line">红灯下一个灯是黄灯</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></div>

<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>前面提到过耦合, 耦合是指不同模块 (如类、方法等) 之间相互依赖的程度.<br>为了减少耦合, 尽可能隐藏类中的细节.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/file-20250125131236947.jpg"
                     
                ></p>
<p>不过这种方式终究还是无法避免耦合,<br>接口为此而生.</p>
<p>接口 <strong>(Interface)</strong> 是一种类似于 class 的类型,但是只定义方法的声明, 不定义具体实现.</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rollable</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> roll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>例如制作饺子皮, 一般都使用擀面杖来制作.<br>不过非得要擀面杖来制作吗?</p>
<p>擀饺子皮，重在不在于用什么’工具’，重点在于’擀’.<br>‘擀’就是接口中的方法，擀面杖、火腿肠、苹果，都是’擀‘的实现类.</p>
<p>这样擀面杖与制作饺子皮就解除耦合了.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/file-20250125131737164.jpg"
                     
                ></p>
<p>接口只定义需要什么样的行为, 具体实现由其他类来实现.<br>接口解除类与类的耦合, 提高代码的拓展性.</p>
<p>新建一个接口:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Coupon</span>&#123;</span><br><span class="line">	<span class="comment">// 接口默认为 public abstract, 可以省略</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">calculateDiscount</span><span class="params">(<span class="type">double</span> totalPrice)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实现这个接口:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriceDiscountCoupon</span> <span class="keyword">implements</span> <span class="title class_">Coupon</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> threshold;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> discount;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">PriceDiscountCoupon</span><span class="params">(<span class="type">int</span> threshold, <span class="type">int</span> discount)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.threshold = threshold;</span><br><span class="line">		<span class="built_in">this</span>.discount = discount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span> <span class="comment">// 加上此注解以便于更好地排查错误</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculateDiscount</span><span class="params">(<span class="type">double</span> totalPrice)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> totalPrice &gt;= threshold ? discount : <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用接口:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Product product;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> amout;</span><br><span class="line">	<span class="comment">// 使用接口</span></span><br><span class="line">	<span class="keyword">private</span> Coupon coupon;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(Product product, <span class="type">int</span> amount, <span class="type">int</span> amount, <span class="type">int</span> threshold, <span class="type">int</span> discount)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.product = product;</span><br><span class="line">		<span class="built_in">this</span>.amount = amount;</span><br><span class="line">		<span class="comment">// 仍然存在耦合</span></span><br><span class="line">		<span class="built_in">this</span>.coupon = <span class="keyword">new</span> <span class="title class_">PriceDiscountCoupon</span>(threshold, discount);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showOrderInfo</span><span class="params">()</span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入(Dependency Injection) 是一种软件设计模式, 它要求类不再创建他所依赖的对象,而是由其他类提供并注入这些依赖项.</p>
<p>依赖注入常见方式:</p>
<h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接接收优惠券对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(Product product, <span class="type">int</span> amount, <span class="type">int</span> amount, Coupon coupon)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.product = product;</span><br><span class="line">		<span class="built_in">this</span>.amount = amount;</span><br><span class="line">		<span class="built_in">this</span>.coupon = coupon;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>

<p>使用者注入对象:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">void</span> main(String[] args)&#123;</span><br><span class="line">	<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> Product.createPhysicalProduct( name:<span class="string">&quot;华为Mate70&quot;</span>, price: <span class="number">7299.00</span>, weight:<span class="number">672.00</span>);</span><br><span class="line">	<span class="comment">// 需要提前创建好对象</span></span><br><span class="line">	<span class="type">Coupon</span> <span class="variable">coupon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PriceDiscountCoupon</span>(threshold:<span class="number">9000</span>,discount:<span class="number">1000</span>)</span><br><span class="line">	<span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(product, amount: <span class="number">2</span>,coupon);</span><br><span class="line"></span><br><span class="line">	order.showorderInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>能在创建对象那一刻, 立马将所需要的依赖项都注入.<br>适用于明确知道对象不再变化.</p>
<h4 id="setter-注入"><a href="#setter-注入" class="headerlink" title="setter 注入"></a>setter 注入</h4><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在setter中接收优惠券对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCoupon</span><span class="params">(Coupon coupon)</span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.coupon = coupon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Coupon</span> <span class="variable">coupon</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RateDiscountCoupon</span>(<span class="number">9000</span>,<span class="number">85</span>);</span><br><span class="line">order.setCoupon(coupon);</span><br><span class="line"></span><br><span class="line">order.showorderInfo();</span><br></pre></td></tr></table></figure></div>

<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>接口时定义要做什么, 尽量不要变化.<br>类时定义怎么做, 可以看作是协议的履行者.</p>
<h3 id="接口分离"><a href="#接口分离" class="headerlink" title="接口分离"></a>接口分离</h3><p>接口分离原则（InterfaceSegregationPrinciple）也叫接口隔离原则.</p>
<ul>
<li>一个接口中应该只包含相同职责的方法, 尽可能少的方法, 方法过多时应考虑拆分接口.</li>
</ul>
<p>注意事项:</p>
<ul>
<li>Java 中 1 个类可以实现多个接口, 但是只能单继承</li>
<li>接口之间是可以继承的, 而且可以多继承.</li>
</ul>
<p>例如三个类只需要接口中的一部分方法.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/file-20250204104044568.jpg"
                     
                ></p>
<p>只需要将接口拆分成三个即可.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/java%E5%85%A5%E9%97%A8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/file-20250204104100749.jpg"
                     
                ></p>
<p>实际案例, 实现快捷键和鼠标点击的事件监听:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onclick</span><span class="params">()</span>; <span class="comment">// 处理用户鼠标点击</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onkeydown</span><span class="params">(String key)</span>; <span class="comment">// 处理用户按下键盘</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onchange</span><span class="params">()</span>; <span class="comment">// 监控用户输入内容做补全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如此将全部功能定义在一个接口中, 我们在实现接口时, 就不得不把接口中所有的功能都实现:<br>例如我只想在这个类中实现 <code>onclick()</code> 方法:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageEventListener</span> <span class="keyword">implements</span> <span class="title class_">EventListener</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onclick</span><span class="params">()</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;展开包中的文件.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 并不需要实现下列方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onkeydown</span><span class="params">(String key)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onchange</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此时遵守接口分离原则更为便利<br>将接口按功能和需求拆分:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MouseEventListener</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onclick</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意: 一个类中只能有一个接口</p>
<p>同理的, 接着拆分:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">KeyEventListener</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onkeydown</span><span class="params">(String key)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样, 原接口还剩下:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onchange</span><span class="params">()</span>; <span class="comment">// 监控用户输入内容做补全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这样三个接口就独立开来.<br>只想在这个类中实现 <code>onclick()</code> 方法时只需要:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageEventListener</span> <span class="keyword">implements</span> <span class="title class_">EventListener</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onclick</span><span class="params">()</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;展开包中的文件.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>即可.</p>
<h4 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h4><p>如果又同时需要两个接口有以下两种方法:</p>
<h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PackageEventListener</span> <span class="keyword">implements</span> <span class="title class_">EventListener</span>, KeyEventListener&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onclick</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;展开包中的文件.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onkeydown</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;快捷键被按下了.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>实现多个接口, 适用于需要实现的接口数量较少.</p>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>当需要实现的接口数量较多, 可以使用继承的方式组合多个接口:</p>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EventListener</span> <span class="keyword">extends</span> <span class="title class_">MouseEventListener</span>, EventListener&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">onchange</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="其他特性-了解"><a href="#其他特性-了解" class="headerlink" title="其他特性(了解)"></a>其他特性(了解)</h3><p>在 Java 发展的过程中, Interface 添加了很多本来不应该属于它的特性, 例如:</p>
<ul>
<li>接口中的变量默认就是 public static final，也就是静态常量</li>
<li>接口中可以定义静态方法，可以直接用接口名.方法名调用</li>
<li>接口中可以定义默认方法，实现接口的类可以不用实现该方法</li>
</ul>
<div class="code-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="comment">//静态常量，默认是 public staticfinal</span></span><br><span class="line"><span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159265354979323846</span>;</span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="title function_">calculatePerimeter</span><span class="params">(<span class="type">double</span> radius）&#123;</span></span><br><span class="line"><span class="params">return <span class="number">2</span> _ PI _ radius;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">//默认方法</span></span><br><span class="line"><span class="params"><span class="keyword">default</span> <span class="type">double</span> calculateArea(<span class="type">double</span> radius）&#123;</span></span><br><span class="line"><span class="params">return PI * radius * radius;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>什么时候需要使用接口（解除与依赖项之间的耦合关系）？</p>
<ul>
<li>依赖的类将来有可能会升级或替换</li>
<li>与第三方系统对接，可能更换第三方服务提供者，例如支付、发短信</li>
<li>通过接口定义协议，不断开发新的接口实现类来拓展新功能</li>
</ul>
<p>接口和抽象类有什么区别？</p>
<ul>
<li>接口，用来定义协议，实现低耦合、拓展性强的代码</li>
<li>抽象类，部分实现的类，用来在子类之间共享代码</li>
</ul>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>封装与继承</tag>
        <tag>接口与多态</tag>
      </tags>
  </entry>
  <entry>
    <title>Web-互联网与星辰大海</title>
    <url>/2024/11/21/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-Web-%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8E%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7/</url>
    <content><![CDATA[<p>Web 就是全球广域网, 也称为万维网(www World Wide Web).<br>Web 指的就是能够通过浏览器访问的网站.</p>
<p>而我们要想开发一个 web 网站, 那首先就得知道 web 网站的基本结构.</p>
<h1 id="Web-网站结构"><a href="#Web-网站结构" class="headerlink" title="Web 网站结构"></a>Web 网站结构</h1><p>一个 web 网站的核心, 是由以下三个部分组成:</p>
<ul>
<li>前端程序：负责将数据以好看的样式<strong>呈现</strong>出来。</li>
<li>后端程序：负责具体的业务逻辑的<strong>处理</strong>。</li>
<li>数据库：负责数据的<strong>存储和管理</strong>。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/web-%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8E%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7/file-20241201160801897.jpg"
                     
                ></li>
</ul>
<p>当我们在浏览器地址栏, 输入 url 地址, 一敲回车.<br>此时首先访问到的是服务器中部署的 <strong>前端程序</strong>, 而前端程序仅仅负责将数据以好看的样式呈现出来.</p>
<p>前端展示的数据从哪里来呢? 前端程序会发送请求来请求<strong>服务端&#x2F;后端程序</strong>，由服务端&#x2F;后端程序来查询<strong>数据库</strong>, 然后将数据库查询的数据返回给前端.</p>
<p>最终, 前端程序再将数据渲染, 再由浏览器来解析前端程序.<br>这样, 一个精美的网页就展示在浏览器中了.</p>
<h1 id="Web-前端"><a href="#Web-前端" class="headerlink" title="Web 前端"></a>Web 前端</h1><p>前端开发，主要的职责就是将数据以好看的样式呈现出来。</p>
<p>不同的浏览器，内核不同，对于相同的前端代码解析的效果也会存在差异。为了避免这个差异，就需要定义一个统一的标准，然后让各大浏览器厂商都参照这个标准来实现即可。</p>
<p>这就是接下来要介绍的 <strong>web 标准</strong>。</p>
<p><strong>Web 标准</strong> 也称为 网页标准, 由三个组成部分：</p>
<ul>
<li>[[前端&#x2F;网页之骨架-HTML]]：负责网页的结构（页面元素和内容）。</li>
<li><a href="%E5%89%8D%E7%AB%AF/%E7%BD%91%E9%A1%B5%E4%B9%8B%E8%A1%A3%E8%A3%B3-CSS.md">网页之衣裳-CSS</a>：负责网页的表现（页面元素的外观、位置等页面样式，如：颜色、大小等）。</li>
<li><a href="%E5%89%8D%E7%AB%AF/%E7%BD%91%E9%A1%B5%E4%B9%8B%E5%A4%A7%E8%84%91-Javascript.md">网页之大脑-Javascript</a>：负责网页的行为（交互效果）。</li>
</ul>
<p>通过这三项技术, 就足够制作前端页面了.</p>
<p>除了这前端三件套以外，基础部分还有：</p>
<ul>
<li>[[前端&#x2F;Ajax-异步交互]]</li>
</ul>
<p>除了这些基础内容，目前的前端大多都会使用更高级的框架，例如</p>
<ul>
<li>[[前端&#x2F;渐进式框架-VUE]]</li>
<li>Element Plus</li>
<li>Tlias</li>
</ul>
<h1 id="Web-后端"><a href="#Web-后端" class="headerlink" title="Web 后端"></a>Web 后端</h1><p>Web 后端开发, 主要负责处理前端发送的请求、执行业务逻辑、与数据库交互以及管理服务器.<br>后端是网站和应用程序的“大脑”, 它处理着数据的存储、检索和业务逻辑.</p>
<p>像前面提到的 HTML、CSS、JS 以及图片、音频、视频等这些资源，我们都称为 <strong>静态资源</strong> .<br>与静态资源对应的, 就是 <strong>动态资源</strong> .</p>

  <div class="note-large default">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <i class="notel-icon fa-solid fa-info"></i><p>资源分类</p>

    </div>
    <div class="notel-content">
      <p>静态资源: 指在服务器上存储的, 不会改变的数据, 通常不会根据用户的请求而变化.<br>动态资源: 指在服务器端上存储的，会根据用户请求和其他数据动态生成的，内容可能会在每次请求时都发生变化.</p>

    </div>
  </div>

<p>比如：Servlet、JSP 等(负责逻辑处理)。而 Servlet、JSP 这些技术现在早都被企业淘汰了，现在在企业项目开发中，都是直接 <strong>基于 Spring 框架</strong> 来构建动态资源.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/web-%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%8E%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7/file-20241201161835843.jpg"
                     
                ></p>
<p>而对于我们 java 程序开发的动态资源来说，我们通常会将这些动态资源部署在 <strong>Tomcat</strong>，这样的 Web 服务器中运行。 而浏览器与服务器在通信的时候，基本都是 <strong>基于 HTTP 协议的</strong> .</p>
<p>上述所描述的这种 <strong>浏览器&#x2F;服务器</strong> 的架构模式呢，我们称之为：<strong>BS 架构</strong>。</p>
<ul>
<li>BS 架构：Browser&#x2F;Server, 浏览器&#x2F;服务器架构模式. 客户端只需要浏览器, 应用程序的逻辑和数据都存储在服务端.</li>
</ul>
<p>还有一种 <strong>客户端&#x2F;服务器</strong> 的架构, 需要单独下载客户端的方式, 称之为 <strong>CS 架构</strong>.</p>
<ul>
<li>CS 架构：Client&#x2F;Server, 客户端&#x2F;服务器架构模式. 需要单独开发维护客户端.</li>
</ul>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>环境变量</title>
    <url>/2024/12/21/%E7%8C%8E%E8%AF%86%E5%8D%B0%E8%AE%B0-%E9%A2%86%E5%9F%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%80%9A%E8%AF%86-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p><strong>如何通过“运行”对话框打开程序？</strong></p>
<ol>
<li>按下  <code>Win + R</code>  打开“运行”对话框。</li>
<li>输入  <code>cmd</code>  并回车，即可打开命令提示符（cmd 也算是一个 exe 程序）。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221161809785.jpg"
                     
                ></p>
<p>但如果你尝试输入一个别的 exe，例如 <code>QQ.exe</code>，可能会发现无法运行——这正是环境变量在起作用！</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221161951459.jpg"
                     
                ></p>
<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p><strong>环境变量是什么？</strong><br>环境变量就像系统的“快捷地址簿”。当你输入一个程序名（如  <code>cmd</code>），系统会快速从地址簿（Path 变量）中查找程序的位置。</p>
<blockquote>
<p>⚠️ <strong>注意</strong><br>修改环境变量需谨慎！错误操作可能导致系统无法找到关键程序（如系统忘记如何“呼吸”）。</p>
</blockquote>
<h3 id="如何查看环境变量？"><a href="#如何查看环境变量？" class="headerlink" title="如何查看环境变量？**"></a>如何查看环境变量？**</h3><p>打开设置, 在 关于 系统 -&gt; 系统高级设置 中即可找到<code>环境变量</code>.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221152757090.jpg"
                     
                ></p>
<p>也可以按下  <code>Win + S</code>  搜索“环境变量”:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221152349580.jpg"
                     
                ></p>
<p>打开面板, 我们不难发现, cmd 的路径 <code>(C:\Windows\System32)</code> 就在其中:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221164423296.jpg"
                     
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221163834724.jpg"
                     
                ></p>
<p>因此, “运行”对话框实际上是在环境变量配置的路径中寻找程序.<br>如果能够找到指定程序的路径就运行,<br>反之则报错.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221163746469.jpg"
                     
                ></p>
<p>你可能注意到了 CMD 的实际目录是 <code>C:\Windows\System32</code><br>而在环境变量 PATH 中指定的目录是 <code>%SystemRoot%\system32</code></p>
<p>这是由于虽然系统默认安装在 C 盘, 但是也可由用户指定位置.<br>为了灵活应对, Windows 就规定了 <code>%SystemRoot%</code> 的变量来存放系统安装的位置.<br>Windows 安装程序会将<code>%SystemRoot%</code>环境变量设置为安装目录的路径，通常是<code>C:\Windows</code>.</p>
<h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><p>一般而言, 我们并不需要通过 “运行” 对话框, 或是使用命令行来运行 QQ 这种程序.<br>环境变量更多地用于配置那些在命令行中运行的程序，比如 Java 和 Python 这样的开发工具.</p>
<p>使用命令行 运行程序时, 命令行会:</p>
<ul>
<li>默认会在 <strong>当前的目录</strong> 下寻找指定的程序.</li>
<li>未找到, 则会尝试去 <strong>Path 环境变量</strong> 中指定的路径寻找.</li>
</ul>

  <div class="note-large red">
    <div class="notel-title rounded-t-lg p-3 font-bold text-lg flex flex-row gap-2 items-center">
      <p>再次提醒!</p>

    </div>
    <div class="notel-content">
      <p>错误地编辑注册表可能会损坏系统!<br>编辑更改注册表前请确保你知道你在做什么.</p>

    </div>
  </div>

<p>那就拿熟悉点的 QQ 来举例吧!</p>
<h3 id="方式一-默认路径"><a href="#方式一-默认路径" class="headerlink" title="方式一 默认路径"></a>方式一 默认路径</h3><p>我的 QQ 安装在了这个文件夹下:<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221171313140.jpg"
                     
                ></p>
<p>我们可以尝试通过 CMD 命令行 打开, 在桌面时 <code>win</code>+<code>r</code> <code>回车</code>, 快捷打开命令行.<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221171655673.jpg"
                     
                ><br>可以观察到当前命令行所在的路径为 <code>C:\Users\Wreckloud</code><br>显而易见地, QQ 并不在这个目录中, 尝试运行一下, 直接输入应用程序的名称即可运行:</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">QQ.exe</span><br></pre></td></tr></table></figure></div>

<p>也是在预料之内的:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221171956227.jpg"
                     
                ></p>
<p>接下来我们将命令行的路径切换到 <code>QQ.exe</code> 所在的目录中:<br>常用以下两种方式打开指定的路径.</p>
<h4 id="在命令行中使用指令切换路径"><a href="#在命令行中使用指令切换路径" class="headerlink" title="在命令行中使用指令切换路径"></a>在命令行中使用指令切换路径</h4><p>使用指令: <code>cd 路径</code> 即可将命令行切换到指定的路径.</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:\Program Files\Tencent\QQNT</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>关于命令行的更多指令, 请 [[windows命令行与批处理|看这里!]]</p>
</blockquote>
<h4 id="在文件浏览器中用命令行打开指定路径"><a href="#在文件浏览器中用命令行打开指定路径" class="headerlink" title="在文件浏览器中用命令行打开指定路径"></a>在文件浏览器中用命令行打开指定路径</h4><p>我更推荐:<br>直接在文件夹中找到需要的文件, 然后在地址栏输入 <code>cmd</code> 并回车.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221172536631.jpg"
                     
                ></p>
<p>两种方式都能让命令行转到指定的路径中:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221172632464.jpg"
                     
                ></p>
<p>再尝试在这个路径下输入 <code>QQ.exe</code> .</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221172727445.jpg"
                     
                ></p>
<p>成功地打开了, 但这种方式并不是重头戏.<br>这样也成功验证了 在安装目录以外的地方没办法使用命令行打开 QQ.</p>
<h3 id="方式二-Path-中的路径"><a href="#方式二-Path-中的路径" class="headerlink" title="方式二 Path 中的路径"></a>方式二 Path 中的路径</h3><p>只要类似 cmd 的, 将自己的安装路径配置在 Path 中, 命令行就可以在任意位置找到并打开 QQ.exe 了.</p>
<p>打开 环境变量 ,在 系统变量中 双击 Path.<br>接着将 <code>D:\Program Files\Tencent\QQNT</code> 配置到 Path 环境变量中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221174016322.jpg"
                     
                ></p>
<p>打开一个 <strong>新的</strong> 命令行, 尝试在任意位置执行 QQ.exe:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221174130557.jpg"
                     
                ></p>
<blockquote>
<p>带后缀(.exe)地, 不带后缀地都可以执行此程序.</p>
</blockquote>
<h1 id="环境变量的用途"><a href="#环境变量的用途" class="headerlink" title="环境变量的用途"></a>环境变量的用途</h1><p>环境变量实际可用于 版本控制.<br>例如 Java, 我们可以在一台计算机中安装多个版本的环境变量.</p>
<p>在 环境变量 Path 中指定所需要的 Java 路径(注意指定的是 <code>java.exe</code> 与 <code>javac.exe</code> 所在的路径):</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241222131553091.jpg"
                     
                ></p>
<p>将此路径新建到 环境变量的 Path 中.<br>打开一个新的终端查看 Java 版本.</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure></div>

<p>我们提到过, Path 中有许多重要的路径, 不建议直接修改 Path 的内容.<br>我们可以模仿系统的 <code>%SystemRoot%</code> 做法, 也为 Java 设置一个 <code>%JAVA_HOME%</code> 的变量.<br><code>% %</code>代表引用环境变量.</p>
<p>这样, 控制版本时, 只需要在外修改变量的值, 从而避免频繁修改 Path 的内容.</p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>在环境变量中新建系统环境变量:</p>
<div class="code-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">JAVA_HOME</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241222132654859.jpg"
                     
                ></p>
<p>再在 Path 中新建, 引用词变量 (注意指定的是 <code>java.exe</code> 与 <code>javac.exe</code> 所在的路径):</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241222133843666.jpg"
                     
                ></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之, 在绝大部分的情况下, 我们配置环境变量只是为了在任何一处都能用命令行或是别的什么, 来便利地运行所需程序.</p>
<p>这是一个很常用的功能.<br>既然如此, 现代的软件在设计时就考虑到了这一点.</p>
<p>在它们安装时, 通常会自带有将安装目录写入 Path 的选项:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../../../img/%E6%96%87%E7%AB%A0%E8%B5%84%E6%BA%90/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/file-20241221174828554.jpg"
                     
                ></p>
<p>如果在命令行中遇到了:<br><code>xxx&#39; 不是内部或外部命令，也不是可运行的程序或批处理文件.</code><br>那么就检查一下 Path 路径是否配置正确吧.</p>
]]></content>
      <categories>
        <category>猎识印记-领域</category>
        <category>计算机通识</category>
      </categories>
      <tags>
        <tag>环境变量</tag>
        <tag>命令行</tag>
        <tag>系统管理</tag>
      </tags>
  </entry>
</search>
